{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#datar","title":"datar","text":"<p>A Grammar of Data Manipulation in python</p> <p>  []5 []13 []13 []7</p> <p>Documentation | Reference Maps | Notebook Examples | API</p> <p><code>datar</code> is a re-imagining of APIs for data manipulation in python with multiple backends supported. Those APIs are aligned with tidyverse packages in R as much as possible.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -U datar\n\n# install with a backend\npip install -U datar[pandas]\n\n# More backends support coming soon\n</code></pre>"},{"location":"#backends","title":"Backends","text":"Repo Badges datar-numpy datar-pandas datar-arrow"},{"location":"#example-usage","title":"Example usage","text":"<pre><code># with pandas backend\nfrom datar import f\nfrom datar.dplyr import mutate, filter_, if_else\nfrom datar.tibble import tibble\n# or\n# from datar.all import f, mutate, filter_, if_else, tibble\n\ndf = tibble(\n    x=range(4),  # or c[:4]  (from datar.base import c)\n    y=['zero', 'one', 'two', 'three']\n)\ndf &gt;&gt; mutate(z=f.x)\n\"\"\"# output\n        x        y       z\n  &lt;int64&gt; &lt;object&gt; &lt;int64&gt;\n0       0     zero       0\n1       1      one       1\n2       2      two       2\n3       3    three       3\n\"\"\"\n\ndf &gt;&gt; mutate(z=if_else(f.x&gt;1, 1, 0))\n\"\"\"# output:\n        x        y       z\n  &lt;int64&gt; &lt;object&gt; &lt;int64&gt;\n0       0     zero       0\n1       1      one       0\n2       2      two       1\n3       3    three       1\n\"\"\"\n\ndf &gt;&gt; filter_(f.x&gt;1)\n\"\"\"# output:\n        x        y\n  &lt;int64&gt; &lt;object&gt;\n0       2      two\n1       3    three\n\"\"\"\n\ndf &gt;&gt; mutate(z=if_else(f.x&gt;1, 1, 0)) &gt;&gt; filter_(f.z==1)\n\"\"\"# output:\n        x        y       z\n  &lt;int64&gt; &lt;object&gt; &lt;int64&gt;\n0       2      two       1\n1       3    three       1\n\"\"\"\n</code></pre> <pre><code># works with plotnine\n# example grabbed from https://github.com/has2k1/plydata\nimport numpy\nfrom datar import f\nfrom datar.base import sin, pi\nfrom datar.tibble import tibble\nfrom datar.dplyr import mutate, if_else\nfrom plotnine import ggplot, aes, geom_line, theme_classic\n\ndf = tibble(x=numpy.linspace(0, 2 * pi, 500))\n(\n    df\n    &gt;&gt; mutate(y=sin(f.x), sign=if_else(f.y &gt;= 0, \"positive\", \"negative\"))\n    &gt;&gt; ggplot(aes(x=\"x\", y=\"y\"))\n    + theme_classic()\n    + geom_line(aes(color=\"sign\"), size=1.2)\n)\n</code></pre> <pre><code># very easy to integrate with other libraries\n# for example: klib\nimport klib\nfrom pipda import register_verb\nfrom datar import f\nfrom datar.data import iris\nfrom datar.dplyr import pull\n\ndist_plot = register_verb(func=klib.dist_plot)\niris &gt;&gt; pull(f.Sepal_Length) &gt;&gt; dist_plot()\n</code></pre>"},{"location":"#testimonials","title":"Testimonials","text":"<p>@coforfe:</p> <p>Thanks for your excellent package to port R (<code>dplyr</code>) flow of processing to Python. I have been using other alternatives, and yours is the one that offers the most extensive and equivalent to what is possible now with <code>dplyr</code>.</p>"},{"location":"CHANGELOG/","title":"Change Log","text":""},{"location":"CHANGELOG/#change-log","title":"Change Log","text":""},{"location":"CHANGELOG/#0157","title":"0.15.7","text":"<ul> <li>chore(deps): drop support for python3.8</li> <li>ci: update Python version matrix to drop 3.8 and add 3.11, 3.12</li> <li>chore(docs): add mkdocs and related dependencies for documentation generation</li> </ul>"},{"location":"CHANGELOG/#0156","title":"0.15.6","text":"<ul> <li>deps: bump simplug to 0.4, datar-numpy to 0.3.4 and datar-pandas to 0.5.5</li> <li>tests: adopt pytest v8</li> <li>ci: use latest actions</li> </ul>"},{"location":"CHANGELOG/#0155","title":"0.15.5","text":"<ul> <li>deps: bump datar-numpy to 0.3.3</li> </ul>"},{"location":"CHANGELOG/#0154","title":"0.15.4","text":"<ul> <li>docs: fix typo in README.md (#197)</li> <li>docs: change <code>filter</code> to <code>filter_</code> in README.md</li> <li>docs: fix typo in data.md</li> <li>deps: bump datar-pandas to 0.5.4 (support pandas 2.2+)</li> </ul>"},{"location":"CHANGELOG/#0153","title":"0.15.3","text":"<ul> <li>\u2b06\ufe0f Bump pipda to 0.13.1</li> </ul>"},{"location":"CHANGELOG/#0152","title":"0.15.2","text":"<ul> <li>\u2b06\ufe0f Bump datar-pandas to 0.5.2 to fix <code>pip install datar[pandas]</code> not having numpy backend installed.</li> </ul>"},{"location":"CHANGELOG/#0151","title":"0.15.1","text":"<ul> <li>\u2b06\ufe0f Bump datar-pandas to 0.5.1<ul> <li>Dismiss ast warning for if_else.</li> <li>Make scipy and wcwidth optional deps</li> <li>Set seed in tests</li> <li>Dismiss warnings of fillna with method for pandas2.1</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#0150","title":"0.15.0","text":"<ul> <li>\u2728 Add data who2, household, cms_patient_experience, and cms_patient_care</li> <li>\u2b06\ufe0f Bump datar-pandas to 0.5 to support pandas2 (#186)</li> </ul>"},{"location":"CHANGELOG/#0140","title":"0.14.0","text":"<ul> <li>\u2b06\ufe0f Bump pipda to 0.13</li> <li>\ud83c\udf71 Support dplyr up to 1.1.3</li> <li>\ud83d\udc7d\ufe0f Align <code>rows_*()</code> verbs to align with dplyr 1.1.3 (#188)</li> <li>\ud83d\udd27 Update pyproject.toml to generate setup.py for poetry</li> </ul>"},{"location":"CHANGELOG/#0131","title":"0.13.1","text":"<ul> <li>\ud83c\udfa8 Allow <code>datar.all.filter</code> regardless of <code>allow_conflict_names</code> (#184)</li> </ul>"},{"location":"CHANGELOG/#0130","title":"0.13.0","text":"<ul> <li>\ud83d\udc77 Add scripts for codesandbox</li> <li> <p>\ud83d\udca5 Change the option for conflict names (#184)</p> <p>There is no more warning for conflict names (python reserved names). By default, those names are suffixed with <code>_</code> (ie <code>filter_</code> instead of <code>filter</code>). You can still use the original names by setting <code>allow_conflict_names</code> to <code>True</code> in <code>datar.options()</code>.</p> <pre><code>from datar import options\noptions(allow_conflict_names=True)\nfrom datar.all import *\nfilter  # &lt;function datar.dplyr.filter_ at 0x7f62303c8940&gt;\n</code></pre> </li> </ul>"},{"location":"CHANGELOG/#0122","title":"0.12.2","text":"<ul> <li>\u2795 Add pyarrow backend</li> <li>\ud83d\udc1b Exclude coverage for multiline version in <code>get_versions()</code></li> <li>\u2b06\ufe0f Bump up <code>python-simpleconf</code> to 0.6 so datar can be installed in Windows (#180)</li> </ul>"},{"location":"CHANGELOG/#0121","title":"0.12.1","text":"<ul> <li>\u2b06\ufe0f Bump datar-numpy to ^0.2</li> </ul>"},{"location":"CHANGELOG/#0120","title":"0.12.0","text":"<ul> <li>\ud83d\udcdd Added import f to plotnine on README.md (#177)</li> <li>\u2b06\ufe0f Drop support for python3.7</li> <li>\u2b06\ufe0f Bump pipda to 0.12</li> <li>\ud83c\udf71 Update storms data to 2020 (tidyverse/dplyr#5899)</li> </ul>"},{"location":"CHANGELOG/#0112","title":"0.11.2","text":"<ul> <li>\ud83d\udcdd Add pypi downloads badge to README</li> <li>\ud83d\udcdd Fix github workflow badges for README</li> <li>\ud83d\udc1b Add return type annotation to fix #173</li> <li>\u2b06\ufe0f Bump python-slugify to v8</li> </ul>"},{"location":"CHANGELOG/#0111","title":"0.11.1","text":"<ul> <li>\ud83d\udc1b Fix <code>get_versions()</code> not showing plugin versions</li> <li>\ud83d\udc1b Fix plugins not loaded when loading datasets</li> <li>\ud83d\udeb8 Add github issue templates</li> </ul>"},{"location":"CHANGELOG/#0110","title":"0.11.0","text":"<ul> <li>\ud83d\udcdd Add testimonials and backend badges in README.md</li> <li>\ud83d\udc1b Load entrypoint plugins only when APIs are called (#162)</li> <li>\ud83d\udca5 Rename <code>other</code> module to <code>misc</code></li> </ul>"},{"location":"CHANGELOG/#0103","title":"0.10.3","text":"<ul> <li>\u2b06\ufe0f Bump simplug to 0.2.2</li> <li>\u2728 Add <code>apis.other.array_ufunc</code> to support numpy ufuncs</li> <li>\ud83d\udca5 Change hook <code>data_api</code> to <code>load_dataset</code></li> <li>\u2728 Allow backend for <code>c[]</code></li> <li>\u2728 Add <code>DatarOperator.with_backend()</code> to select backend for operators</li> <li>\u2705 Add tests</li> <li>\ud83d\udcdd Update docs for backend supports</li> </ul>"},{"location":"CHANGELOG/#0102","title":"0.10.2","text":"<ul> <li>\ud83d\ude91 Fix false warning when importing from all</li> </ul>"},{"location":"CHANGELOG/#0101","title":"0.10.1","text":"<ul> <li>Pump simplug to 0.2</li> </ul>"},{"location":"CHANGELOG/#0100","title":"0.10.0","text":"<ul> <li>Detach backend support, so that more backends can be supported easier in the future</li> <li>numpy backend: https://github.com/pwwang/datar-numpy</li> <li>pandas backend: https://github.com/pwwang/datar-pandas</li> <li>Adopt pipda 0.10 so that functions can be pipeable (#148)</li> <li>Support pandas 1.5+ (#148), but v1.5.0 excluded (see pandas-dev/pandas#48645)</li> </ul>"},{"location":"CHANGELOG/#091","title":"0.9.1","text":"<ul> <li>Pump pipda to 0.8.0 (fixes #149)</li> </ul>"},{"location":"CHANGELOG/#090","title":"0.9.0","text":""},{"location":"CHANGELOG/#fixes","title":"Fixes","text":"<ul> <li>Fix <code>weighted_mean</code> not handling group variables with NaN values (#137)</li> <li>Fix <code>weighted_mean</code> on <code>NA</code> raising error instead of returning <code>NA</code> (#139)</li> <li>Fix pandas <code>.groupby()</code> used internally not inheriting <code>sort</code>, <code>dropna</code> and <code>observed</code> (#138, #142)</li> <li>Fix <code>mutate/summarise</code> not counting references inside function as used for <code>_keep</code> <code>\"used\"/\"unused\"</code></li> <li>Fix metadata <code>_datar</code> of nested <code>TibbleGrouped</code> not frozen</li> </ul>"},{"location":"CHANGELOG/#breaking-changes","title":"Breaking changes","text":"<ul> <li>Refactor <code>core.factory.func_factory()</code> (#140)</li> <li>Use <code>base.c[...]</code> for range short cut, instead of <code>f[...]</code></li> <li>Use <code>tibble.fibble()</code> when constructing <code>Tibble</code> inside a verb, instead of <code>tibble.tibble()</code></li> <li>Make <code>n</code> a keyword-only argument for <code>base.ntile</code></li> </ul>"},{"location":"CHANGELOG/#deprecation","title":"Deprecation","text":"<ul> <li>Deprecate <code>verb_factory</code>, use <code>register_verb</code> from <code>pipda</code> instead</li> <li>Deprecate <code>base.data_context</code></li> </ul>"},{"location":"CHANGELOG/#dependences","title":"Dependences","text":"<ul> <li>Adopt <code>pipda</code> <code>v0.7.1</code></li> <li>Remove <code>varname</code> dependency</li> <li>Install <code>pdtypes</code> by default</li> </ul>"},{"location":"CHANGELOG/#086","title":"0.8.6","text":"<ul> <li>\ud83d\udc1b Fix weighted_mean not working for grouped data (#133)</li> <li>\u2705 Add tests for weighted_mean on grouped data</li> <li>\u26a1\ufe0f Optimize distinct on existing columns (#128)</li> </ul>"},{"location":"CHANGELOG/#085","title":"0.8.5","text":"<ul> <li>\ud83d\udc1b Fix columns missing after Join by same columns using mapping (#122)</li> </ul>"},{"location":"CHANGELOG/#084","title":"0.8.4","text":"<ul> <li>\u2796 Add optional deps to extras so they aren't installed by default</li> <li>\ud83c\udfa8 Giva better message when optional packages not installed</li> </ul>"},{"location":"CHANGELOG/#083","title":"0.8.3","text":"<ul> <li>\u2b06\ufe0f Upgrade pipda to v0.6</li> <li>\u2b06\ufe0f\ufe0f Upgrade thon-simpleconf to 5.5</li> </ul>"},{"location":"CHANGELOG/#082","title":"0.8.2","text":"<ul> <li>\u267b\ufe0f Move <code>glimpse</code> to <code>dplyr</code> (as <code>glimpse</code> is a <code>tidyverse-dplyr</code> API)</li> <li>\ud83d\udc1b Fix <code>glimpse()</code> output not rendering in qtconsole (#117)</li> <li>\ud83d\udc1b Fix <code>base.match()</code> for pandas 1.3.0</li> <li>\ud83d\udc1b Allow <code>base.match()</code> to work with grouping data (#115)</li> <li>\ud83d\udccc Use <code>rtoml</code> (<code>python-simpleconf</code>) instead of <code>toml</code> (See https://github.com/pwwang/toml-bench)</li> <li>\ud83d\udccc Update dependencies</li> </ul>"},{"location":"CHANGELOG/#081","title":"0.8.1","text":"<ul> <li>\ud83d\udc1b Fix <code>month_abb</code> and <code>month_name</code> being truncated (#112)</li> <li>\ud83d\udc1b Fix <code>unite()</code> not keeping other columns (#111)</li> </ul>"},{"location":"CHANGELOG/#080","title":"0.8.0","text":"<ul> <li>\u2728 Support <code>base.glimpse()</code> (#107, machow/siuba#409)</li> <li>\ud83d\udc1b Register <code>base.factor()</code> and accept grouped data (#108)</li> <li>\u2728 Allow configuration file to save default options</li> <li>\ud83d\udca5 Replace option <code>warn_builtin_names</code> with <code>imiport_names_conflict</code> (#73)</li> <li>\ud83e\ude79 Attach original <code>__module__</code> to <code>func_factory</code> registed functions</li> <li>\u2b06\ufe0f Bump <code>pipda</code> to <code>0.5.9</code></li> </ul>"},{"location":"CHANGELOG/#072","title":"0.7.2","text":"<ul> <li>\u2728 Allow tidyr.unite() to unite multiple columns into a list, instead of join them (#105)</li> <li>\ud83e\ude79 Typos in argument names of tidyr.pivot_longer() (#104)</li> <li>\ud83d\udc1b Fix base.sprintf() not working with Series (#102)</li> </ul>"},{"location":"CHANGELOG/#071","title":"0.7.1","text":"<ul> <li>\ud83d\udc1b Fix settingwithcopywarning in tidyr.pivot_wider()</li> <li>\ud83d\udccc Pin deps for docs</li> <li>\ud83d\udc9a Don't upload coverage in PR</li> <li>\ud83d\udcdd Fix typos in docs (#99, #100) (Thanks to @pdwaggoner)</li> </ul>"},{"location":"CHANGELOG/#070","title":"0.7.0","text":"<ul> <li>\u2728 Support <code>modin</code> as backend</li> <li>\u2728 Add <code>_return</code> argument for <code>datar.options()</code></li> <li>\ud83d\udc1b Fix <code>tidyr.expand()</code> when <code>nesting(f.name)</code> as argument</li> </ul>"},{"location":"CHANGELOG/#064","title":"0.6.4","text":""},{"location":"CHANGELOG/#breaking-changes_1","title":"Breaking changes","text":"<ul> <li>\ud83e\ude79 Make <code>base.ntile()</code> labels 1-based (#92)</li> </ul>"},{"location":"CHANGELOG/#fixes_1","title":"Fixes","text":"<ul> <li>\ud83d\udc1b Fix <code>order_by</code> argument for <code>dplyr.lead-lag</code></li> </ul>"},{"location":"CHANGELOG/#enhancements","title":"Enhancements","text":"<ul> <li>\ud83d\ude91 Allow <code>base.paste/paste0()</code> to work with grouped data</li> <li>\ud83e\ude79 Change dtypes of <code>base.letters/LETTERS/month_abb/month_name</code></li> </ul>"},{"location":"CHANGELOG/#housekeeping","title":"Housekeeping","text":"<ul> <li>\ud83d\udcdd Update and fix reference maps</li> <li>\ud83d\udcdd Add <code>environment.yml</code> for binder to work</li> <li>\ud83d\udcdd Update styles for docs</li> <li>\ud83d\udcdd Update styles for API doc in notebooks</li> <li>\ud83d\udcdd Update README for new description about the project and add examples from StackOverflow</li> </ul>"},{"location":"CHANGELOG/#063","title":"0.6.3","text":"<ul> <li>\u2728 Allow <code>base.c()</code> to handle groupby data</li> <li>\ud83d\ude91 Allow <code>base.diff()</code> to work with groupby data</li> <li>\u2728 Allow <code>forcats.fct_inorder()</code> to work with groupby data</li> <li>\u2728 Allow <code>base.rep()</code>'s arguments <code>length</code> and <code>each</code> to work with grouped data</li> <li>\u2728 Allow <code>base.c()</code> to work with grouped data</li> <li>\u2728 Allow <code>base.paste()</code>/<code>base.paste0()</code> to work with grouped data</li> <li>\ud83d\udc1b Force <code>&amp;/|</code> operators to return boolean data</li> <li>\ud83d\ude91 Fix <code>base.diff()</code> not keep empty groups</li> <li>\ud83d\udc1b Fix recycling non-ordered grouped data</li> <li>\ud83e\ude79 Fix <code>dplyr.count()/tally()</code>'s warning about the new name</li> <li>\ud83d\ude91 Make <code>dplyr.n()</code> return groupoed data</li> <li>\ud83d\udc1b Make <code>dplyr.slice()</code> work better with rows/indices from grouped data</li> <li>\ud83e\ude79 Make <code>dplyr.ntile()</code> labels 1-based</li> <li>\u2728 Add <code>datar.attrgetter()</code>, <code>datar.pd_str()</code>, <code>datar.pd_cat()</code> and <code>datar.pd_dt()</code></li> </ul>"},{"location":"CHANGELOG/#062","title":"0.6.2","text":"<ul> <li>\ud83d\ude91 Fix #87 boolean operator losing index</li> <li>\ud83d\ude91 Fix false alarm from <code>rename()</code>/<code>relocate()</code> for missing grouping variables (#89)</li> <li>\u2728 Add <code>base.diff()</code></li> <li>\ud83d\udcdd [doc] Update/Fix doc for case_when (#87)</li> <li>\ud83d\udcdd [doc] Fix links in reference map</li> <li>\ud83d\udcdd [doc] Update docs for <code>dplyr.base</code></li> </ul>"},{"location":"CHANGELOG/#061","title":"0.6.1","text":"<ul> <li>\ud83d\udc1b Fix <code>rep(df, n)</code> producing a nested df</li> <li>\ud83d\udc1b Fix <code>TibbleGrouped.__getitem__()</code> not keeping grouping structures</li> </ul>"},{"location":"CHANGELOG/#060","title":"0.6.0","text":""},{"location":"CHANGELOG/#general","title":"General","text":"<ul> <li>Adopt <code>pipda</code> 0.5.7</li> <li>Reimplement the split-apply-combine rule to solve all performance issues</li> <li>Drop support for pandas v1.2, require pandas v1.3+</li> <li>Remove all <code>base0_</code> options and all indices are now 0-based, except <code>base.seq()</code>, ranks and their variants</li> <li>Remove messy type annotations for now, will add them back in the future</li> <li>Move implementation of data type display for frames in terminal and notebook to <code>pdtypes</code> package</li> <li>Change all arguments end with \"_\" to arguments start with it to avoid confusion</li> <li>Move module <code>datar.stats</code> to <code>datar.base.stats</code></li> <li>Default all <code>na_rm</code> arguments to <code>True</code></li> <li>Rename all <code>ptype</code> arguments for <code>tidyr</code> verbs into <code>dtypes</code></li> </ul>"},{"location":"CHANGELOG/#details","title":"Details","text":"<ul> <li>Introduct new API to register function <code>datar.core.factory.func_factory()</code></li> <li>Aliase <code>register_verb</code> and <code>register_func</code> as <code>verb_factory</code> and <code>context_func_factory</code> in <code>datar.core.factory</code></li> <li>Expose <code>options</code>, <code>options_context</code>, <code>add_option</code> and <code>get_option</code> in <code>datar/__init__.py</code> and remove them from <code>datar.base</code></li> <li>Attach <code>pipda.options</code> to <code>datar.options</code></li> <li>Move <code>head</code> and <code>tail</code> from <code>datar.utils</code> to <code>datar.base</code></li> <li>Remove redundant <code>unique</code> implentation from <code>datar.base.seq</code></li> <li>Add <code>datar.core.factory.func_factory()</code> for developers to register function that works with different types of data (<code>NDFrame</code>, <code>GropuBy</code>, etc)</li> <li>Not ensure NAs after NA for <code>base.cumxxx()</code> families any more</li> <li>Remove <code>set_names</code> from <code>datar.stats</code>, use <code>names(df, &lt;new names&gt;)</code> from <code>datar.base</code> instead</li> <li>Optimize <code>intersect</code>, <code>union</code>, <code>setdiff</code>, <code>append</code> from <code>datar.base</code></li> <li>Keep grouping variables for <code>intersect</code>, <code>union</code>, <code>setdiff</code> and <code>union_all</code> when <code>y</code> is a grouped df, even when <code>x</code> is not</li> <li>Remove <code>drop_index</code> from <code>datar.datar</code>, use <code>datar.tibble.remove_rownames/remove_index/drop_index</code> instead</li> <li>Add <code>assert_tibble_equal()</code> in <code>datar.testing</code> to test whether 2 tibbles are equal</li> <li><code>rep()</code> now works with frames</li> <li><code>c_across()</code> now returns a rowwise df to work with functions that apply to df on <code>axis=1</code></li> <li><code>datar.dplyr.order_by()</code> now only works like it does in <code>r-dplyr</code> and only in side a verb</li> <li><code>datar.dplyr.group_by()</code> detauls <code>_sort</code> to <code>False</code> for speed</li> <li>Only raise error for duplicated column names when selected by column name instead of index</li> <li><code>base.scale()</code> returns a series rather than a frame when works with a series</li> <li>Other fixes and optimizations</li> </ul>"},{"location":"CHANGELOG/#056","title":"0.5.6","text":"<ul> <li>\ud83d\udc1b Hotfix for types registered for base.proportions (#77)</li> <li>\ud83d\udc7d\ufe0f Fix for pandas 1.4</li> </ul>"},{"location":"CHANGELOG/#055","title":"0.5.5","text":"<ul> <li>Fix #71: semi_join returns duplicated rows</li> </ul>"},{"location":"CHANGELOG/#054","title":"0.5.4","text":"<ul> <li>Fix <code>filter()</code> restructures group_data incorrectly (#69)</li> </ul>"},{"location":"CHANGELOG/#053","title":"0.5.3","text":"<ul> <li>\u26a1\ufe0f Optimize dplyr.arrange when data are series from the df itself</li> <li>\ud83d\udc1b Fix sub-df order of apply for grouped df (#63)</li> <li>\ud83d\udcdd Update doc for argument by for join functions (#62)</li> <li>\ud83d\udc1b Fix mean() with option na_rm=False does not work (#65)</li> </ul>"},{"location":"CHANGELOG/#052","title":"0.5.2","text":"<p>More of a maintenance release.</p> <ul> <li>\ud83d\udd27 Add metadata for datasets</li> <li>\ud83d\udd0a Send logs to stderr, instead of stdout</li> <li>\ud83d\udcccPin dependency versions</li> <li>\ud83d\udea8 Switch linter to flake8</li> <li>\ud83d\udcdd Update some docs to fit <code>datar-cli</code></li> </ul>"},{"location":"CHANGELOG/#051","title":"0.5.1","text":"<ul> <li>Add documentation about \"blind\" environment (#45, #54, #55)</li> <li>Change <code>base.as_date()</code> to return pandas datetime types instead python datetime types (#56)</li> <li>Add <code>base.as_pd_date()</code> to be an alias of <code>pandas.to_datetime()</code> (#56)</li> <li>Expose <code>trimws</code> to <code>datar.all</code> (#58)</li> </ul>"},{"location":"CHANGELOG/#050","title":"0.5.0","text":"<p>Added:</p> <ul> <li>Added <code>forcats</code> (#51 )</li> <li>Added <code>base.is_ordered()</code>, <code>base.nlevels()</code>, <code>base.ordered()</code>, <code>base.rank()</code>, <code>base.order()</code>, <code>base.sort()</code>, <code>base.tabulate()</code>, <code>base.append()</code>, <code>base.prop_table()</code> and <code>base.proportions()</code></li> <li>Added <code>gss_cat</code> dataset</li> </ul> <p>Fixed:</p> <ul> <li>Fixed an issue when <code>Collection</code> dealing with <code>numpy.int_</code></li> </ul> <p>Enhanced:</p> <ul> <li>Added <code>base0_</code> argument for <code>datar.get()</code></li> <li>Passed <code>__calling_env</code> to registered functions/verbs when used internally (this makes sure the library to be robust in different environments)</li> </ul>"},{"location":"CHANGELOG/#044","title":"0.4.4","text":"<ul> <li>Adopt <code>varname</code> <code>v0.8.0</code></li> <li>Add <code>base.make_names()</code> and <code>base.make_unique()</code></li> </ul>"},{"location":"CHANGELOG/#043","title":"0.4.3","text":"<ul> <li>Adopt <code>pipda</code> <code>0.4.5</code></li> <li>Make dataset names case-insensitive;</li> <li>Add datasets: <code>ToothGrowth</code>, <code>economics</code>, <code>economics_long</code>, <code>faithful</code>, <code>faithfuld</code>, <code>luv_colours</code>, <code>midwest</code>, <code>mpg</code>, <code>msleep</code>, <code>presidential</code>, <code>seals</code>, and <code>txhousing</code></li> <li>Add <code>base.complete_cases()</code></li> <li>Change <code>datasets.all_datasets()</code> to <code>datasets.list_datasets()</code></li> <li>Make sure <code>assume_all_piping</code> mode works internally: #45</li> </ul>"},{"location":"CHANGELOG/#042","title":"0.4.2","text":"<ul> <li>Adopt <code>pipda</code> 0.4.4</li> <li>Add <code>varname</code> to dependency to close #30</li> <li>Rename <code>datar.datar_versions</code> to <code>datar.get_versions</code></li> <li>Port a set of functions from r-base, incluing:<ul> <li><code>prod</code>, <code>sign</code>, <code>signif</code>, <code>trunc</code>, <code>exp</code>, <code>log</code>, <code>log2</code>, <code>log10</code>, <code>log1p</code>,</li> <li><code>is_finite</code>, <code>is_infinite</code>, <code>is_nan</code>,</li> <li><code>match</code>,</li> <li><code>startswith</code>, <code>endswith</code>, <code>strtoi</code>, <code>chartr</code>, <code>tolower</code>, <code>toupper</code>,</li> <li><code>max_col</code></li> </ul> </li> </ul>"},{"location":"CHANGELOG/#041","title":"0.4.1","text":"<ul> <li>Don't use piping syntax internally (<code>&gt;&gt;=</code>)</li> <li>Add <code>python</code>, <code>numpy</code> and <code>datar</code> version to <code>datar.datar_versions()</code></li> <li>Fix #40: anti_join/semi_join not working when by is column mapping</li> </ul>"},{"location":"CHANGELOG/#040","title":"0.4.0","text":"<ul> <li>Adopt <code>pipda</code> v0.4.2</li> </ul> <p>Performance improved: - Refactor core.grouped to adopt pandas's groupby - Try to use <code>DataFrame.agg()</code>/<code>DataFrameGroupBy.agg()</code> when function applied on a single columns (Related issues: #27, #33, #37)</p> <p>Fixed: - Fix when <code>data</code> or <code>context</code> as new column name for <code>mutate()</code> - Fix SettingwithCopyWarning in pivot_longer - Use regular calling internally to make sure it works in some cases that node cannot be detected (ie <code>Gooey</code>/<code>%%timeit</code> in jupyter)</p> <p>Added: - <code>datar.datar_versions()</code> to show versions of related packages for bug reporting.</p>"},{"location":"CHANGELOG/#032","title":"0.3.2","text":"<ul> <li>Adopt <code>pipda</code> v0.4.1 to fix <code>getattr()</code> failure for operater-connected expressions (#38)</li> <li>Add <code>str_dtype</code> argument to <code>as_character()</code> to partially fix #36</li> <li>Update license in <code>core._frame_format_patch</code> (#28)</li> </ul>"},{"location":"CHANGELOG/#031","title":"0.3.1","text":"<ul> <li>Adopt <code>pipda</code> v0.4.0</li> <li>Change argument <code>_dtypes</code> to <code>dtypes_</code> for tibble-families</li> </ul>"},{"location":"CHANGELOG/#030","title":"0.3.0","text":"<ul> <li>Adopt <code>pipda</code> v0.3.0</li> </ul> <p>Breaking changes:</p> <ul> <li>Rename argument <code>dtypes</code> of <code>unchop</code> and <code>unnest</code> back to <code>ptype</code></li> <li>Change all <code>_base0</code> to <code>base0_</code></li> <li>Change argument <code>how</code> of <code>tidyr.drop_na</code> to <code>how_</code></li> </ul>"},{"location":"CHANGELOG/#023","title":"0.2.3","text":"<ul> <li>Fix compatibility with <code>pandas</code> <code>v1.2.0~4</code> (#20, thanks to @antonio-yu)</li> <li>Fix base.table when inputs are factors and exclude is NA;</li> <li>Add base.scale/col_sums/row_sums/col_means/row_means/col_sds/row_sds/col_medians/row_medians</li> </ul>"},{"location":"CHANGELOG/#022","title":"0.2.2","text":"<ul> <li>Use a better strategy warning for builtin name overriding.</li> <li>Fix index of subdf not dropped for mutate on grouped data</li> <li>Fix <code>names_glue</code> not working with single <code>values_from</code> for <code>tidyr.pivot_wider</code></li> <li>Fix <code>base.paste</code> not registered</li> <li>Fix <code>base.grep</code>/<code>grepl</code> on NA values</li> <li>Make <code>base.sub</code>/<code>gsub</code> return scalar when inputs are scalar strings</li> </ul>"},{"location":"CHANGELOG/#021","title":"0.2.1","text":"<ul> <li>Use observed values for non-observsed value match for group_data instead of NAs, which might change the dtype.</li> <li>Fix tibble recycling values too early</li> </ul>"},{"location":"CHANGELOG/#020","title":"0.2.0","text":"<p>Added: - Add <code>base.which</code>, <code>base.bessel</code>, <code>base.special</code>, <code>base.trig_hb</code> and <code>base.string</code> modules - Add Support for duplicated keyword arguments for dplyr.mutate/summarise by using <code>_</code> as suffix - Warn when import python builtin names directly; ; Remove modkit dependency</p> <p>Fixed: - Fixed errors when use<code>a_1</code> as names for <code>\"check_unique\"</code> name repairs - Fixed #14: <code>f.a.mean()</code> not applied to grouped data</p> <p>Changed: - Don't allow <code>from datar.datasets import *</code> - Remove <code>modkit</code> dependency - Reset <code>NaN</code> to <code>NA</code> - Rename <code>base.getOption</code> to <code>base.get_option</code> - Rename <code>stats.setNames</code> to <code>stats.set_names</code></p>"},{"location":"CHANGELOG/#011","title":"0.1.1","text":"<ul> <li>Adopt <code>pipda</code> 0.2.8</li> <li>Allow <code>f.col1[f.col2==max(f.col2)]</code> like expression</li> <li>Add <code>base.which/cov/var</code></li> <li>Fix <code>base.max</code></li> <li>Add <code>datasets.ChickWeight</code></li> <li>Allow <code>dplyr.across</code> to have plain functions passed with default <code>EVAL</code> context.</li> </ul>"},{"location":"CHANGELOG/#010","title":"0.1.0","text":"<p>Added: - <code>pandas.NA</code> as <code>NaN</code> - Dtypes display when printing a dataframe (string, html, notebook) - <code>zibble</code> to construct dataframes with names specified together, and values together.</p> <p>Fixed: - <code>base.diag()</code> on dataframes - Data recycling when length is different from original data - <code>datar.itemgetter()</code> not public</p> <p>Changed: - Behavior of <code>group_by()</code> with <code>_drop=False</code>. Invisible values will not mix with visible values of other columns</p>"},{"location":"CHANGELOG/#007","title":"0.0.7","text":"<ul> <li>Add dplyr rows verbs</li> <li>Allow mixed numbering (with <code>c()</code> and <code>f[...]</code>) for tibble construction</li> <li>Allow slice (<code>f[a:b]</code>) to be expanded into sequence for <code>EVAL</code> context</li> <li>Finish tidyr porting.</li> </ul>"},{"location":"CHANGELOG/#006","title":"0.0.6","text":"<ul> <li>Add <code>options</code>, <code>get_option</code> and <code>options_context</code> to <code>datar.base</code> to allow set/get global options</li> <li>Add options: <code>dplyr.summarise.inform</code></li> <li>Add <code>base0_</code> argument to all related APIs</li> <li>Add <code>nycflights13</code> datasets</li> <li>Support slice_head/slice_tail for grouped data</li> </ul>"},{"location":"CHANGELOG/#005","title":"0.0.5","text":"<ul> <li>Add option index.base.0;</li> <li>Refactor Collection families</li> </ul>"},{"location":"CHANGELOG/#004","title":"0.0.4","text":"<ul> <li>Finish port of tibble.</li> </ul>"},{"location":"CHANGELOG/#003","title":"0.0.3","text":"<ul> <li>Add stats.weighted_mean</li> <li>Allow function to prefer recycling input or output for summarise</li> </ul>"},{"location":"CHANGELOG/#002","title":"0.0.2","text":"<ul> <li>Port verbs and functions from tidyverse/dplyr and test them with original cases</li> </ul>"},{"location":"backends/","title":"Backends","text":""},{"location":"backends/#backends","title":"Backends","text":"<p>The <code>datar</code> package is a collection of APIs that are ported from a bunch of R packages. The APIs are implemented in a backend-agnostic way, so that they can be used with different backends. Currently, <code>datar</code> supports the following backends:</p> <ul> <li><code>numpy</code>: Mostly the implementations of functions from <code>datar.base</code>.</li> <li><code>pandas</code>: Implementations using <code>pandas</code> as backend.</li> </ul>"},{"location":"backends/#installation-of-a-backend","title":"Installation of a backend","text":"<pre><code>pip install -U datar[&lt;pandas&gt;]\n</code></pre>"},{"location":"backends/#using-desired-backends","title":"Using desired backends","text":"<p>You can install multiple backends, but can use a subset of them.</p> <pre><code>from datar import options\n\noptions(backends=['pandas'])\n\n# Import the API functions then\n</code></pre>"},{"location":"backends/#writing-a-backend","title":"Writing a backend","text":"<p>A backend is supposed to implement as a <code>Simplug</code> plugin. There are a hooks to be implemented.</p>"},{"location":"backends/#hooks","title":"Hooks","text":"<ul> <li><code>setup()</code>: calleed before any API is imported. You can do some setup here.</li> <li><code>get_versions()</code>: return a dict of versions of the dependencies of the backend. The keys are the names of the packages, and the values are the versions.</li> <li><code>load_dataset(name: str, metadata: Mapping)</code>: load a dataset, which can be loaded using <code>from datar.data import &lt;dataset&gt;</code>.</li> <li><code>base_api()</code>: load the implementation of <code>datar.apis.base</code>.</li> <li><code>dplyr_api()</code>: load the implementation of <code>datar.apis.dplyr</code>.</li> <li><code>tibble_api()</code>: load the implementation of <code>datar.apis.tibble</code>.</li> <li><code>forcats_api()</code>: load the implementation of <code>datar.apis.forcats</code>.</li> <li><code>tidyr_api()</code>: load the implementation of <code>datar.apis.tidyr</code>.</li> <li><code>other_api()</code>: load other backend-specific APIs.</li> <li><code>c_getitem(item)</code>: load the implementation of <code>datar.base.c.__getitem__</code> (<code>c[...]</code>).</li> <li><code>operate(op: str, x: Any, y: Any = None)</code>: load the implementation of the operators.</li> </ul>"},{"location":"backends/#seleting-a-backend-at-runtime","title":"Seleting a backend at runtime","text":"<p>You can use <code>__backend</code> to select a backend at runtime.</p> <pre><code>from datar.tibble import tibble\n\ntibble(..., __backend=\"pandas\")\n</code></pre>"},{"location":"backends/#selecting-a-backend-for-operators","title":"Selecting a backend for operators","text":"<p>If you have multiple backends installed, you can select a backend for operators.</p> <pre><code>from datar.core.operator import DatarOperator\n\nDatarOperator.backend = \"pandas\"\n\n# Or use the context manager\nwith DatarOperator.with_backend(\"pandas\"):\n    data &gt;&gt; mutate(z=f.x + f.y)\n</code></pre>"},{"location":"backends/#selecting-a-backend-for-c","title":"Selecting a backend for <code>c[]</code>","text":"<pre><code>from datar.base import c\n\nc.backend = \"pandas\"\n\n# Or use the context manager\nwith c.with_backend(\"pandas\"):\n    data &gt;&gt; mutate(z=c[1:3])\n</code></pre>"},{"location":"backends/#selecting-a-backend-for-numpy-ufuncs","title":"Selecting a backend for numpy ufuncs","text":"<pre><code>from datar.apis.other import array_ufunc\n\narray_ufunc.backend = \"pandas\"\n\n# Or use the context manager\nwith array_ufunc.with_backend(\"pandas\"):\n    data &gt;&gt; mutate(z=np.sin(f.x))\n</code></pre>"},{"location":"data/","title":"Data","text":"<p>See full reference of datasets at: reference-maps/data</p> <p>Datasets have to be imported individually by:</p> <pre><code>from datar.data import iris\n\n# or\nfrom datar import data\n\niris = data.iris\n</code></pre> <p>To list all available datasets:</p> <pre><code>from datar import data\nprint(datasets.descr_datasets())\n</code></pre> <p><code>file</code> shows the path to the csv file of the dataset, and <code>index</code> shows if it has index (rownames).</p> <p>Note</p> <p>The column names are altered by replace <code>.</code> to <code>_</code>. For example <code>Sepal.Width</code> to <code>Sepal_Width</code>.</p> <p>Note</p> <p>Dataset names are case-insensitive. So you can do:</p> <pre><code>from datar.datasets import ToothGrowth\n# or\nfrom datar.datasets import toothgrowth\n</code></pre> <p>See also Backends for implementations to loaad datasets.</p>"},{"location":"f/","title":"The f-expression","text":""},{"location":"f/#why-f","title":"Why <code>f</code>?","text":"<p>It is just fast for you to type, since usually, it is <code>.</code> right after <code>f</code>. Then you have your left hand and right hand working together sequentially.</p>"},{"location":"f/#the-symbolic-object-f","title":"The <code>Symbolic</code> object <code>f</code>","text":"<p>You can import it by <code>from datar import f</code>, or <code>from datar.all import *</code></p> <p><code>f</code> is a universal <code>Symbolic</code> object, which does the magic to connect the expressions in verb arguments so that they can be delayed to execute.</p> <p>There are different uses for the <code>f</code>.</p> <ul> <li>Use as a proxy to refer to dataframe columns (i.e. <code>f.x</code>, <code>f['x']</code>)</li> <li> <p>Use as the column name marker for <code>tribble</code>:</p> <pre><code>tribble(\n    f.x, f.y\n    1,   2\n    3,   4\n)\n</code></pre> </li> </ul> <p>Note</p> <p>If you want a sequence literal, other than using <code>base.seq()</code>, you can also use <code>base.c[]</code>.</p> <p>For example, <pre><code>from datar.base import c\nfrom datar.tibble import tibble\ndf = tibble(x=c[1:5])  # 1, 2, 3, 4\n</code></pre></p>"},{"location":"f/#if-you-dont-like-f","title":"If you don't like <code>f</code> ...","text":"<p>Sometimes if you have mixed verbs with piping and you want to distinguish to proxies for different verbs:</p> <pre><code># you can just replicate f with a different name\ng = f\n\ndf = tibble(x=1, y=2)\ndf &gt;&gt; left_join(df &gt;&gt; group_by(f.x), by=g.y)\n</code></pre> <p>Or you can instantiate a new <code>Symbolic</code> object: <pre><code>from pipda.symbolic import Symbolic\n\ng = Symbolic()\n# assert f is g\n\n# f and g make no difference in execution technically\n</code></pre></p> <p>You can also alias <code>f</code> by: <pre><code>from datar import f as g\n</code></pre></p>"},{"location":"import/","title":"Import datar","text":""},{"location":"import/#import-submodule-verbs-and-functions-from-datar","title":"Import submodule, verbs and functions from datar","text":"<p>You can import everything (all verbs and functions) from datar by: <pre><code>from datar.all import *\n</code></pre></p> <p>which is not recommended. Instead, you can import individual verbs or functions by: <pre><code>from datar.all import mutate\n</code></pre></p> <p>Attention</p> <p>When you use <code>from datar.all import *</code>, you need to pay attention to the python builtin names that are covered by <code>datar</code> (will warn by default). For example, <code>slice</code> will be <code>datar.dplyr.slice</code> instead of <code>builtins.slice</code>. To refer to the builtin one, you need to: <pre><code>import builtins\n\ns = builtins.slice(None, 3, None) # [:3]\n</code></pre></p> <p>Or if you know the origin of the verb, you can also do: <pre><code>from datar.dplyr import mutate\n</code></pre></p> <p>You can also keep the namespace: <pre><code>from datar import dplyr\n\n# df = tibble(x=1)\n# then use it with the dplyr namespace:\ndf &gt;&gt; dplyr.mutate(y=2)\n</code></pre></p> <p>If you feel those namespaces are annoying, you can always use <code>datar.all</code>: <pre><code>from datar.all import mutate\n</code></pre></p>"},{"location":"import/#import-datasets-from-datar","title":"Import datasets from datar","text":"<p>Note</p> <p>Dataset has to be imported individually. This means  <code>from datar.datasets import *</code> won't work (you don't want all datasets to exhaust your memory).</p> <p>You don't have to worry about other datasets to be imported and take up the memory when you import one. The dataset is only loaded into memory when you explictly import it individually.</p> <p>See also datasets for details about available datasets.</p>"},{"location":"import/#about-python-reserved-names-to-be-masked-by-datar","title":"About python reserved names to be masked by <code>datar</code>","text":"<p>Sometimes it will be confusing especially when python builtin functions are overriden by <code>datar</code>. There are a couple of datar (<code>r-base</code>, <code>dplyr</code>) functions with the same name as python builtin functions. For example: <code>filter</code>, which is a python builtin function, but also a <code>dplyr</code> function. You should use <code>filter_</code> instead. By default, <code>datar</code> will raise an error when you try to import <code>filter</code>. You can set this option to <code>True</code> to allow this behavior.</p>"},{"location":"options/","title":"Options","text":"<p>Options are used to change some behaviors in <code>datar</code>.</p>"},{"location":"options/#available-options","title":"Available options","text":""},{"location":"options/#allow_conflict_names","title":"allow_conflict_names","text":"<p>Whether to allow conflict names that reversed by python. For example, <code>filter</code> is a python builtin function, but also a <code>dplyr</code> function. You should use <code>filter_</code> instead. By default, <code>datar</code> will raise an error when you try to import <code>filter</code>. You can set this option to <code>True</code> to allow this behavior.</p> <pre><code>&gt;&gt;&gt; from datar.all import filter\n&gt;&gt;&gt; # or from datar.dplyr import filter\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nImportError: cannot import name 'filter' from 'datar.all'\n</code></pre> <pre><code>&gt;&gt;&gt; from datar import options\n&gt;&gt;&gt; options(allow_conflict_names=True)\n&gt;&gt;&gt; from datar.all import filter\n&gt;&gt;&gt; filter\n&lt;function filter_ at 0x7f76b34c0940&gt;\n</code></pre> <p>The conflict names under <code>datar.base</code> are:</p> <ul> <li><code>min</code></li> <li><code>max</code></li> <li><code>sum</code></li> <li><code>abs</code></li> <li><code>round</code></li> <li><code>all</code></li> <li><code>any</code></li> <li><code>re</code></li> </ul> <p>The conflict names under <code>datar.dplyr</code> are:</p> <ul> <li><code>filter</code></li> <li><code>slice</code></li> </ul>"},{"location":"options/#backends","title":"backends","text":"<p>If you have multiple backends installed, you can use this option to specify which backends to use.</p>"},{"location":"options/#configuration-files","title":"Configuration files","text":"<p>You can change the default behavior of datar by configuring a <code>.toml.toml</code> file in your home directory. For example, to always use underscore-suffixed names for conflicting names, you can add the following to your <code>~/.datar.toml</code> file:</p> <pre><code>allow_conflict_names = true\n</code></pre> <p>You can also have a project/directory-based configuration file (<code>./.datar.toml</code>) in your current working directory, which has higher priority than the home directory configuration file.</p>"},{"location":"api/datar.all/","title":"datar.all","text":"module &lt;/&gt; <p>Import all constants, verbs and functions</p> Functions <ul> <li><code>__getattr__</code><code>(</code><code>name</code><code>)</code> \u2014 Even when allow_conflict_names is False, datar.base.sum should be fine&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Even when allow_conflict_names is False, datar.base.sum should be fine</p>"},{"location":"api/datar.all/#datarall","title":"datar.all","text":""},{"location":"api/datar.all/#datarallgetattr","title":"<code>datar.all.</code><code>__getattr__</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/datar.apis.base/","title":"datar.apis.base","text":"module &lt;/&gt; <p>APIs ported from r-base</p> Functions <ul> <li><code>abs_</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the absolute value of a vector&lt;/&gt;</li> <li><code>acos</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the inverse cosine&lt;/&gt;</li> <li><code>acosh</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the inverse hyperbolic cosine&lt;/&gt;</li> <li><code>all_</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Are all elements true&lt;/&gt;</li> <li><code>any_</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Is any element true&lt;/&gt;</li> <li><code>any_na</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if anything in <code>x</code> is NA&lt;/&gt;</li> <li><code>append</code><code>(</code><code>x</code>, <code>values</code>, <code>after</code><code>)</code> (Any) \u2014 Append values to the vector&lt;/&gt;</li> <li><code>arg</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Angles of complex numbers&lt;/&gt;</li> <li><code>as_character</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to a character vector&lt;/&gt;</li> <li><code>as_complex</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to a complex vector&lt;/&gt;</li> <li><code>as_date</code><code>(</code><code>x</code>, <code>format</code>, <code>try_formats</code>, <code>optional</code>, <code>tz</code>, <code>origin</code><code>)</code> (Any) \u2014 Convert an object to a datetime.date object&lt;/&gt;</li> <li><code>as_double</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to a double vector&lt;/&gt;</li> <li><code>as_factor</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to a factor vector&lt;/&gt;</li> <li><code>as_integer</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to an integer vector&lt;/&gt;</li> <li><code>as_logical</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to a logical vector&lt;/&gt;</li> <li><code>as_null</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert anything to NULL&lt;/&gt;</li> <li><code>as_numeric</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to a numeric vector&lt;/&gt;</li> <li><code>as_ordered</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to an ordered vector&lt;/&gt;</li> <li><code>asin</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the inverse sine&lt;/&gt;</li> <li><code>asinh</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the inverse hyperbolic sine&lt;/&gt;</li> <li><code>atan</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the inverse tangent&lt;/&gt;</li> <li><code>atan2</code><code>(</code><code>y</code>, <code>x</code><code>)</code> (Any) \u2014 Get the inverse tangent of y/x&lt;/&gt;</li> <li><code>atanh</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the inverse hyperbolic tangent&lt;/&gt;</li> <li><code>bessel_i</code><code>(</code><code>x</code>, <code>nu</code>, <code>expon_scaled</code><code>)</code> (Any) \u2014 Compute the modified Bessel function of the first kind&lt;/&gt;</li> <li><code>bessel_j</code><code>(</code><code>x</code>, <code>nu</code><code>)</code> (Any) \u2014 Compute the Bessel function of the first kind&lt;/&gt;</li> <li><code>bessel_k</code><code>(</code><code>x</code>, <code>nu</code>, <code>expon_scaled</code><code>)</code> (Any) \u2014 Compute the modified Bessel function of the second kind&lt;/&gt;</li> <li><code>bessel_y</code><code>(</code><code>x</code>, <code>nu</code><code>)</code> (Any) \u2014 Compute the Bessel function of the second kind&lt;/&gt;</li> <li><code>beta</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Compute the beta function&lt;/&gt;</li> <li><code>c_</code><code>(</code><code>*args</code><code>)</code> (Any) \u2014 Concatenate vectors&lt;/&gt;</li> <li><code>ceiling</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Round up to the nearest integer&lt;/&gt;</li> <li><code>chartr</code><code>(</code><code>old</code>, <code>new</code>, <code>x</code><code>)</code> (Any) \u2014 Translate characters&lt;/&gt;</li> <li><code>choose</code><code>(</code><code>n</code>, <code>k</code><code>)</code> (Any) \u2014 Compute the binomial coefficient&lt;/&gt;</li> <li><code>col_means</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the column means of a matrix&lt;/&gt;</li> <li><code>col_medians</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the column medians of a matrix&lt;/&gt;</li> <li><code>col_sds</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the column standard deviations of a matrix&lt;/&gt;</li> <li><code>col_sums</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the column sums of a matrix&lt;/&gt;</li> <li><code>colnames</code><code>(</code><code>x</code>, <code>nested</code><code>)</code> (Any) \u2014 Get the column names&lt;/&gt;</li> <li><code>complete_cases</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the complete cases&lt;/&gt;</li> <li><code>conj</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Complex conjugate&lt;/&gt;</li> <li><code>cos</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the cosine&lt;/&gt;</li> <li><code>cosh</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the hyperbolic cosine&lt;/&gt;</li> <li><code>cospi</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the cosine of pi times x&lt;/&gt;</li> <li><code>cov</code><code>(</code><code>x</code>, <code>y</code>, <code>na_rm</code>, <code>ddof</code><code>)</code> (Any) \u2014 Compute pairwise covariance between two variables&lt;/&gt;</li> <li><code>cummax</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Cumulative maxima&lt;/&gt;</li> <li><code>cummin</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Cumulative minima&lt;/&gt;</li> <li><code>cumprod</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Cumulative products&lt;/&gt;</li> <li><code>cumsum</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Cumulative sums&lt;/&gt;</li> <li><code>cut</code><code>(</code><code>x</code>, <code>breaks</code>, <code>labels</code>, <code>include_lowest</code>, <code>right</code>, <code>dig_lab</code>, <code>ordered_result</code><code>)</code> (Any) \u2014 Cut a numeric vector into bins&lt;/&gt;</li> <li><code>diag</code><code>(</code><code>x</code>, <code>nrow</code>, <code>ncol</code><code>)</code> (Any) \u2014 Get the diagonal of a matrix&lt;/&gt;</li> <li><code>diff</code><code>(</code><code>x</code>, <code>lag</code>, <code>differences</code><code>)</code> (An array of `x[lag) \u2014 Difference of a numeric vector&lt;/&gt;</li> <li><code>digamma</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the digamma function&lt;/&gt;</li> <li><code>dim</code><code>(</code><code>x</code>, <code>nested</code><code>)</code> (Any) \u2014 Get the dimensions&lt;/&gt;</li> <li><code>droplevels</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Drop unused levels of a factor&lt;/&gt;</li> <li><code>duplicated</code><code>(</code><code>x</code>, <code>incomparables</code>, <code>from_last</code><code>)</code> (Any) \u2014 Get the duplicated values&lt;/&gt;</li> <li><code>endswith</code><code>(</code><code>x</code>, <code>suffix</code><code>)</code> (Any) \u2014 Does x end with suffix&lt;/&gt;</li> <li><code>exp</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the exponential of a vector&lt;/&gt;</li> <li><code>expand_grid</code><code>(</code><code>x</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Expand a grid&lt;/&gt;</li> <li><code>factor</code><code>(</code><code>x</code>, <code>levels</code>, <code>labels</code>, <code>exclude</code>, <code>ordered</code>, <code>nmax</code><code>)</code> (Any) \u2014 Create a factor vector&lt;/&gt;</li> <li><code>factorial</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the factorial&lt;/&gt;</li> <li><code>floor</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Round down to the nearest integer&lt;/&gt;</li> <li><code>gamma</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the gamma function&lt;/&gt;</li> <li><code>grep</code><code>(</code><code>pattern</code>, <code>x</code>, <code>ignore_case</code>, <code>value</code>, <code>fixed</code>, <code>invert</code><code>)</code> (Any) \u2014 Grep for a pattern&lt;/&gt;</li> <li><code>grepl</code><code>(</code><code>pattern</code>, <code>x</code>, <code>ignore_case</code>, <code>fixed</code><code>)</code> (Any) \u2014 Grep for a pattern&lt;/&gt;</li> <li><code>gsub</code><code>(</code><code>pattern</code>, <code>replacement</code>, <code>x</code>, <code>ignore_case</code>, <code>fixed</code><code>)</code> (Any) \u2014 Substitute a pattern&lt;/&gt;</li> <li><code>head</code><code>(</code><code>x</code>, <code>n</code><code>)</code> (Any) \u2014 Get the first n rows&lt;/&gt;</li> <li><code>identity</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Identity function&lt;/&gt;</li> <li><code>im</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Imaginary part of complex numbers&lt;/&gt;</li> <li><code>intersect</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Get the intersection of two vectors&lt;/&gt;</li> <li><code>is_atomic</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Is the object atomic&lt;/&gt;</li> <li><code>is_character</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Is x a character vector&lt;/&gt;</li> <li><code>is_complex</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if a vector is complex&lt;/&gt;</li> <li><code>is_double</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Is the object a double&lt;/&gt;</li> <li><code>is_element</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Is the object an element of the table&lt;/&gt;</li> <li><code>is_factor</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if a vector is a factor&lt;/&gt;</li> <li><code>is_false</code><code>(</code><code>x</code><code>)</code> (bool) \u2014 Check if anything is false&lt;/&gt;</li> <li><code>is_finite</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if anything is finite&lt;/&gt;</li> <li><code>is_infinite</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if anything is infinite&lt;/&gt;</li> <li><code>is_integer</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Is the object an integer&lt;/&gt;</li> <li><code>is_logical</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if a vector is logical&lt;/&gt;</li> <li><code>is_na</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if anything is NA&lt;/&gt;</li> <li><code>is_null</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if anything is NULL&lt;/&gt;</li> <li><code>is_numeric</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Is the object numeric&lt;/&gt;</li> <li><code>is_ordered</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if a vector is ordered&lt;/&gt;</li> <li><code>is_true</code><code>(</code><code>x</code><code>)</code> (bool) \u2014 Check if anything is true&lt;/&gt;</li> <li><code>lbeta</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Compute the log beta function&lt;/&gt;</li> <li><code>lchoose</code><code>(</code><code>n</code>, <code>k</code><code>)</code> (Any) \u2014 Compute the log binomial coefficient&lt;/&gt;</li> <li><code>length</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the length of a vector&lt;/&gt;</li> <li><code>lengths</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the lengths of a list&lt;/&gt;</li> <li><code>levels</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the levels of a factor&lt;/&gt;</li> <li><code>lfactorial</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the log factorial&lt;/&gt;</li> <li><code>lgamma</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the log gamma function&lt;/&gt;</li> <li><code>log</code><code>(</code><code>x</code>, <code>base</code><code>)</code> (Any) \u2014 Compute the logarithm of a vector&lt;/&gt;</li> <li><code>log10</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the base 10 logarithm of a vector&lt;/&gt;</li> <li><code>log1p</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the logarithm of one plus a vector&lt;/&gt;</li> <li><code>log2</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the base-2 logarithm of a vector&lt;/&gt;</li> <li><code>make_names</code><code>(</code><code>names</code>, <code>unique</code><code>)</code> (Any) \u2014 Make names for a vector&lt;/&gt;</li> <li><code>make_unique</code><code>(</code><code>names</code><code>)</code> (Any) \u2014 Make a vector unique&lt;/&gt;</li> <li><code>match</code><code>(</code><code>x</code>, <code>table</code>, <code>nomatch</code><code>)</code> (Any) \u2014 Match elements of a vector&lt;/&gt;</li> <li><code>max_</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the maximum of a vector&lt;/&gt;</li> <li><code>max_col</code><code>(</code><code>x</code>, <code>ties_method</code>, <code>nested</code><code>)</code> (Any) \u2014 Get the maximum column&lt;/&gt;</li> <li><code>mean</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the mean of a vector&lt;/&gt;</li> <li><code>median</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the median of a vector&lt;/&gt;</li> <li><code>min_</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the minimum of a vector&lt;/&gt;</li> <li><code>mod</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Modulus of complex numbers&lt;/&gt;</li> <li><code>nchar</code><code>(</code><code>x</code>, <code>type_</code>, <code>allow_na</code>, <code>keep_na</code>, <code>_na_len</code><code>)</code> (Any) \u2014 Get the number of characters in a string&lt;/&gt;</li> <li><code>ncol</code><code>(</code><code>x</code>, <code>nested</code><code>)</code> (Any) \u2014 Get the number of columns&lt;/&gt;</li> <li><code>nlevels</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the number of levels of a factor&lt;/&gt;</li> <li><code>nrow</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the number of rows&lt;/&gt;</li> <li><code>nzchar</code><code>(</code><code>x</code>, <code>keep_na</code><code>)</code> (Any) \u2014 Is the string non-zero length&lt;/&gt;</li> <li><code>order</code><code>(</code><code>x</code>, <code>decreasing</code>, <code>na_last</code><code>)</code> (Any) \u2014 Order a vector&lt;/&gt;</li> <li><code>ordered</code><code>(</code><code>x</code>, <code>levels</code>, <code>labels</code>, <code>exclude</code>, <code>nmax</code><code>)</code> (Any) \u2014 Create an ordered factor vector&lt;/&gt;</li> <li><code>outer</code><code>(</code><code>x</code>, <code>y</code>, <code>fun</code><code>)</code> (Any) \u2014 Outer product of two vectors&lt;/&gt;</li> <li><code>paste</code><code>(</code><code>*args</code>, <code>sep</code>, <code>collapse</code><code>)</code> (Any) \u2014 Join a vector into a string&lt;/&gt;</li> <li><code>paste0</code><code>(</code><code>*args</code>, <code>collapse</code><code>)</code> (Any) \u2014 Join a vector into a string&lt;/&gt;</li> <li><code>pmax</code><code>(</code><code>*args</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Returns the (regular or Parallel) maxima and minima of the input values. &lt;/&gt;</li> <li><code>pmin</code><code>(</code><code>*args</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Returns the (regular or Parallel) maxima and minima of the input values. &lt;/&gt;</li> <li><code>prod</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the product of a vector&lt;/&gt;</li> <li><code>proportions</code><code>(</code><code>x</code>, <code>margin</code><code>)</code> (Any) \u2014 Get the proportion table&lt;/&gt;</li> <li><code>psigamma</code><code>(</code><code>x</code>, <code>deriv</code><code>)</code> (Any) \u2014 Compute the psi function&lt;/&gt;</li> <li><code>quantile</code><code>(</code><code>x</code>, <code>probs</code>, <code>na_rm</code>, <code>names</code>, <code>type_</code>, <code>digits</code><code>)</code> (Any) \u2014 Compute the quantiles of a vector&lt;/&gt;</li> <li><code>rank</code><code>(</code><code>x</code>, <code>na_last</code>, <code>ties_method</code><code>)</code> (Any) \u2014 Rank a numeric vector&lt;/&gt;</li> <li><code>rbinom</code><code>(</code><code>n</code>, <code>size</code>, <code>prob</code><code>)</code> (Any) \u2014 Generate random binomial variables&lt;/&gt;</li> <li><code>rcauchy</code><code>(</code><code>n</code>, <code>location</code>, <code>scale</code><code>)</code> (Any) \u2014 Generate random Cauchy variables&lt;/&gt;</li> <li><code>rchisq</code><code>(</code><code>n</code>, <code>df</code><code>)</code> (Any) \u2014 Generate random chi-squared variables&lt;/&gt;</li> <li><code>re_</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Real part of complex numbers&lt;/&gt;</li> <li><code>rep</code><code>(</code><code>x</code>, <code>times</code>, <code>length</code>, <code>each</code><code>)</code> (Any) \u2014 Replicate elements of a vector&lt;/&gt;</li> <li><code>rev</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Reverse a vector&lt;/&gt;</li> <li><code>rexp</code><code>(</code><code>n</code>, <code>rate</code><code>)</code> (Any) \u2014 Generate random exponential variables&lt;/&gt;</li> <li><code>rnorm</code><code>(</code><code>n</code>, <code>mean</code>, <code>sd</code><code>)</code> (Any) \u2014 Generate random normal variables&lt;/&gt;</li> <li><code>round_</code><code>(</code><code>x</code>, <code>digits</code><code>)</code> (Any) \u2014 Round the values of a vector&lt;/&gt;</li> <li><code>row_means</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the row means of a matrix&lt;/&gt;</li> <li><code>row_medians</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the row medians of a matrix&lt;/&gt;</li> <li><code>row_sds</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the row standard deviations of a matrix&lt;/&gt;</li> <li><code>row_sums</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the row sums of a matrix&lt;/&gt;</li> <li><code>rownames</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the row names&lt;/&gt;</li> <li><code>rpois</code><code>(</code><code>n</code>, <code>lambda_</code><code>)</code> (Any) \u2014 Generate random Poisson variables&lt;/&gt;</li> <li><code>runif</code><code>(</code><code>n</code>, <code>min</code>, <code>max</code><code>)</code> (Any) \u2014 Generate random uniform variables&lt;/&gt;</li> <li><code>sample</code><code>(</code><code>x</code>, <code>size</code>, <code>replace</code>, <code>prob</code><code>)</code> (Any) \u2014 Sample a vector&lt;/&gt;</li> <li><code>scale</code><code>(</code><code>x</code>, <code>center</code>, <code>scale_</code><code>)</code> (Any) \u2014 Center and/or scale the data&lt;/&gt;</li> <li><code>sd</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the standard deviation of a vector&lt;/&gt;</li> <li><code>seq</code><code>(</code><code>from_</code>, <code>to</code>, <code>by</code>, <code>length_out</code>, <code>along_with</code><code>)</code> (Any) \u2014 Generate a sequence&lt;/&gt;</li> <li><code>seq_along</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Generate a sequence along a vector&lt;/&gt;</li> <li><code>seq_len</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Generate a sequence of length x&lt;/&gt;</li> <li><code>set_colnames</code><code>(</code><code>x</code>, <code>names</code>, <code>nested</code><code>)</code> (Any) \u2014 Set the column names&lt;/&gt;</li> <li><code>set_levels</code><code>(</code><code>x</code>, <code>levels</code><code>)</code> (Any) \u2014 Set the levels of a factor&lt;/&gt;</li> <li><code>set_rownames</code><code>(</code><code>x</code>, <code>names</code><code>)</code> (Any) \u2014 Set the row names&lt;/&gt;</li> <li><code>set_seed</code><code>(</code><code>seed</code><code>)</code> (Any) \u2014 Set the seed of the random number generator&lt;/&gt;</li> <li><code>setdiff</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Get the difference of two vectors&lt;/&gt;</li> <li><code>setequal</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Check if two vectors are equal&lt;/&gt;</li> <li><code>sign</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the sign of a vector&lt;/&gt;</li> <li><code>signif</code><code>(</code><code>x</code>, <code>digits</code><code>)</code> (Any) \u2014 Round the values of a vector to a given number of significant digits&lt;/&gt;</li> <li><code>sin</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the sine&lt;/&gt;</li> <li><code>sinh</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the hyperbolic sine&lt;/&gt;</li> <li><code>sinpi</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the sine of pi times x&lt;/&gt;</li> <li><code>sort</code><code>(</code><code>x</code>, <code>decreasing</code>, <code>na_last</code><code>)</code> (Any) \u2014 Sort a vector&lt;/&gt;</li> <li><code>sprintf</code><code>(</code><code>fmt</code>, <code>*args</code><code>)</code> (Any) \u2014 Format a string&lt;/&gt;</li> <li><code>sqrt</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the square root of a vector&lt;/&gt;</li> <li><code>startswith</code><code>(</code><code>x</code>, <code>prefix</code><code>)</code> (Any) \u2014 Does x start with prefix&lt;/&gt;</li> <li><code>strsplit</code><code>(</code><code>x</code>, <code>split</code>, <code>fixed</code>, <code>perl</code>, <code>use_bytes</code><code>)</code> (Any) \u2014 Split a string&lt;/&gt;</li> <li><code>strtoi</code><code>(</code><code>x</code>, <code>base</code><code>)</code> (Any) \u2014 Convert a string to an integer&lt;/&gt;</li> <li><code>sub</code><code>(</code><code>pattern</code>, <code>replacement</code>, <code>x</code>, <code>ignore_case</code>, <code>fixed</code><code>)</code> (Any) \u2014 Substitute a pattern&lt;/&gt;</li> <li><code>substr</code><code>(</code><code>x</code>, <code>start</code>, <code>stop</code><code>)</code> (Any) \u2014 Get a substring&lt;/&gt;</li> <li><code>substring</code><code>(</code><code>x</code>, <code>first</code>, <code>last</code><code>)</code> (Any) \u2014 Get a substring&lt;/&gt;</li> <li><code>sum_</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the sum of a vector&lt;/&gt;</li> <li><code>t</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the transpose&lt;/&gt;</li> <li><code>table</code><code>(</code><code>x</code>, <code>*more</code>, <code>exclude</code>, <code>use_na</code>, <code>dnn</code>, <code>deparse_level</code><code>)</code> (Any) \u2014 Get the table of a vector&lt;/&gt;</li> <li><code>tabulate</code><code>(</code><code>bin</code>, <code>nbins</code><code>)</code> (Any) \u2014 Get the table of a vector&lt;/&gt;</li> <li><code>tail</code><code>(</code><code>x</code>, <code>n</code><code>)</code> (Any) \u2014 Get the last n rows&lt;/&gt;</li> <li><code>tan</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the tangent&lt;/&gt;</li> <li><code>tanh</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the hyperbolic tangent&lt;/&gt;</li> <li><code>tanpi</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the tangent of pi times x&lt;/&gt;</li> <li><code>tolower</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a string to lower case&lt;/&gt;</li> <li><code>toupper</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a string to upper case&lt;/&gt;</li> <li><code>trigamma</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the trigamma function&lt;/&gt;</li> <li><code>trimws</code><code>(</code><code>x</code>, <code>which</code>, <code>whitespace</code><code>)</code> (Any) \u2014 Trim whitespace from a string&lt;/&gt;</li> <li><code>trunc</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Truncate the values of a vector&lt;/&gt;</li> <li><code>union</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Get the union of two vectors&lt;/&gt;</li> <li><code>unique</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the unique values&lt;/&gt;</li> <li><code>var</code><code>(</code><code>x</code>, <code>na_rm</code>, <code>ddof</code><code>)</code> (Any) \u2014 Compute the variance of a vector&lt;/&gt;</li> <li><code>weighted_mean</code><code>(</code><code>x</code>, <code>w</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the weighted mean of a vector&lt;/&gt;</li> <li><code>which</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the indices of the non-zero values&lt;/&gt;</li> <li><code>which_max</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the index of the maximum value&lt;/&gt;</li> <li><code>which_min</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the index of the minimum value&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Round up to the nearest integer</p> Parameters <ul> <li><code>x</code> \u2014 The value to be rounded up</li> </ul> Returns (Any) <p>The rounded up value</p> function &lt;/&gt; <p>Compute pairwise covariance between two variables</p> Parameters <ul> <li><code>x</code> \u2014 a numeric vector, matrix or data frame.</li> <li><code>y</code> (optional) \u2014 None or a vector, matrix or data frame withcompatible dimensions to <code>x</code>.  The default is equivalent to <code>y = x</code> </li> <li><code>na_rm</code> (bool, optional) \u2014 If <code>True</code>, remove missing values before computingthe covariance. </li> <li><code>ddof</code> (int, optional) \u2014 The denominator degrees of freedom.</li> </ul> Returns (Any) <p>The covariance matrix</p> function &lt;/&gt; <p>Round down to the nearest integer</p> Parameters <ul> <li><code>x</code> \u2014 The value to be rounded down</li> </ul> Returns (Any) <p>The rounded down value</p> function &lt;/&gt; <p>Compute the mean of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The mean of the vector</p> function &lt;/&gt; <p>Compute the median of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The median of the vector</p> function &lt;/&gt; <p>Returns the (regular or Parallel) maxima and minima of the input values.</p> Parameters <ul> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> <li><code>x</code> \u2014 A numeric vector</li> <li><code>more</code> \u2014 One or more values</li> </ul> Returns (Any) <p>The maximum of the vector and the values</p> function &lt;/&gt; <p>Returns the (regular or Parallel) maxima and minima of the input values.</p> Parameters <ul> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> <li><code>x</code> \u2014 A numeric vector</li> <li><code>more</code> \u2014 One or more values</li> </ul> Returns (Any) <p>The minimum of the vector and the values</p> function &lt;/&gt; <p>Compute the square root of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The square root of the vector</p> function &lt;/&gt; <p>Compute the variance of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> <li><code>ddof</code> (int, optional) \u2014 The degrees of freedom</li> <li><code>y</code> \u2014 None or a vector, matrix or data frame withcompatible dimensions to <code>x</code>.  The default is equivalent to <code>y = x</code> </li> </ul> Returns (Any) <p>The variance of the vector</p> function &lt;/&gt; <p>Center and/or scale the data</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>center</code> (optional) \u2014 Whether to center the data</li> <li><code>scale_</code> (optional) \u2014 Whether to scale the data</li> </ul> Returns (Any) <p>The scaled data</p> function &lt;/&gt; <p>Compute the column sums of a matrix</p> Parameters <ul> <li><code>x</code> \u2014 A numeric matrix</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The column sums of the matrix</p> function &lt;/&gt; <p>Compute the column means of a matrix</p> Parameters <ul> <li><code>x</code> \u2014 A numeric matrix</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The column means of the matrix</p> function &lt;/&gt; <p>Compute the column standard deviations of a matrix</p> Parameters <ul> <li><code>x</code> \u2014 A numeric matrix</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The column standard deviations of the matrix</p> function &lt;/&gt; <p>Compute the column medians of a matrix</p> Parameters <ul> <li><code>x</code> \u2014 A numeric matrix</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The column medians of the matrix</p> function &lt;/&gt; <p>Compute the row sums of a matrix</p> Parameters <ul> <li><code>x</code> \u2014 A numeric matrix</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The row sums of the matrix</p> function &lt;/&gt; <p>Compute the row means of a matrix</p> Parameters <ul> <li><code>x</code> \u2014 A numeric matrix</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The row means of the matrix</p> function &lt;/&gt; <p>Compute the row standard deviations of a matrix</p> Parameters <ul> <li><code>x</code> \u2014 A numeric matrix</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The row standard deviations of the matrix</p> function &lt;/&gt; <p>Compute the row medians of a matrix</p> Parameters <ul> <li><code>x</code> \u2014 A numeric matrix</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The row medians of the matrix</p> function &lt;/&gt; <p>Compute the minimum of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The minimum of the vector</p> function &lt;/&gt; <p>Compute the maximum of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The maximum of the vector</p> function &lt;/&gt; <p>Round the values of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>digits</code> (int, optional) \u2014 The number of digits to round to</li> </ul> Returns (Any) <p>The rounded values</p> function &lt;/&gt; <p>Compute the sum of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The sum of the vector</p> function &lt;/&gt; <p>Compute the absolute value of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The absolute values of the vector</p> function &lt;/&gt; <p>Compute the product of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The product of the vector</p> function &lt;/&gt; <p>Compute the sign of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The signs of the vector</p> function &lt;/&gt; <p>Round the values of a vector to a given number of significant digits</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>digits</code> (int, optional) \u2014 The number of significant digits to round to</li> </ul> Returns (Any) <p>The rounded values</p> function &lt;/&gt; <p>Truncate the values of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The truncated values</p> function &lt;/&gt; <p>Compute the exponential of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The exponential values</p> function &lt;/&gt; <p>Compute the logarithm of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>base</code> (float, optional) \u2014 The base of the logarithm</li> </ul> Returns (Any) <p>The logarithm values</p> function &lt;/&gt; <p>Compute the base-2 logarithm of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The logarithm values</p> function &lt;/&gt; <p>Compute the base 10 logarithm of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The logarithm values</p> function &lt;/&gt; <p>Compute the logarithm of one plus a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The logarithm values</p> function &lt;/&gt; <p>Compute the standard deviation of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The standard deviation of the vector</p> function &lt;/&gt; <p>Compute the weighted mean of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>w</code> (optional) \u2014 The weights to use</li> <li><code>na_rm</code> (bool, optional) \u2014 Whether to remove <code>NA</code> values</li> </ul> Returns (Any) <p>The weighted mean of the vector</p> function &lt;/&gt; <p>Compute the quantiles of a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>probs</code> (optional) \u2014 The probabilities to use</li> </ul> Returns (Any) <p>The quantiles of the vector</p> function &lt;/&gt; <p>Compute the modified Bessel function of the first kind</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>nu</code> \u2014 The order of the Bessel function</li> <li><code>expon_scaled</code> (bool, optional) \u2014 Whether to use the scaled version</li> </ul> Returns (Any) <p>The Bessel function values</p> function &lt;/&gt; <p>Compute the Bessel function of the first kind</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>nu</code> \u2014 The order of the Bessel function</li> </ul> Returns (Any) <p>The Bessel function values</p> function &lt;/&gt; <p>Compute the modified Bessel function of the second kind</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>nu</code> \u2014 The order of the Bessel function</li> <li><code>expon_scaled</code> (bool, optional) \u2014 Whether to use the scaled version</li> </ul> Returns (Any) <p>The Bessel function values</p> function &lt;/&gt; <p>Compute the Bessel function of the second kind</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>nu</code> \u2014 The order of the Bessel function</li> </ul> Returns (Any) <p>The Bessel function values</p> function &lt;/&gt; <p>Convert a vector to a double vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The double vector</p> function &lt;/&gt; <p>Convert a vector to an integer vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The integer vector</p> function &lt;/&gt; <p>Convert a vector to a logical vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The logical vector</p> function &lt;/&gt; <p>Convert a vector to a character vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The character vector</p> function &lt;/&gt; <p>Convert a vector to a factor vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The factor vector</p> function &lt;/&gt; <p>Convert a vector to an ordered vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The ordered vector</p> function &lt;/&gt; <p>Convert an object to a datetime.date object</p><p>See: https://rdrr.io/r/base/as.Date.html</p> Parameters <ul> <li><code>x</code> \u2014 Object that can be converted into a datetime.date object</li> <li><code>format</code> (optional) \u2014 If not specified, it will try try_formats one by one onthe first non-np.nan element, and give an error if none works. Otherwise, the processing is via strptime </li> <li><code>try_formats</code> (optional) \u2014 vector of format strings to try if format is not specified.Default formats to try: \"%Y-%m-%d\" \"%Y/%m/%d\" \"%Y-%m-%d %H:%M:%S\" \"%Y/%m/%d %H:%M:%S\" </li> <li><code>optional</code> (optional) \u2014 indicating to return np.nan (instead of signalling an error)if the format guessing does not succeed. </li> <li><code>tz</code> (optional) \u2014 a time zone offset or a datetime.timedelta object.Note that time zone name is not supported yet. </li> <li><code>origin</code> (optional) \u2014 a datetime.date/datetime object, or something which can becoerced by as_date(origin, ...) to such an object. </li> </ul> Returns (Any) <p>The datetime.date object</p> function &lt;/&gt; <p>Convert a vector to a numeric vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The numeric vector</p> function &lt;/&gt; <p>Angles of complex numbers</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The angles</p> function &lt;/&gt; <p>Complex conjugate</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The complex conjugates</p> function &lt;/&gt; <p>Modulus of complex numbers</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The modulus</p> function &lt;/&gt; <p>Real part of complex numbers</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The real parts</p> function &lt;/&gt; <p>Imaginary part of complex numbers</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The imaginary parts</p> function &lt;/&gt; <p>Convert a vector to a complex vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The complex vector</p> function &lt;/&gt; <p>Check if a vector is complex</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>Whether the vector is complex</p> function &lt;/&gt; <p>Cumulative maxima</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The cumulative maxima</p> function &lt;/&gt; <p>Cumulative minima</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The cumulative minima</p> function &lt;/&gt; <p>Cumulative products</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The cumulative products</p> function &lt;/&gt; <p>Cumulative sums</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The cumulative sums</p> function &lt;/&gt; <p>Drop unused levels of a factor</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The factor vector</p> function &lt;/&gt; <p>Get the levels of a factor</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The factor vector</p> function &lt;/&gt; <p>Set the levels of a factor</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>levels</code> \u2014 The new levels</li> </ul> Returns (Any) <p>The factor vector</p> function &lt;/&gt; <p>Check if a vector is a factor</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>Whether the vector is a factor</p> function &lt;/&gt; <p>Check if a vector is ordered</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>Whether the vector is ordered</p> function &lt;/&gt; <p>Get the number of levels of a factor</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The number of levels</p> function &lt;/&gt; <p>Create a factor vector</p> Parameters <ul> <li><code>x</code> (optional) \u2014 A numeric vector</li> <li><code>levels</code> (optional) \u2014 The levels</li> <li><code>labels</code> (optional) \u2014 The labels</li> <li><code>exclude</code> (optional) \u2014 The excluded levels</li> <li><code>ordered</code> (optional) \u2014 Whether the factor is ordered</li> <li><code>nmax</code> (optional) \u2014 The maximum number of levels</li> </ul> Returns (Any) <p>The factor vector</p> function &lt;/&gt; <p>Create an ordered factor vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>levels</code> (optional) \u2014 The levels</li> <li><code>labels</code> (optional) \u2014 The labels</li> <li><code>exclude</code> (optional) \u2014 The excluded levels</li> <li><code>nmax</code> (optional) \u2014 The maximum number of levels</li> </ul> Returns (Any) <p>The ordered factor vector</p> function &lt;/&gt; <p>Cut a numeric vector into bins</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>breaks</code> \u2014 The breaks</li> <li><code>labels</code> (optional) \u2014 The labels</li> <li><code>include_lowest</code> (optional) \u2014 Whether to include the lowest value</li> <li><code>right</code> (optional) \u2014 Whether to include the rightmost value</li> <li><code>dig_lab</code> (optional) \u2014 The number of digits for labels</li> <li><code>ordered_result</code> (optional) \u2014 Whether to return an ordered factor</li> </ul> Returns (Any) <p>The factor vector</p> function &lt;/&gt; <p>Difference of a numeric vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>lag</code> (int, optional) \u2014 The lag to use. Could be negative.It always calculates <code>x[lag:] - x[:-lag]</code> even when <code>lag</code> is negative </li> <li><code>differences</code> (int, optional) \u2014 The order of the difference</li> </ul> Returns (An array of `x[lag) <p>] \u2013 x[:-lag]<code>.If</code>differences &gt; 1<code>, the rule applies</code>differences<code>times on</code>x`</p> function &lt;/&gt; <p>Expand a grid</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>*args</code> \u2014 Additional numeric vectors</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments</li> </ul> Returns (Any) <p>The expanded grid</p> function &lt;/&gt; <p>Outer product of two vectors</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>y</code> \u2014 A numeric vector</li> <li><code>fun</code> (optional) \u2014 The function to handle how the result of the elements fromthe first and second vectors should be computed. The function has to be vectorized at the second argument, and return the same shape as y. </li> </ul> Returns (Any) <p>The outer product</p> function &lt;/&gt; <p>Make names for a vector</p> Parameters <ul> <li><code>names</code> \u2014 character vector to be coerced to syntactically valid names.This is coerced to character if necessary. </li> <li><code>unique</code> (bool, optional) \u2014 Whether to make the names unique</li> </ul> Returns (Any) <p>The names</p> function &lt;/&gt; <p>Make a vector unique</p> Parameters <ul> <li><code>names</code> \u2014 a character vector</li> </ul> Returns (Any) <p>The unique vector</p> function &lt;/&gt; <p>Rank a numeric vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>na_last</code> (bool, optional) \u2014 Whether to put NA at the end</li> <li><code>ties_method</code> (str, optional) \u2014 The method to handle ties. One of \"average\", \"first\",\"last\", \"random\", \"max\", \"min\" </li> </ul> Returns (Any) <p>The ranks</p> function &lt;/&gt; <p>Identity function</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>The same vector</p> function &lt;/&gt; <p>Check if a vector is logical</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> </ul> Returns (Any) <p>Whether the vector is logical</p> function &lt;/&gt; <p>Check if anything is true</p> Parameters <ul> <li><code>x</code> \u2014 object to be tested</li> </ul> Returns (bool) <p>Whether <code>x</code> is true</p> function &lt;/&gt; <p>Check if anything is false</p> Parameters <ul> <li><code>x</code> \u2014 object to be tested</li> </ul> Returns (bool) <p>Whether <code>x</code> is false</p> function &lt;/&gt; <p>Check if anything is NA</p> Parameters <ul> <li><code>x</code> \u2014 object to be tested</li> </ul> Returns (Any) <p>Whether <code>x</code> is NA</p> function &lt;/&gt; <p>Check if anything is finite</p> Parameters <ul> <li><code>x</code> \u2014 object to be tested</li> </ul> Returns (Any) <p>Whether <code>x</code> is finite</p> function &lt;/&gt; <p>Check if anything is infinite</p> Parameters <ul> <li><code>x</code> \u2014 object to be tested</li> </ul> Returns (Any) <p>Whether <code>x</code> is infinite</p> function &lt;/&gt; <p>Check if anything in <code>x</code> is NA</p> Parameters <ul> <li><code>x</code> \u2014 object to be tested</li> </ul> Returns (Any) <p>Whether anything in <code>x</code> is NA</p> function &lt;/&gt; <p>Convert anything to NULL</p> Parameters <ul> <li><code>x</code> \u2014 object to be converted</li> </ul> Returns (Any) <p>NULL</p> function &lt;/&gt; <p>Check if anything is NULL</p> Parameters <ul> <li><code>x</code> \u2014 object to be tested</li> </ul> Returns (Any) <p>Whether <code>x</code> is NULL</p> function &lt;/&gt; <p>Set the seed of the random number generator</p> Parameters <ul> <li><code>seed</code> \u2014 The seed</li> </ul> function &lt;/&gt; <p>Replicate elements of a vector</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> <li><code>times</code> (optional) \u2014 number of times to repeat each element if of length len(x),or to repeat the whole vector if of length 1 </li> <li><code>length</code> (optional) \u2014 non-negative integer. The desired length of the output vector</li> <li><code>each</code> (optional) \u2014 non-negative integer. Each element of x is repeated each times.</li> </ul> Returns (Any) <p>The replicated vector</p> function &lt;/&gt; <p>Concatenate vectors</p> Parameters <ul> <li><code>args</code> \u2014 vectors to be concatenated</li> </ul> Returns (Any) <p>The concatenated vector</p> function &lt;/&gt; <p>Get the length of a vector</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The length of the vector</p> function &lt;/&gt; <p>Get the lengths of a list</p> Parameters <ul> <li><code>x</code> \u2014 a list</li> </ul> Returns (Any) <p>The lengths of the list</p> function &lt;/&gt; <p>Order a vector</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> <li><code>decreasing</code> (bool, optional) \u2014 Whether to order in decreasing order</li> <li><code>na_last</code> (bool, optional) \u2014 Whether to put NA at the end</li> </ul> Returns (Any) <p>The order</p> function &lt;/&gt; <p>Sort a vector</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> <li><code>decreasing</code> (bool, optional) \u2014 Whether to sort in decreasing order</li> <li><code>na_last</code> (bool, optional) \u2014 Whether to put NA at the end</li> </ul> Returns (Any) <p>The sorted vector</p> function &lt;/&gt; <p>Reverse a vector</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The reversed vector</p> function &lt;/&gt; <p>Sample a vector</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> <li><code>size</code> (optional) \u2014 the size of the sample</li> <li><code>replace</code> (bool, optional) \u2014 whether to sample with replacement</li> <li><code>prob</code> (optional) \u2014 the probabilities of sampling each element</li> </ul> Returns (Any) <p>The sampled vector</p> function &lt;/&gt; <p>Generate a sequence</p> Parameters <ul> <li><code>from_</code> (optional) \u2014 the start of the sequence</li> <li><code>to</code> (optional) \u2014 the end of the sequence</li> <li><code>by</code> (optional) \u2014 the step of the sequence</li> <li><code>length_out</code> (optional) \u2014 the length of the sequence</li> <li><code>along_with</code> (optional) \u2014 the sequence to be aligned with</li> </ul> Returns (Any) <p>The sequence</p> function &lt;/&gt; <p>Generate a sequence along a vector</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The sequence</p> function &lt;/&gt; <p>Generate a sequence of length x</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The sequence</p> function &lt;/&gt; <p>Match elements of a vector</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> <li><code>table</code> \u2014 the table to match</li> <li><code>nomatch</code> (optional) \u2014 the value to use for no match</li> </ul> Returns (Any) <p>The matched vector</p> function &lt;/&gt; <p>Compute the beta function</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> <li><code>y</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The beta function</p> function &lt;/&gt; <p>Compute the log gamma function</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The log gamma function</p> function &lt;/&gt; <p>Compute the digamma function</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The digamma function</p> function &lt;/&gt; <p>Compute the trigamma function</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The trigamma function</p> function &lt;/&gt; <p>Compute the binomial coefficient</p> Parameters <ul> <li><code>n</code> \u2014 a vector or scaler</li> <li><code>k</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The binomial coefficient</p> function &lt;/&gt; <p>Compute the factorial</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The factorial</p> function &lt;/&gt; <p>Compute the gamma function</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The gamma function</p> function &lt;/&gt; <p>Compute the log factorial</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The log factorial</p> function &lt;/&gt; <p>Compute the log binomial coefficient</p> Parameters <ul> <li><code>n</code> \u2014 a vector or scaler</li> <li><code>k</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The log binomial coefficient</p> function &lt;/&gt; <p>Compute the log beta function</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> <li><code>y</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>The log beta function</p> function &lt;/&gt; <p>Compute the psi function</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> <li><code>deriv</code> \u2014 the derivative</li> </ul> Returns (Any) <p>The psi function</p> function &lt;/&gt; <p>Generate random normal variables</p> Parameters <ul> <li><code>n</code> \u2014 the number of random variables</li> <li><code>mean</code> (optional) \u2014 the mean of the random variables</li> <li><code>sd</code> (optional) \u2014 the standard deviation of the random variables</li> </ul> Returns (Any) <p>The random normal variables</p> function &lt;/&gt; <p>Generate random uniform variables</p> Parameters <ul> <li><code>n</code> \u2014 the number of random variables</li> <li><code>min</code> (optional) \u2014 the minimum of the random variables</li> <li><code>max</code> (optional) \u2014 the maximum of the random variables</li> </ul> Returns (Any) <p>The random uniform variables</p> function &lt;/&gt; <p>Generate random Poisson variables</p> Parameters <ul> <li><code>n</code> \u2014 the number of random variables</li> <li><code>lambda_</code> \u2014 the lambda of the random variables</li> </ul> Returns (Any) <p>The random Poisson variables</p> function &lt;/&gt; <p>Generate random binomial variables</p> Parameters <ul> <li><code>n</code> \u2014 the number of random variables</li> <li><code>size</code> \u2014 the size of the random variables</li> <li><code>prob</code> \u2014 the probability of the random variables</li> </ul> Returns (Any) <p>The random binomial variables</p> function &lt;/&gt; <p>Generate random Cauchy variables</p> Parameters <ul> <li><code>n</code> \u2014 the number of random variables</li> <li><code>location</code> (optional) \u2014 the location of the random variables</li> <li><code>scale</code> (optional) \u2014 the scale of the random variables</li> </ul> Returns (Any) <p>The random Cauchy variables</p> function &lt;/&gt; <p>Generate random chi-squared variables</p> Parameters <ul> <li><code>n</code> \u2014 the number of random variables</li> <li><code>df</code> \u2014 the degrees of freedom of the random variables</li> </ul> Returns (Any) <p>The random chi-squared variables</p> function &lt;/&gt; <p>Generate random exponential variables</p> Parameters <ul> <li><code>n</code> \u2014 the number of random variables</li> <li><code>rate</code> \u2014 the rate of the random variables</li> </ul> Returns (Any) <p>The random exponential variables</p> function &lt;/&gt; <p>Is x a character vector</p> Parameters <ul> <li><code>x</code> \u2014 a vector or scaler</li> </ul> Returns (Any) <p>True if x is a character vector</p> function &lt;/&gt; <p>Grep for a pattern</p> Parameters <ul> <li><code>pattern</code> \u2014 the pattern to search for</li> <li><code>x</code> \u2014 the vector to search</li> <li><code>ignore_case</code> (optional) \u2014 ignore case</li> <li><code>value</code> (optional) \u2014 return the value</li> <li><code>fixed</code> (optional) \u2014 use fixed string matching</li> <li><code>invert</code> (optional) \u2014 invert the match</li> </ul> Returns (Any) <p>The indices of the matches</p> function &lt;/&gt; <p>Grep for a pattern</p> Parameters <ul> <li><code>pattern</code> \u2014 the pattern to search for</li> <li><code>x</code> \u2014 the vector to search</li> <li><code>ignore_case</code> (optional) \u2014 ignore case</li> <li><code>fixed</code> (optional) \u2014 use fixed string matching</li> </ul> Returns (Any) <p>The indices of the matches</p> function &lt;/&gt; <p>Substitute a pattern</p> Parameters <ul> <li><code>pattern</code> \u2014 the pattern to search for</li> <li><code>replacement</code> \u2014 the replacement</li> <li><code>x</code> \u2014 the vector to search</li> <li><code>ignore_case</code> (optional) \u2014 ignore case</li> <li><code>fixed</code> (optional) \u2014 use fixed string matching</li> </ul> Returns (Any) <p>The vector with the substitutions</p> function &lt;/&gt; <p>Substitute a pattern</p> Parameters <ul> <li><code>pattern</code> \u2014 the pattern to search for</li> <li><code>replacement</code> \u2014 the replacement</li> <li><code>x</code> \u2014 the vector to search</li> <li><code>ignore_case</code> (optional) \u2014 ignore case</li> <li><code>fixed</code> (optional) \u2014 use fixed string matching</li> </ul> Returns (Any) <p>The vector with the substitutions</p> function &lt;/&gt; <p>Split a string</p> Parameters <ul> <li><code>x</code> \u2014 the vector to split</li> <li><code>split</code> \u2014 the pattern to split on</li> <li><code>fixed</code> (optional) \u2014 use fixed string matching</li> <li><code>perl</code> (optional) \u2014 use perl regular expressions</li> <li><code>use_bytes</code> (optional) \u2014 use bytes</li> </ul> Returns (Any) <p>The vector with the splits</p> function &lt;/&gt; <p>Join a vector into a string</p> Parameters <ul> <li><code>*args</code> \u2014 the vector to join</li> <li><code>sep</code> (optional) \u2014 the separator</li> <li><code>collapse</code> (optional) \u2014 collapse the vector</li> </ul> Returns (Any) <p>The vector joined into a string</p> function &lt;/&gt; <p>Join a vector into a string</p> Parameters <ul> <li><code>*args</code> \u2014 the vector to join</li> <li><code>collapse</code> (optional) \u2014 collapse the vector</li> </ul> Returns (Any) <p>The vector joined into a string</p> function &lt;/&gt; <p>Format a string</p> Parameters <ul> <li><code>fmt</code> \u2014 the format string</li> <li><code>args</code> \u2014 the arguments to the format string</li> </ul> Returns (Any) <p>The formatted string</p> function &lt;/&gt; <p>Get a substring</p> Parameters <ul> <li><code>x</code> \u2014 the string to get the substring from</li> <li><code>start</code> \u2014 the start of the substring</li> <li><code>stop</code> \u2014 the stop of the substring</li> </ul> Returns (Any) <p>The substring</p> function &lt;/&gt; <p>Get a substring</p> Parameters <ul> <li><code>x</code> \u2014 the string to get the substring from</li> <li><code>first</code> \u2014 the start of the substring</li> <li><code>last</code> (optional) \u2014 the stop of the substring</li> </ul> Returns (Any) <p>The substring</p> function &lt;/&gt; <p>Does x start with prefix</p> Parameters <ul> <li><code>x</code> \u2014 the string to check</li> <li><code>prefix</code> \u2014 the prefix to check</li> </ul> Returns (Any) <p>True if x starts with prefix</p> function &lt;/&gt; <p>Does x end with suffix</p> Parameters <ul> <li><code>x</code> \u2014 the string to check</li> <li><code>suffix</code> \u2014 the suffix to check</li> </ul> Returns (Any) <p>True if x ends with suffix</p> function &lt;/&gt; <p>Convert a string to an integer</p> Parameters <ul> <li><code>x</code> \u2014 the string to convert</li> <li><code>base</code> (optional) \u2014 the base of the integer</li> </ul> Returns (Any) <p>The integer</p> function &lt;/&gt; <p>Trim whitespace from a string</p> Parameters <ul> <li><code>x</code> \u2014 the string to trim</li> <li><code>which</code> (optional) \u2014 which whitespace to trim</li> <li><code>whitespace</code> (optional) \u2014 the whitespace to trim</li> </ul> Returns (Any) <p>The trimmed string</p> function &lt;/&gt; <p>Convert a string to upper case</p> Parameters <ul> <li><code>x</code> \u2014 the string to convert</li> </ul> Returns (Any) <p>The upper case string</p> function &lt;/&gt; <p>Convert a string to lower case</p> Parameters <ul> <li><code>x</code> \u2014 the string to convert</li> </ul> Returns (Any) <p>The lower case string</p> function &lt;/&gt; <p>Translate characters</p> Parameters <ul> <li><code>old</code> \u2014 the characters to translate</li> <li><code>new</code> \u2014 the new characters</li> <li><code>x</code> \u2014 the string to translate</li> </ul> Returns (Any) <p>The translated string</p> function &lt;/&gt; <p>Get the number of characters in a string</p> Parameters <ul> <li><code>x</code> \u2014 the string to count</li> <li><code>allow_na</code> (bool, optional) \u2014 allow NA</li> <li><code>keep_na</code> (bool, optional) \u2014 keep NA</li> <li><code>type</code> \u2014 the type of count</li> </ul> Returns (Any) <p>The number of characters</p> function &lt;/&gt; <p>Is the string non-zero length</p> Parameters <ul> <li><code>x</code> \u2014 the string to check</li> <li><code>keep_na</code> (bool, optional) \u2014 keep NA</li> </ul> Returns (Any) <p>True if the string is non-zero length</p> function &lt;/&gt; <p>Get the table of a vector</p> Parameters <ul> <li><code>x</code> \u2014 the vector to get the table of</li> <li><code>exclude</code> (optional) \u2014 exclude these values</li> <li><code>use_na</code> (optional) \u2014 use NA</li> <li><code>dnn</code> (optional) \u2014 the names of the vectors</li> <li><code>deparse_level</code> (optional) \u2014 the deparse level</li> <li><code>more</code> \u2014 more vectors</li> </ul> Returns (Any) <p>The table</p> function &lt;/&gt; <p>Get the table of a vector</p> Parameters <ul> <li><code>bin</code> \u2014 the vector to get the table of</li> <li><code>nbins</code> (optional) \u2014 the number of bins</li> </ul> Returns (Any) <p>An integer valued 'integer' vector (without names).There is a bin for each of the values '1, ..., nbins'</p> function &lt;/&gt; <p>Is the object atomic</p> Parameters <ul> <li><code>x</code> \u2014 the object to check</li> </ul> Returns (Any) <p>True if the object is atomic</p> function &lt;/&gt; <p>Is the object a double</p> Parameters <ul> <li><code>x</code> \u2014 the object to check</li> </ul> Returns (Any) <p>True if the object is a double</p> function &lt;/&gt; <p>Is the object an element of the table</p> Parameters <ul> <li><code>x</code> \u2014 the object to check</li> <li><code>y</code> \u2014 the pool to check</li> </ul> Returns (Any) <p>True if the object is an element of the pool</p> function &lt;/&gt; <p>Is the object an integer</p> Parameters <ul> <li><code>x</code> \u2014 the object to check</li> </ul> Returns (Any) <p>True if the object is an integer</p> function &lt;/&gt; <p>Is the object numeric</p> Parameters <ul> <li><code>x</code> \u2014 the object to check</li> </ul> Returns (Any) <p>True if the object is numeric</p> function &lt;/&gt; <p>Is any element true</p> Parameters <ul> <li><code>x</code> \u2014 the vector to check</li> <li><code>na_rm</code> (bool, optional) \u2014 remove NA</li> </ul> Returns (Any) <p>True if any element is true</p> function &lt;/&gt; <p>Are all elements true</p> Parameters <ul> <li><code>x</code> \u2014 the vector to check</li> <li><code>na_rm</code> (bool, optional) \u2014 remove NA</li> </ul> Returns (Any) <p>True if all elements are true</p> function &lt;/&gt; <p>Get the inverse cosine</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the inverse cosine of</li> </ul> Returns (Any) <p>The inverse cosine</p> function &lt;/&gt; <p>Get the inverse hyperbolic cosine</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the inverse hyperbolic cosine of</li> </ul> Returns (Any) <p>The inverse hyperbolic cosine</p> function &lt;/&gt; <p>Get the inverse sine</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the inverse sine of</li> </ul> Returns (Any) <p>The inverse sine</p> function &lt;/&gt; <p>Get the inverse hyperbolic sine</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the inverse hyperbolic sine of</li> </ul> Returns (Any) <p>The inverse hyperbolic sine</p> function &lt;/&gt; <p>Get the inverse tangent</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the inverse tangent of</li> </ul> Returns (Any) <p>The inverse tangent</p> function &lt;/&gt; <p>Get the inverse hyperbolic tangent</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the inverse hyperbolic tangent of</li> </ul> Returns (Any) <p>The inverse hyperbolic tangent</p> function &lt;/&gt; <p>Get the cosine</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the cosine of</li> </ul> Returns (Any) <p>The cosine</p> function &lt;/&gt; <p>Get the hyperbolic cosine</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the hyperbolic cosine of</li> </ul> Returns (Any) <p>The hyperbolic cosine</p> function &lt;/&gt; <p>Get the cosine of pi times x</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the cosine of pi times x of</li> </ul> Returns (Any) <p>The cosine of pi times x</p> function &lt;/&gt; <p>Get the sine</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the sine of</li> </ul> Returns (Any) <p>The sine</p> function &lt;/&gt; <p>Get the hyperbolic sine</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the hyperbolic sine of</li> </ul> Returns (Any) <p>The hyperbolic sine</p> function &lt;/&gt; <p>Get the sine of pi times x</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the sine of pi times x of</li> </ul> Returns (Any) <p>The sine of pi times x</p> function &lt;/&gt; <p>Get the tangent</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the tangent of</li> </ul> Returns (Any) <p>The tangent</p> function &lt;/&gt; <p>Get the hyperbolic tangent</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the hyperbolic tangent of</li> </ul> Returns (Any) <p>The hyperbolic tangent</p> function &lt;/&gt; <p>Get the tangent of pi times x</p> Parameters <ul> <li><code>x</code> \u2014 the value to get the tangent of pi times x of</li> </ul> Returns (Any) <p>The tangent of pi times x</p> function &lt;/&gt; <p>Get the inverse tangent of y/x</p> Parameters <ul> <li><code>y</code> \u2014 the numerator</li> <li><code>x</code> \u2014 the denominator</li> </ul> Returns (Any) <p>The inverse tangent of y/x</p> function &lt;/&gt; <p>Append values to the vector</p> Parameters <ul> <li><code>x</code> \u2014 the vector to append to</li> <li><code>values</code> \u2014 the values to append</li> <li><code>after</code> (int, optional) \u2014 the index to append after</li> </ul> Returns (Any) <p>The vector with the values appended</p> function &lt;/&gt; <p>Get the column names</p> Parameters <ul> <li><code>x</code> \u2014 the data frame to get the column names of</li> <li><code>nested</code> (bool, optional) \u2014 whether x is a nested data frame</li> </ul> Returns (Any) <p>The column names</p> function &lt;/&gt; <p>Set the column names</p> Parameters <ul> <li><code>x</code> \u2014 the data frame to set the column names of</li> <li><code>names</code> \u2014 the column names to set</li> <li><code>nested</code> (bool, optional) \u2014 whether the frame are nested</li> </ul> Returns (Any) <p>The data frame with the column names set</p> function &lt;/&gt; <p>Get the row names</p> Parameters <ul> <li><code>x</code> \u2014 the data frame to get the row names of</li> </ul> Returns (Any) <p>The row names</p> function &lt;/&gt; <p>Set the row names</p> Parameters <ul> <li><code>x</code> \u2014 the data frame to set the row names of</li> <li><code>names</code> \u2014 the row names to set</li> </ul> Returns (Any) <p>The data frame with the row names set</p> function &lt;/&gt; <p>Get the dimensions</p> Parameters <ul> <li><code>x</code> \u2014 the data frame to get the dimensions of</li> <li><code>nested</code> (bool, optional) \u2014 whether x is a nested data frame</li> </ul> Returns (Any) <p>The dimensions</p> function &lt;/&gt; <p>Get the diagonal of a matrix</p> Parameters <ul> <li><code>x</code> \u2014 the matrix to get the diagonal of</li> <li><code>nrow</code> (optional) \u2014 the number of rows</li> <li><code>ncol</code> (optional) \u2014 the number of columns</li> </ul> Returns (Any) <p>The diagonal of the matrix</p> function &lt;/&gt; <p>Get the duplicated values</p> Parameters <ul> <li><code>x</code> \u2014 the vector to get the duplicated values of</li> <li><code>incomparables</code> (optional) \u2014 the incomparables</li> <li><code>from_last</code> (bool, optional) \u2014 whether to search from the last</li> </ul> Returns (Any) <p>The duplicated values</p> function &lt;/&gt; <p>Get the intersection of two vectors</p> Parameters <ul> <li><code>x</code> \u2014 the first vector</li> <li><code>y</code> \u2014 the second vector</li> </ul> Returns (Any) <p>The intersection of the two vectors</p> function &lt;/&gt; <p>Get the number of columns</p> Parameters <ul> <li><code>x</code> \u2014 the data frame to get the number of columns of</li> <li><code>nested</code> (bool, optional) \u2014 whether x is a nested data frame</li> </ul> Returns (Any) <p>The number of columns</p> function &lt;/&gt; <p>Get the number of rows</p> Parameters <ul> <li><code>x</code> \u2014 the data frame to get the number of rows of</li> </ul> Returns (Any) <p>The number of rows</p> function &lt;/&gt; <p>Get the proportion table</p> Parameters <ul> <li><code>x</code> \u2014 the data frame to get the proportion table of</li> <li><code>margin</code> (int, optional) \u2014 the margin</li> </ul> Returns (Any) <p>The proportion table</p> function &lt;/&gt; <p>Get the difference of two vectors</p> Parameters <ul> <li><code>x</code> \u2014 the first vector</li> <li><code>y</code> \u2014 the second vector</li> </ul> Returns (Any) <p>The difference of the two vectors</p> function &lt;/&gt; <p>Check if two vectors are equal</p> Parameters <ul> <li><code>x</code> \u2014 the first vector</li> <li><code>y</code> \u2014 the second vector</li> </ul> Returns (Any) <p>Whether the two vectors are equal</p> function &lt;/&gt; <p>Get the unique values</p> Parameters <ul> <li><code>x</code> \u2014 the vector to get the unique values of</li> </ul> Returns (Any) <p>The unique values</p> function &lt;/&gt; <p>Get the transpose</p> Parameters <ul> <li><code>x</code> \u2014 the matrix to get the transpose of</li> </ul> Returns (Any) <p>The transpose</p> function &lt;/&gt; <p>Get the union of two vectors</p> Parameters <ul> <li><code>x</code> \u2014 the first vector</li> <li><code>y</code> \u2014 the second vector</li> </ul> Returns (Any) <p>The union of the two vectors</p> function &lt;/&gt; <p>Get the maximum column</p> Parameters <ul> <li><code>x</code> \u2014 the data frame to get the maximum column of</li> <li><code>ties_method</code> (str, optional) \u2014 the ties method</li> <li><code>nested</code> (bool, optional) \u2014 whether x is a nested data frame</li> </ul> Returns (Any) <p>The maximum column</p> function &lt;/&gt; <p>Get the complete cases</p> Parameters <ul> <li><code>x</code> \u2014 the data frame to get the complete cases of</li> </ul> Returns (Any) <p>The complete cases</p> function &lt;/&gt; <p>Get the first n rows</p> Parameters <ul> <li><code>x</code> \u2014 the data frame to get the first n rows of</li> <li><code>n</code> (int, optional) \u2014 the number of rows to get</li> </ul> Returns (Any) <p>The first n rows</p> function &lt;/&gt; <p>Get the last n rows</p> Parameters <ul> <li><code>x</code> \u2014 the data frame to get the last n rows of</li> <li><code>n</code> (int, optional) \u2014 the number of rows to get</li> </ul> Returns (Any) <p>The last n rows</p> function &lt;/&gt; <p>Get the indices of the non-zero values</p> Parameters <ul> <li><code>x</code> \u2014 the vector to get the indices of the non-zero values of</li> </ul> Returns (Any) <p>The indices of the non-zero values</p> function &lt;/&gt; <p>Get the index of the maximum value</p> Parameters <ul> <li><code>x</code> \u2014 the vector to get the index of the maximum value of</li> </ul> Returns (Any) <p>The index of the maximum value</p> function &lt;/&gt; <p>Get the index of the minimum value</p> Parameters <ul> <li><code>x</code> \u2014 the vector to get the index of the minimum value of</li> </ul> Returns (Any) <p>The index of the minimum value</p>"},{"location":"api/datar.apis.base/#datarapisbase","title":"datar.apis.base","text":""},{"location":"api/datar.apis.base/#datarapisbaseceiling","title":"<code>datar.apis.base.</code><code>ceiling</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecov","title":"<code>datar.apis.base.</code><code>cov</code><code>(</code><code>x</code>, <code>y=None</code>, <code>na_rm=False</code>, <code>ddof=1</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasefloor","title":"<code>datar.apis.base.</code><code>floor</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasemean","title":"<code>datar.apis.base.</code><code>mean</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasemedian","title":"<code>datar.apis.base.</code><code>median</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasepmax","title":"<code>datar.apis.base.</code><code>pmax</code><code>(</code><code>*args</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasepmin","title":"<code>datar.apis.base.</code><code>pmin</code><code>(</code><code>*args</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesqrt","title":"<code>datar.apis.base.</code><code>sqrt</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasevar","title":"<code>datar.apis.base.</code><code>var</code><code>(</code><code>x</code>, <code>na_rm=False</code>, <code>ddof=1</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasescale","title":"<code>datar.apis.base.</code><code>scale</code><code>(</code><code>x</code>, <code>center=True</code>, <code>scale_=True</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecol_sums","title":"<code>datar.apis.base.</code><code>col_sums</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecol_means","title":"<code>datar.apis.base.</code><code>col_means</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecol_sds","title":"<code>datar.apis.base.</code><code>col_sds</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecol_medians","title":"<code>datar.apis.base.</code><code>col_medians</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaserow_sums","title":"<code>datar.apis.base.</code><code>row_sums</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaserow_means","title":"<code>datar.apis.base.</code><code>row_means</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaserow_sds","title":"<code>datar.apis.base.</code><code>row_sds</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaserow_medians","title":"<code>datar.apis.base.</code><code>row_medians</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasemin_","title":"<code>datar.apis.base.</code><code>min_</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasemax_","title":"<code>datar.apis.base.</code><code>max_</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseround_","title":"<code>datar.apis.base.</code><code>round_</code><code>(</code><code>x</code>, <code>digits=0</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesum_","title":"<code>datar.apis.base.</code><code>sum_</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseabs_","title":"<code>datar.apis.base.</code><code>abs_</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseprod","title":"<code>datar.apis.base.</code><code>prod</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesign","title":"<code>datar.apis.base.</code><code>sign</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesignif","title":"<code>datar.apis.base.</code><code>signif</code><code>(</code><code>x</code>, <code>digits=6</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasetrunc","title":"<code>datar.apis.base.</code><code>trunc</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseexp","title":"<code>datar.apis.base.</code><code>exp</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaselog","title":"<code>datar.apis.base.</code><code>log</code><code>(</code><code>x</code>, <code>base=2.718281828459045</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaselog2","title":"<code>datar.apis.base.</code><code>log2</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaselog10","title":"<code>datar.apis.base.</code><code>log10</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaselog1p","title":"<code>datar.apis.base.</code><code>log1p</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesd","title":"<code>datar.apis.base.</code><code>sd</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseweighted_mean","title":"<code>datar.apis.base.</code><code>weighted_mean</code><code>(</code><code>x</code>, <code>w=None</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasequantile","title":"<code>datar.apis.base.</code><code>quantile</code><code>(</code><code>x</code>, <code>probs=(0.0, 0.25, 0.5, 0.75, 1.0)</code>, <code>na_rm=False</code>, <code>names=True</code>, <code>type_=7</code>, <code>digits=7</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasebessel_i","title":"<code>datar.apis.base.</code><code>bessel_i</code><code>(</code><code>x</code>, <code>nu</code>, <code>expon_scaled=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasebessel_j","title":"<code>datar.apis.base.</code><code>bessel_j</code><code>(</code><code>x</code>, <code>nu</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasebessel_k","title":"<code>datar.apis.base.</code><code>bessel_k</code><code>(</code><code>x</code>, <code>nu</code>, <code>expon_scaled=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasebessel_y","title":"<code>datar.apis.base.</code><code>bessel_y</code><code>(</code><code>x</code>, <code>nu</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseas_double","title":"<code>datar.apis.base.</code><code>as_double</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseas_integer","title":"<code>datar.apis.base.</code><code>as_integer</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseas_logical","title":"<code>datar.apis.base.</code><code>as_logical</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseas_character","title":"<code>datar.apis.base.</code><code>as_character</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseas_factor","title":"<code>datar.apis.base.</code><code>as_factor</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseas_ordered","title":"<code>datar.apis.base.</code><code>as_ordered</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseas_date","title":"<code>datar.apis.base.</code><code>as_date</code><code>(</code><code>x</code>, <code>format=None</code>, <code>try_formats=None</code>, <code>optional=False</code>, <code>tz=0</code>, <code>origin=None</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseas_numeric","title":"<code>datar.apis.base.</code><code>as_numeric</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasearg","title":"<code>datar.apis.base.</code><code>arg</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseconj","title":"<code>datar.apis.base.</code><code>conj</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasemod","title":"<code>datar.apis.base.</code><code>mod</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasere_","title":"<code>datar.apis.base.</code><code>re_</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseim","title":"<code>datar.apis.base.</code><code>im</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseas_complex","title":"<code>datar.apis.base.</code><code>as_complex</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_complex","title":"<code>datar.apis.base.</code><code>is_complex</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecummax","title":"<code>datar.apis.base.</code><code>cummax</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecummin","title":"<code>datar.apis.base.</code><code>cummin</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecumprod","title":"<code>datar.apis.base.</code><code>cumprod</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecumsum","title":"<code>datar.apis.base.</code><code>cumsum</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasedroplevels","title":"<code>datar.apis.base.</code><code>droplevels</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaselevels","title":"<code>datar.apis.base.</code><code>levels</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseset_levels","title":"<code>datar.apis.base.</code><code>set_levels</code><code>(</code><code>x</code>, <code>levels</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_factor","title":"<code>datar.apis.base.</code><code>is_factor</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_ordered","title":"<code>datar.apis.base.</code><code>is_ordered</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasenlevels","title":"<code>datar.apis.base.</code><code>nlevels</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasefactor","title":"<code>datar.apis.base.</code><code>factor</code><code>(</code><code>x=None</code>, <code>levels=None</code>, <code>labels=None</code>, <code>exclude=None</code>, <code>ordered=False</code>, <code>nmax=None</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseordered","title":"<code>datar.apis.base.</code><code>ordered</code><code>(</code><code>x</code>, <code>levels=None</code>, <code>labels=None</code>, <code>exclude=None</code>, <code>nmax=None</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecut","title":"<code>datar.apis.base.</code><code>cut</code><code>(</code><code>x</code>, <code>breaks</code>, <code>labels=None</code>, <code>include_lowest=False</code>, <code>right=True</code>, <code>dig_lab=3</code>, <code>ordered_result=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasediff","title":"<code>datar.apis.base.</code><code>diff</code><code>(</code><code>x</code>, <code>lag=1</code>, <code>differences=1</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseexpand_grid","title":"<code>datar.apis.base.</code><code>expand_grid</code><code>(</code><code>x</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseouter","title":"<code>datar.apis.base.</code><code>outer</code><code>(</code><code>x</code>, <code>y</code>, <code>fun='*'</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasemake_names","title":"<code>datar.apis.base.</code><code>make_names</code><code>(</code><code>names</code>, <code>unique=True</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasemake_unique","title":"<code>datar.apis.base.</code><code>make_unique</code><code>(</code><code>names</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaserank","title":"<code>datar.apis.base.</code><code>rank</code><code>(</code><code>x</code>, <code>na_last=True</code>, <code>ties_method='average'</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseidentity","title":"<code>datar.apis.base.</code><code>identity</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_logical","title":"<code>datar.apis.base.</code><code>is_logical</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_true","title":"<code>datar.apis.base.</code><code>is_true</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_false","title":"<code>datar.apis.base.</code><code>is_false</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_na","title":"<code>datar.apis.base.</code><code>is_na</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_finite","title":"<code>datar.apis.base.</code><code>is_finite</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_infinite","title":"<code>datar.apis.base.</code><code>is_infinite</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseany_na","title":"<code>datar.apis.base.</code><code>any_na</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseas_null","title":"<code>datar.apis.base.</code><code>as_null</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_null","title":"<code>datar.apis.base.</code><code>is_null</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseset_seed","title":"<code>datar.apis.base.</code><code>set_seed</code><code>(</code><code>seed</code><code>)</code> \u2192 Any","text":""},{"location":"api/datar.apis.base/#datarapisbaserep","title":"<code>datar.apis.base.</code><code>rep</code><code>(</code><code>x</code>, <code>times=1</code>, <code>length=None</code>, <code>each=1</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasec_","title":"<code>datar.apis.base.</code><code>c_</code><code>(</code><code>*args</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaselength","title":"<code>datar.apis.base.</code><code>length</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaselengths","title":"<code>datar.apis.base.</code><code>lengths</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseorder","title":"<code>datar.apis.base.</code><code>order</code><code>(</code><code>x</code>, <code>decreasing=False</code>, <code>na_last=True</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesort","title":"<code>datar.apis.base.</code><code>sort</code><code>(</code><code>x</code>, <code>decreasing=False</code>, <code>na_last=True</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaserev","title":"<code>datar.apis.base.</code><code>rev</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesample","title":"<code>datar.apis.base.</code><code>sample</code><code>(</code><code>x</code>, <code>size=None</code>, <code>replace=False</code>, <code>prob=None</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseseq","title":"<code>datar.apis.base.</code><code>seq</code><code>(</code><code>from_=None</code>, <code>to=None</code>, <code>by=None</code>, <code>length_out=None</code>, <code>along_with=None</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseseq_along","title":"<code>datar.apis.base.</code><code>seq_along</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseseq_len","title":"<code>datar.apis.base.</code><code>seq_len</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasematch","title":"<code>datar.apis.base.</code><code>match</code><code>(</code><code>x</code>, <code>table</code>, <code>nomatch=-1</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasebeta","title":"<code>datar.apis.base.</code><code>beta</code><code>(</code><code>x</code>, <code>y</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaselgamma","title":"<code>datar.apis.base.</code><code>lgamma</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasedigamma","title":"<code>datar.apis.base.</code><code>digamma</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasetrigamma","title":"<code>datar.apis.base.</code><code>trigamma</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasechoose","title":"<code>datar.apis.base.</code><code>choose</code><code>(</code><code>n</code>, <code>k</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasefactorial","title":"<code>datar.apis.base.</code><code>factorial</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasegamma","title":"<code>datar.apis.base.</code><code>gamma</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaselfactorial","title":"<code>datar.apis.base.</code><code>lfactorial</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaselchoose","title":"<code>datar.apis.base.</code><code>lchoose</code><code>(</code><code>n</code>, <code>k</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaselbeta","title":"<code>datar.apis.base.</code><code>lbeta</code><code>(</code><code>x</code>, <code>y</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasepsigamma","title":"<code>datar.apis.base.</code><code>psigamma</code><code>(</code><code>x</code>, <code>deriv</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasernorm","title":"<code>datar.apis.base.</code><code>rnorm</code><code>(</code><code>n</code>, <code>mean=0</code>, <code>sd=1</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaserunif","title":"<code>datar.apis.base.</code><code>runif</code><code>(</code><code>n</code>, <code>min=0</code>, <code>max=1</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaserpois","title":"<code>datar.apis.base.</code><code>rpois</code><code>(</code><code>n</code>, <code>lambda_</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaserbinom","title":"<code>datar.apis.base.</code><code>rbinom</code><code>(</code><code>n</code>, <code>size</code>, <code>prob</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasercauchy","title":"<code>datar.apis.base.</code><code>rcauchy</code><code>(</code><code>n</code>, <code>location=0</code>, <code>scale=1</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaserchisq","title":"<code>datar.apis.base.</code><code>rchisq</code><code>(</code><code>n</code>, <code>df</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaserexp","title":"<code>datar.apis.base.</code><code>rexp</code><code>(</code><code>n</code>, <code>rate</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_character","title":"<code>datar.apis.base.</code><code>is_character</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasegrep","title":"<code>datar.apis.base.</code><code>grep</code><code>(</code><code>pattern</code>, <code>x</code>, <code>ignore_case=False</code>, <code>value=False</code>, <code>fixed=False</code>, <code>invert=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasegrepl","title":"<code>datar.apis.base.</code><code>grepl</code><code>(</code><code>pattern</code>, <code>x</code>, <code>ignore_case=False</code>, <code>fixed=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesub","title":"<code>datar.apis.base.</code><code>sub</code><code>(</code><code>pattern</code>, <code>replacement</code>, <code>x</code>, <code>ignore_case=False</code>, <code>fixed=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasegsub","title":"<code>datar.apis.base.</code><code>gsub</code><code>(</code><code>pattern</code>, <code>replacement</code>, <code>x</code>, <code>ignore_case=False</code>, <code>fixed=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasestrsplit","title":"<code>datar.apis.base.</code><code>strsplit</code><code>(</code><code>x</code>, <code>split</code>, <code>fixed=False</code>, <code>perl=False</code>, <code>use_bytes=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasepaste","title":"<code>datar.apis.base.</code><code>paste</code><code>(</code><code>*args</code>, <code>sep=' '</code>, <code>collapse=None</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasepaste0","title":"<code>datar.apis.base.</code><code>paste0</code><code>(</code><code>*args</code>, <code>collapse=None</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesprintf","title":"<code>datar.apis.base.</code><code>sprintf</code><code>(</code><code>fmt</code>, <code>*args</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesubstr","title":"<code>datar.apis.base.</code><code>substr</code><code>(</code><code>x</code>, <code>start</code>, <code>stop</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesubstring","title":"<code>datar.apis.base.</code><code>substring</code><code>(</code><code>x</code>, <code>first</code>, <code>last=None</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasestartswith","title":"<code>datar.apis.base.</code><code>startswith</code><code>(</code><code>x</code>, <code>prefix</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseendswith","title":"<code>datar.apis.base.</code><code>endswith</code><code>(</code><code>x</code>, <code>suffix</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasestrtoi","title":"<code>datar.apis.base.</code><code>strtoi</code><code>(</code><code>x</code>, <code>base=0</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasetrimws","title":"<code>datar.apis.base.</code><code>trimws</code><code>(</code><code>x</code>, <code>which='both'</code>, <code>whitespace=' \\\\t'</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasetoupper","title":"<code>datar.apis.base.</code><code>toupper</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasetolower","title":"<code>datar.apis.base.</code><code>tolower</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasechartr","title":"<code>datar.apis.base.</code><code>chartr</code><code>(</code><code>old</code>, <code>new</code>, <code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasenchar","title":"<code>datar.apis.base.</code><code>nchar</code><code>(</code><code>x</code>, <code>type_='width'</code>, <code>allow_na=True</code>, <code>keep_na=False</code>, <code>_na_len=2</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasenzchar","title":"<code>datar.apis.base.</code><code>nzchar</code><code>(</code><code>x</code>, <code>keep_na=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasetable","title":"<code>datar.apis.base.</code><code>table</code><code>(</code><code>x</code>, <code>*more</code>, <code>exclude=None</code>, <code>use_na='no'</code>, <code>dnn=None</code>, <code>deparse_level=1</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasetabulate","title":"<code>datar.apis.base.</code><code>tabulate</code><code>(</code><code>bin</code>, <code>nbins=None</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_atomic","title":"<code>datar.apis.base.</code><code>is_atomic</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_double","title":"<code>datar.apis.base.</code><code>is_double</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_element","title":"<code>datar.apis.base.</code><code>is_element</code><code>(</code><code>x</code>, <code>y</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_integer","title":"<code>datar.apis.base.</code><code>is_integer</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseis_numeric","title":"<code>datar.apis.base.</code><code>is_numeric</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseany_","title":"<code>datar.apis.base.</code><code>any_</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseall_","title":"<code>datar.apis.base.</code><code>all_</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseacos","title":"<code>datar.apis.base.</code><code>acos</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseacosh","title":"<code>datar.apis.base.</code><code>acosh</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseasin","title":"<code>datar.apis.base.</code><code>asin</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseasinh","title":"<code>datar.apis.base.</code><code>asinh</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseatan","title":"<code>datar.apis.base.</code><code>atan</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseatanh","title":"<code>datar.apis.base.</code><code>atanh</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecos","title":"<code>datar.apis.base.</code><code>cos</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecosh","title":"<code>datar.apis.base.</code><code>cosh</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecospi","title":"<code>datar.apis.base.</code><code>cospi</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesin","title":"<code>datar.apis.base.</code><code>sin</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesinh","title":"<code>datar.apis.base.</code><code>sinh</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesinpi","title":"<code>datar.apis.base.</code><code>sinpi</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasetan","title":"<code>datar.apis.base.</code><code>tan</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasetanh","title":"<code>datar.apis.base.</code><code>tanh</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasetanpi","title":"<code>datar.apis.base.</code><code>tanpi</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseatan2","title":"<code>datar.apis.base.</code><code>atan2</code><code>(</code><code>y</code>, <code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseappend","title":"<code>datar.apis.base.</code><code>append</code><code>(</code><code>x</code>, <code>values</code>, <code>after=-1</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecolnames","title":"<code>datar.apis.base.</code><code>colnames</code><code>(</code><code>x</code>, <code>nested=True</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseset_colnames","title":"<code>datar.apis.base.</code><code>set_colnames</code><code>(</code><code>x</code>, <code>names</code>, <code>nested=True</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaserownames","title":"<code>datar.apis.base.</code><code>rownames</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseset_rownames","title":"<code>datar.apis.base.</code><code>set_rownames</code><code>(</code><code>x</code>, <code>names</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasedim","title":"<code>datar.apis.base.</code><code>dim</code><code>(</code><code>x</code>, <code>nested=True</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasediag","title":"<code>datar.apis.base.</code><code>diag</code><code>(</code><code>x</code>, <code>nrow=None</code>, <code>ncol=None</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseduplicated","title":"<code>datar.apis.base.</code><code>duplicated</code><code>(</code><code>x</code>, <code>incomparables=None</code>, <code>from_last=False</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseintersect","title":"<code>datar.apis.base.</code><code>intersect</code><code>(</code><code>x</code>, <code>y</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasencol","title":"<code>datar.apis.base.</code><code>ncol</code><code>(</code><code>x</code>, <code>nested=True</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasenrow","title":"<code>datar.apis.base.</code><code>nrow</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseproportions","title":"<code>datar.apis.base.</code><code>proportions</code><code>(</code><code>x</code>, <code>margin=1</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesetdiff","title":"<code>datar.apis.base.</code><code>setdiff</code><code>(</code><code>x</code>, <code>y</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasesetequal","title":"<code>datar.apis.base.</code><code>setequal</code><code>(</code><code>x</code>, <code>y</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseunique","title":"<code>datar.apis.base.</code><code>unique</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaset","title":"<code>datar.apis.base.</code><code>t</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbaseunion","title":"<code>datar.apis.base.</code><code>union</code><code>(</code><code>x</code>, <code>y</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasemax_col","title":"<code>datar.apis.base.</code><code>max_col</code><code>(</code><code>x</code>, <code>ties_method='random'</code>, <code>nested=True</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasecomplete_cases","title":"<code>datar.apis.base.</code><code>complete_cases</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasehead","title":"<code>datar.apis.base.</code><code>head</code><code>(</code><code>x</code>, <code>n=6</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasetail","title":"<code>datar.apis.base.</code><code>tail</code><code>(</code><code>x</code>, <code>n=6</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasewhich","title":"<code>datar.apis.base.</code><code>which</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasewhich_max","title":"<code>datar.apis.base.</code><code>which_max</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.base/#datarapisbasewhich_min","title":"<code>datar.apis.base.</code><code>which_min</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/","title":"datar.apis.dplyr","text":"module &lt;/&gt; Functions <ul> <li><code>across</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_names</code>, <code>**kwargs</code><code>)</code> (T) \u2014 Apply the same transformation to multiple columns&lt;/&gt;</li> <li><code>add_count</code><code>(</code><code>_data</code>, <code>*args</code>, <code>wt</code>, <code>sort</code>, <code>name</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Add a count column to a data frame&lt;/&gt;</li> <li><code>add_tally</code><code>(</code><code>_data</code>, <code>wt</code>, <code>sort</code>, <code>name</code><code>)</code> (Any) \u2014 Add a count column to a data frame&lt;/&gt;</li> <li><code>all_of</code><code>(</code><code>_data</code>, <code>x</code><code>)</code> (Any) \u2014 For strict selection.&lt;/&gt;</li> <li><code>anti_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by</code>, <code>copy</code>, <code>na_matches</code><code>)</code> (Any) \u2014 Anti join two data frames by matching rows.&lt;/&gt;</li> <li><code>any_of</code><code>(</code><code>_data</code>, <code>x</code>, <code>vars</code><code>)</code> (Any) \u2014 For strict selection.&lt;/&gt;</li> <li><code>arrange</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_by_group</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 orders the rows of a data frame by the values of selected columns.&lt;/&gt;</li> <li><code>between</code><code>(</code><code>x</code>, <code>left</code>, <code>right</code>, <code>inclusive</code><code>)</code> (Any) \u2014 Check if a value is between two other values&lt;/&gt;</li> <li><code>bind_cols</code><code>(</code><code>*data</code>, <code>_name_repair</code>, <code>_copy</code><code>)</code> (Any) \u2014 Bind columns of give dataframes&lt;/&gt;</li> <li><code>bind_rows</code><code>(</code><code>*data</code>, <code>_id</code>, <code>_copy</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Bind rows of give dataframes&lt;/&gt;</li> <li><code>c_across</code><code>(</code><code>_data</code>, <code>_cols</code><code>)</code> (T) \u2014 Apply the same transformation to multiple columns rowwisely&lt;/&gt;</li> <li><code>case_match</code><code>(</code><code>_x</code>, <code>*args</code>, <code>_default</code>, <code>_dtypes</code><code>)</code> (T) \u2014 This function allows you to vectorise multiple <code>switch()</code> statements.Each case is evaluated sequentially and the first match for each element determines the corresponding value in the output vector. If no cases match, the <code>_default</code> is used. &lt;/&gt;</li> <li><code>case_when</code><code>(</code><code>cond</code>, <code>value</code>, <code>*more_cases</code><code>)</code> (Any) \u2014 Vectorise multiple <code>if_else()</code> statements.&lt;/&gt;</li> <li><code>coalesce</code><code>(</code><code>x</code>, <code>*replace</code><code>)</code> (Any) \u2014 Replace missing values with the first non-missing value&lt;/&gt;</li> <li><code>consecutive_id</code><code>(</code><code>x</code>, <code>*args</code><code>)</code> (Sequence) \u2014 Generate consecutive ids&lt;/&gt;</li> <li><code>contains</code><code>(</code><code>_data</code>, <code>match</code>, <code>ignore_case</code>, <code>vars</code><code>)</code> (Any) \u2014 Select columns that contain a string.&lt;/&gt;</li> <li><code>count</code><code>(</code><code>_data</code>, <code>*args</code>, <code>wt</code>, <code>sort</code>, <code>name</code>, <code>_drop</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Count the number of rows in each group&lt;/&gt;</li> <li><code>cross_join</code><code>(</code><code>x</code>, <code>y</code>, <code>copy</code>, <code>suffix</code><code>)</code> (T) \u2014 Cross joins match each row in x to every row in y, resulting in adata frame with nrow(x) * nrow(y) rows. &lt;/&gt;</li> <li><code>cumall</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get cumulative bool. All cases after first False&lt;/&gt;</li> <li><code>cumany</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get cumulative bool. All cases after first True&lt;/&gt;</li> <li><code>cume_dist</code><code>(</code><code>x</code>, <code>na_last</code><code>)</code> (Any) \u2014 Get the cume_dist of x&lt;/&gt;</li> <li><code>cummean</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Cumulative mean&lt;/&gt;</li> <li><code>cur_column</code><code>(</code><code>_data</code>, <code>_name</code><code>)</code> (Any) \u2014 Get the current column&lt;/&gt;</li> <li><code>cur_data</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the current dataframe&lt;/&gt;</li> <li><code>cur_data_all</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the current data for the current group includingthe grouping variables &lt;/&gt;</li> <li><code>cur_group</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the current group&lt;/&gt;</li> <li><code>cur_group_id</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the current group id&lt;/&gt;</li> <li><code>cur_group_rows</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the current group row indices&lt;/&gt;</li> <li><code>dense_rank</code><code>(</code><code>x</code>, <code>na_last</code><code>)</code> (Any) \u2014 Get the dense rank of x&lt;/&gt;</li> <li><code>desc</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Transform a vector into a format that will be sorted in descending order&lt;/&gt;</li> <li><code>distinct</code><code>(</code><code>_data</code>, <code>*args</code>, <code>keep_all</code>, <code>_preserve</code><code>)</code> (Any) \u2014 Filter a data frame based on conditions&lt;/&gt;</li> <li><code>ends_with</code><code>(</code><code>_data</code>, <code>match</code>, <code>ignore_case</code>, <code>vars</code><code>)</code> (Any) \u2014 Select columns that end with a string.&lt;/&gt;</li> <li><code>everything</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Select all variables.&lt;/&gt;</li> <li><code>filter_</code><code>(</code><code>_data</code>, <code>*conditions</code>, <code>_preserve</code><code>)</code> (Any) \u2014 Filter a data frame based on conditions&lt;/&gt;</li> <li><code>first</code><code>(</code><code>x</code>, <code>order_by</code>, <code>default</code><code>)</code> (Any) \u2014 Extract the first element of a vector&lt;/&gt;</li> <li><code>full_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by</code>, <code>copy</code>, <code>suffix</code>, <code>keep</code>, <code>na_matches</code>, <code>multiple</code>, <code>unmatched</code>, <code>relationship</code><code>)</code> (Any) \u2014 Full join two data frames by matching rows.&lt;/&gt;</li> <li><code>glimpse</code><code>(</code><code>_data</code>, <code>width</code>, <code>formatter</code><code>)</code> (Any) \u2014 Display a summary of a data frame&lt;/&gt;</li> <li><code>group_by</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_add</code>, <code>_drop</code><code>)</code> (Any) \u2014 Create a grouped frame&lt;/&gt;</li> <li><code>group_by_drop_default</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the default value of <code>_drop</code> of a frame&lt;/&gt;</li> <li><code>group_cols</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the group columns of a frame&lt;/&gt;</li> <li><code>group_data</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the group data of a frame&lt;/&gt;</li> <li><code>group_indices</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the group indices of a frame&lt;/&gt;</li> <li><code>group_keys</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the group keys of a frame&lt;/&gt;</li> <li><code>group_map</code><code>(</code><code>_data</code>, <code>_f</code>, <code>*args</code>, <code>_keep</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Apply a function to each group&lt;/&gt;</li> <li><code>group_modify</code><code>(</code><code>_data</code>, <code>_f</code>, <code>*args</code>, <code>_keep</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Apply a function to each group&lt;/&gt;</li> <li><code>group_rows</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the group rows of a frame&lt;/&gt;</li> <li><code>group_size</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the group sizes of a frame&lt;/&gt;</li> <li><code>group_split</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_keep</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Split a grouped frame into a list of data frames&lt;/&gt;</li> <li><code>group_trim</code><code>(</code><code>_data</code>, <code>_drop</code><code>)</code> (Any) \u2014 Remove empty groups&lt;/&gt;</li> <li><code>group_vars</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the grouping variables of a frame&lt;/&gt;</li> <li><code>group_walk</code><code>(</code><code>_data</code>, <code>_f</code>, <code>*args</code>, <code>_keep</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Apply a function to each group&lt;/&gt;</li> <li><code>if_all</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_names</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Apply the same predicate function to a selection of columns and combinethe results True if all elements are True. &lt;/&gt;</li> <li><code>if_any</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_names</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Apply the same predicate function to a selection of columns and combinethe results True if any element is True. &lt;/&gt;</li> <li><code>if_else</code><code>(</code><code>condition</code>, <code>true</code>, <code>false</code>, <code>missing</code><code>)</code> (Any) \u2014 Where condition is TRUE, the matching value from true, where it's FALSE,the matching value from false, otherwise missing. &lt;/&gt;</li> <li><code>inner_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by</code>, <code>copy</code>, <code>suffix</code>, <code>keep</code>, <code>na_matches</code>, <code>multiple</code>, <code>unmatched</code>, <code>relationship</code><code>)</code> (Any) \u2014 Inner join two data frames by matching rows.&lt;/&gt;</li> <li><code>lag</code><code>(</code><code>x</code>, <code>n</code>, <code>default</code>, <code>order_by</code><code>)</code> (Any) \u2014 Shift a vector by <code>n</code> positions.&lt;/&gt;</li> <li><code>last</code><code>(</code><code>x</code>, <code>order_by</code>, <code>default</code><code>)</code> (Any) \u2014 Extract the last element of a vector&lt;/&gt;</li> <li><code>last_col</code><code>(</code><code>_data</code>, <code>offset</code>, <code>vars</code><code>)</code> (Any) \u2014 Select the last column.&lt;/&gt;</li> <li><code>lead</code><code>(</code><code>x</code>, <code>n</code>, <code>default</code>, <code>order_by</code><code>)</code> (Any) \u2014 Shift a vector by <code>n</code> positions.&lt;/&gt;</li> <li><code>left_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by</code>, <code>copy</code>, <code>suffix</code>, <code>keep</code>, <code>na_matches</code>, <code>multiple</code>, <code>unmatched</code>, <code>relationship</code><code>)</code> (Any) \u2014 Left join two data frames by matching rows.&lt;/&gt;</li> <li><code>matches</code><code>(</code><code>_data</code>, <code>match</code>, <code>ignore_case</code>, <code>vars</code><code>)</code> (Any) \u2014 Select columns that match a regular expression.&lt;/&gt;</li> <li><code>min_rank</code><code>(</code><code>x</code>, <code>na_last</code><code>)</code> (Any) \u2014 Get the min rank of x&lt;/&gt;</li> <li><code>mutate</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_keep</code>, <code>_before</code>, <code>_after</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Add new columns to a data frame.&lt;/&gt;</li> <li><code>n</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Get the current group size&lt;/&gt;</li> <li><code>n_distinct</code><code>(</code><code>_data</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Count the number of distinct values&lt;/&gt;</li> <li><code>n_groups</code><code>(</code><code>_data</code><code>)</code> (int) \u2014 Get the number of groups of a frame&lt;/&gt;</li> <li><code>na_if</code><code>(</code><code>x</code>, <code>value</code><code>)</code> (Any) \u2014 Replace values with missing values&lt;/&gt;</li> <li><code>near</code><code>(</code><code>x</code>, <code>y</code>, <code>tol</code><code>)</code> (Any) \u2014 Check if values are approximately equal&lt;/&gt;</li> <li><code>nest_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by</code>, <code>copy</code>, <code>keep</code>, <code>name</code>, <code>na_matches</code>, <code>unmatched</code><code>)</code> (Any) \u2014 Nest join two data frames by matching rows.&lt;/&gt;</li> <li><code>nth</code><code>(</code><code>x</code>, <code>n</code>, <code>order_by</code>, <code>default</code><code>)</code> (Any) \u2014 Extract the nth element of a vector&lt;/&gt;</li> <li><code>ntile</code><code>(</code><code>x</code>, <code>n</code><code>)</code> (Any) \u2014 a rough rank, which breaks the input vector into n buckets.The size of the buckets may differ by up to one, larger buckets have lower rank. &lt;/&gt;</li> <li><code>num_range</code><code>(</code><code>prefix</code>, <code>range_</code>, <code>width</code><code>)</code> (Any) \u2014 Matches a numerical range like x01, x02, x03.&lt;/&gt;</li> <li><code>order_by</code><code>(</code><code>order</code>, <code>call</code><code>)</code> (Any) \u2014 Order the data by the given order&lt;/&gt;</li> <li><code>percent_rank</code><code>(</code><code>x</code>, <code>na_last</code><code>)</code> (Any) \u2014 Get the percent rank of x&lt;/&gt;</li> <li><code>pick</code><code>(</code><code>_data</code>, <code>*args</code><code>)</code> (T) \u2014 Pick columns by name&lt;/&gt;</li> <li><code>pull</code><code>(</code><code>_data</code>, <code>var</code>, <code>name</code>, <code>to</code><code>)</code> (Any) \u2014 Pull a series or a dataframe from a dataframe&lt;/&gt;</li> <li><code>recode</code><code>(</code><code>_x</code>, <code>*args</code>, <code>_default</code>, <code>_missing</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Recode a vector, replacing elements in it&lt;/&gt;</li> <li><code>recode_factor</code><code>(</code><code>_x</code>, <code>*args</code>, <code>_default</code>, <code>_missing</code>, <code>_ordered</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Recode a factor, replacing levels in it&lt;/&gt;</li> <li><code>relocate</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_before</code>, <code>_after</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 change column positions&lt;/&gt;</li> <li><code>rename</code><code>(</code><code>_data</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Rename columns&lt;/&gt;</li> <li><code>rename_with</code><code>(</code><code>_data</code>, <code>_fn</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Rename columns with a function&lt;/&gt;</li> <li><code>right_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by</code>, <code>copy</code>, <code>suffix</code>, <code>keep</code>, <code>na_matches</code>, <code>multiple</code>, <code>unmatched</code>, <code>relationship</code><code>)</code> (Any) \u2014 Right join two data frames by matching rows.&lt;/&gt;</li> <li><code>row_number</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the row number of x&lt;/&gt;</li> <li><code>rows_append</code><code>(</code><code>x</code>, <code>y</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Append rows in y to x&lt;/&gt;</li> <li><code>rows_delete</code><code>(</code><code>x</code>, <code>y</code>, <code>by</code>, <code>unmatched</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Delete rows in x that match keys in y&lt;/&gt;</li> <li><code>rows_insert</code><code>(</code><code>x</code>, <code>y</code>, <code>by</code>, <code>conflict</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Insert rows from y into x&lt;/&gt;</li> <li><code>rows_patch</code><code>(</code><code>x</code>, <code>y</code>, <code>by</code>, <code>unmatched</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Patch rows in x with values from y&lt;/&gt;</li> <li><code>rows_update</code><code>(</code><code>x</code>, <code>y</code>, <code>by</code>, <code>unmatched</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Update rows in x with values from y&lt;/&gt;</li> <li><code>rows_upsert</code><code>(</code><code>x</code>, <code>y</code>, <code>by</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Upsert rows in x with values from y&lt;/&gt;</li> <li><code>rowwise</code><code>(</code><code>_data</code>, <code>*cols</code><code>)</code> (Any) \u2014 Create a rowwise frame&lt;/&gt;</li> <li><code>select</code><code>(</code><code>_data</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Select columns from a data frame.&lt;/&gt;</li> <li><code>semi_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by</code>, <code>copy</code>, <code>na_matches</code><code>)</code> (Any) \u2014 Semi join two data frames by matching rows.&lt;/&gt;</li> <li><code>slice_</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_preserve</code><code>)</code> (Any) \u2014 Extract rows by their position&lt;/&gt;</li> <li><code>slice_head</code><code>(</code><code>_data</code>, <code>n</code>, <code>prop</code><code>)</code> (Any) \u2014 Extract the first rows&lt;/&gt;</li> <li><code>slice_max</code><code>(</code><code>_data</code>, <code>order_by</code>, <code>n</code>, <code>prop</code>, <code>with_ties</code><code>)</code> (Any) \u2014 Extract rows with the maximum value&lt;/&gt;</li> <li><code>slice_min</code><code>(</code><code>_data</code>, <code>order_by</code>, <code>n</code>, <code>prop</code>, <code>with_ties</code><code>)</code> (Any) \u2014 Extract rows with the minimum value&lt;/&gt;</li> <li><code>slice_sample</code><code>(</code><code>_data</code>, <code>n</code>, <code>prop</code>, <code>weight_by</code>, <code>replace</code><code>)</code> (Any) \u2014 Extract rows by sampling&lt;/&gt;</li> <li><code>slice_tail</code><code>(</code><code>_data</code>, <code>n</code>, <code>prop</code><code>)</code> (Any) \u2014 Extract the last rows&lt;/&gt;</li> <li><code>starts_with</code><code>(</code><code>_data</code>, <code>match</code>, <code>ignore_case</code>, <code>vars</code><code>)</code> (Any) \u2014 Select columns that start with a string.&lt;/&gt;</li> <li><code>summarise</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_groups</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Summarise a data frame.&lt;/&gt;</li> <li><code>symdiff</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (T) \u2014 Get the symmetric difference of two dataframes&lt;/&gt;</li> <li><code>tally</code><code>(</code><code>_data</code>, <code>wt</code>, <code>sort</code>, <code>name</code><code>)</code> (Any) \u2014 Count the number of rows in each group&lt;/&gt;</li> <li><code>transmute</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_before</code>, <code>_after</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Add new columns to a data frame and remove existing columnsusing mutate with <code>_keep=\"none\"</code>. &lt;/&gt;</li> <li><code>ungroup</code><code>(</code><code>_data</code>, <code>*cols</code><code>)</code> (Any) \u2014 Remove grouping variables&lt;/&gt;</li> <li><code>union_all</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Combine two data frames together.&lt;/&gt;</li> <li><code>where</code><code>(</code><code>_data</code>, <code>fn</code><code>)</code> (Any) \u2014 Selects the variables for which a function returns True.&lt;/&gt;</li> <li><code>with_groups</code><code>(</code><code>_data</code>, <code>_groups</code>, <code>_func</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Modify the grouping variables for a single operation.&lt;/&gt;</li> <li><code>with_order</code><code>(</code><code>order</code>, <code>func</code>, <code>x</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Control argument and result of a window function&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Pick columns by name</p><p>The original API: https://dplyr.tidyverse.org/reference/pick.html</p> Parameters <ul> <li><code>_data</code> (T) \u2014 The dataframe</li> <li><code>*args</code> \u2014 The columns to pick</li> </ul> Returns (T) <p>The picked dataframe</p> function &lt;/&gt; <p>Apply the same transformation to multiple columns</p><p>The original API: https://dplyr.tidyverse.org/reference/across.html</p> Examples Parameters <ul> <li><code>_data</code> (T) \u2014 The dataframe.</li> <li><code>*args</code> \u2014 If given, the first 2 elements should be columns and functionsapply to each of the selected columns. The rest of them will be the arguments for the functions. </li> <li><code>_names</code> (optional) \u2014 A glue specification that describes how to namethe output columns. This can use <code>{_col}</code> to stand for the selected column name, and <code>{_fn}</code> to stand for the name of the function being applied. The default (None) is equivalent to <code>{_col}</code> for the single function case and <code>{_col}_{_fn}</code> for the case where a list is used for _fns. In such a case, <code>{_fn}</code> is 0-based. To use 1-based index, use <code>{_fn1}</code> </li> <li><code>**kwargs</code> \u2014 Keyword arguments for the functions</li> <li><code>_fn_context</code> \u2014 Defines the context to evaluate the arguments for functionsif they are plain functions. Note that registered functions will use its own context </li> </ul> Returns (T) <p>A dataframe with one column for each column and each function.</p> function &lt;/&gt; <p>Apply the same transformation to multiple columns rowwisely</p> Parameters <ul> <li><code>_data</code> (T) \u2014 The dataframe</li> <li><code>_cols</code> (optional) \u2014 The columns</li> </ul> Returns (T) <p>A rowwise tibble</p> function &lt;/&gt; <p>Apply the same predicate function to a selection of columns and combinethe results True if any element is True.</p> See Also <p><code>across()</code></p> function &lt;/&gt; <p>Apply the same predicate function to a selection of columns and combinethe results True if all elements are True.</p> See Also <p><code>across()</code></p> function &lt;/&gt; <p>Get the symmetric difference of two dataframes</p><p>It computes the symmetric difference, i.e. all rows in x that aren't in y and all rows in y that aren't in x.</p> <p>The original API: https://dplyr.tidyverse.org/reference/setops.html</p> Parameters <ul> <li><code>x</code> (T) \u2014 A dataframe</li> <li><code>y</code> (T) \u2014 A dataframe</li> </ul> Returns (T) <p>The symmetric difference of x and y</p> function &lt;/&gt; <p>orders the rows of a data frame by the values of selected columns.</p><p>The original API: https://dplyr.tidyverse.org/reference/arrange.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>_by_group</code> (optional) \u2014 If TRUE, will sort first by grouping variable.Applies to grouped data frames only. </li> <li><code>**kwargs</code> \u2014 Name-value pairs that apply with mutate</li> <li><code>*series</code> \u2014 Variables, or functions of variables.Use desc() to sort a variable in descending order. </li> </ul> Returns (Any) <p>An object of the same type as _data.The output has the following properties:     All rows appear in the output, but (usually) in a different place.     Columns are not modified.     Groups are not modified.     Data frame attributes are preserved.</p> function &lt;/&gt; <p>Bind rows of give dataframes</p><p>Original APIs https://dplyr.tidyverse.org/reference/bind.html</p> Parameters <ul> <li><code>*data</code> \u2014 Dataframes to combine</li> <li><code>_id</code> (optional) \u2014 The name of the id columns</li> <li><code>_copy</code> (bool, optional) \u2014 If <code>False</code>, do not copy data unnecessarily.Original API does not support this. This argument will be passed by to <code>pandas.concat()</code> as <code>copy</code> argument. </li> <li><code>**kwargs</code> \u2014 A mapping of dataframe, keys will be used as _id col.</li> </ul> Returns (Any) <p>The combined dataframe</p> function &lt;/&gt; <p>Bind columns of give dataframes</p><p>Note that unlike <code>dplyr</code>, mismatched dimensions are allowed and missing rows will be filled with <code>NA</code>s</p> Parameters <ul> <li><code>*data</code> \u2014 Dataframes to bind</li> <li><code>_name_repair</code> (optional) \u2014 treatment of problematic column names:<ul><li>- \"minimal\": No name repair or checks, beyond basic existence,</li><li>- \"unique\": Make sure names are unique and not empty,</li><li>- \"check_unique\": (default value), no name repair,\u00a0    but check they are unique,</li><li>- \"universal\": Make the names unique and syntactic</li><li>- a function: apply custom name repair</li></ul></li> <li><code>_copy</code> (bool, optional) \u2014 If <code>False</code>, do not copy data unnecessarily.Original API does not support this. This argument will be passed by to <code>pandas.concat()</code> as <code>copy</code> argument. </li> </ul> Returns (Any) <p>The combined dataframe</p> function &lt;/&gt; <p>Get the current column</p> Parameters <ul> <li><code>_data</code> \u2014 The dataframe</li> <li><code>_name</code> \u2014 The column name</li> </ul> Returns (Any) <p>The current column</p> function &lt;/&gt; <p>Get the current dataframe</p> Parameters <ul> <li><code>_data</code> \u2014 The dataframe</li> </ul> Returns (Any) <p>The current dataframe</p> function &lt;/&gt; <p>Get the current group size</p> Parameters <ul> <li><code>_data</code> \u2014 The dataframe</li> </ul> Returns (Any) <p>The number of rows</p> function &lt;/&gt; <p>Get the current data for the current group includingthe grouping variables</p> Parameters <ul> <li><code>_data</code> \u2014 The dataframe</li> </ul> Returns (Any) <p>The current dataframe</p> function &lt;/&gt; <p>Get the current group</p> Parameters <ul> <li><code>_data</code> \u2014 The dataframe</li> </ul> Returns (Any) <p>The current group</p> function &lt;/&gt; <p>Get the current group id</p> Parameters <ul> <li><code>_data</code> \u2014 The dataframe</li> </ul> Returns (Any) <p>The current group id</p> function &lt;/&gt; <p>Get the current group row indices</p> Parameters <ul> <li><code>_data</code> \u2014 The dataframe</li> </ul> Returns (Any) <p>The current group rows</p> function &lt;/&gt; <p>Count the number of rows in each group</p><p>Original API: https://dplyr.tidyverse.org/reference/count.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>*args</code> \u2014 Variables, or functions of variables.Use desc() to sort a variable in descending order. </li> <li><code>wt</code> (optional) \u2014 A variable or function of variables to weight by.</li> <li><code>sort</code> (optional) \u2014 If TRUE, the result will be sorted by the count.</li> <li><code>name</code> (optional) \u2014 The name of the count column.</li> <li><code>_drop</code> (optional) \u2014 If <code>False</code>, keep grouping variables even if they are not used.Original API does not support this. </li> <li><code>**kwargs</code> \u2014 Name-value pairs that apply with mutate</li> </ul> Returns (Any) <p>A data frame with the same number of rows as the number of groups.The output has the following properties:     All rows appear in the output, but (usually) in a different place.     Columns are not modified.     Groups are not modified.     Data frame attributes are preserved.</p> function &lt;/&gt; <p>Count the number of rows in each group</p><p>Original API: https://dplyr.tidyverse.org/reference/count.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>wt</code> (optional) \u2014 A variable or function of variables to weight by.</li> <li><code>sort</code> (optional) \u2014 If TRUE, the result will be sorted by the count.</li> <li><code>name</code> (optional) \u2014 The name of the count column.</li> </ul> Returns (Any) <p>A data frame with the same number of rows as the number of groups.The output has the following properties:     All rows appear in the output, but (usually) in a different place.     Columns are not modified.     Groups are not modified.     Data frame attributes are preserved.</p> function &lt;/&gt; <p>Add a count column to a data frame</p><p>Original API: https://dplyr.tidyverse.org/reference/count.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>*args</code> \u2014 Variables, or functions of variables.Use desc() to sort a variable in descending order. </li> <li><code>wt</code> (optional) \u2014 A variable or function of variables to weight by.</li> <li><code>sort</code> (optional) \u2014 If TRUE, the result will be sorted by the count.</li> <li><code>name</code> (optional) \u2014 The name of the count column.</li> <li><code>**kwargs</code> \u2014 Name-value pairs that apply with mutate</li> </ul> Returns (Any) <p>A data frame with the same number of rows as the number of groups.The output has the following properties:     All rows appear in the output, but (usually) in a different place.     Columns are not modified.     Groups are not modified.     Data frame attributes are preserved.</p> function &lt;/&gt; <p>Add a count column to a data frame</p><p>Original API: https://dplyr.tidyverse.org/reference/count.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>wt</code> (optional) \u2014 A variable or function of variables to weight by.</li> <li><code>sort</code> (optional) \u2014 If TRUE, the result will be sorted by the count.</li> <li><code>name</code> (optional) \u2014 The name of the count column.</li> </ul> Returns (Any) <p>A data frame with the same number of rows as the number of groups.The output has the following properties:     All rows appear in the output, but (usually) in a different place.     Columns are not modified.     Groups are not modified.     Data frame attributes are preserved.</p> function &lt;/&gt; <p>Transform a vector into a format that will be sorted in descending order</p><p>This is useful within arrange().</p> <p>The original API: https://dplyr.tidyverse.org/reference/desc.html</p> Parameters <ul> <li><code>x</code> \u2014 vector to transform</li> </ul> Returns (Any) <p>The descending order of x</p> function &lt;/&gt; <p>Filter a data frame based on conditions</p><p>The original API: https://dplyr.tidyverse.org/reference/filter.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>*conditions</code> \u2014 Conditions to filter by.</li> <li><code>_preserve</code> (bool, optional) \u2014 If <code>True</code>, keep grouping variables even if they are not used.</li> </ul> Returns (Any) <p>The subset dataframe</p> function &lt;/&gt; <p>Filter a data frame based on conditions</p><p>The original API: https://dplyr.tidyverse.org/reference/distinct.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>*args</code> \u2014 Variables to filter by.</li> <li><code>keep_all</code> (bool, optional) \u2014 If <code>True</code>, keep all rows that match.</li> <li><code>_preserve</code> (bool, optional) \u2014 If <code>True</code>, keep grouping variables even if they are not used.</li> </ul> Returns (Any) <p>The subset dataframe</p> function &lt;/&gt; <p>Count the number of distinct values</p><p>The original API: https://dplyr.tidyverse.org/reference/distinct.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>na_rm</code> (bool, optional) \u2014 If <code>True</code>, remove missing values before counting.</li> </ul> Returns (Any) <p>The number of distinct values</p> function &lt;/&gt; <p>Display a summary of a data frame</p><p>The original API: https://dplyr.tidyverse.org/reference/glimpse.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>width</code> (int, optional) \u2014 Width of output, defaults to the width of the console.</li> <li><code>formatter</code> (optional) \u2014 A single-dispatch function to format a single element.</li> </ul> function &lt;/&gt; <p>Extract rows by their position</p><p>The original API: https://dplyr.tidyverse.org/reference/slice.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>*args</code> \u2014 Positions to extract.</li> <li><code>_preserve</code> (bool, optional) \u2014 If <code>True</code>, keep grouping variables even if they are not used.</li> </ul> Returns (Any) <p>The subset dataframe</p> function &lt;/&gt; <p>Extract the first rows</p><p>The original API: https://dplyr.tidyverse.org/reference/slice.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>n</code> (int, optional) \u2014 Number of rows to extract.</li> <li><code>prop</code> (float, optional) \u2014 Proportion of rows to extract.</li> </ul> Returns (Any) <p>The subset dataframe</p> function &lt;/&gt; <p>Extract the last rows</p><p>The original API: https://dplyr.tidyverse.org/reference/slice.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>n</code> (int, optional) \u2014 Number of rows to extract.</li> <li><code>prop</code> (float, optional) \u2014 Proportion of rows to extract.</li> </ul> Returns (Any) <p>The subset dataframe</p> function &lt;/&gt; <p>Extract rows by sampling</p><p>The original API: https://dplyr.tidyverse.org/reference/slice.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>n</code> (int, optional) \u2014 Number of rows to extract.</li> <li><code>prop</code> (float, optional) \u2014 Proportion of rows to extract.</li> <li><code>weight_by</code> (optional) \u2014 A variable or function of variables to weight by.</li> <li><code>replace</code> (bool, optional) \u2014 If <code>True</code>, sample with replacement.</li> </ul> Returns (Any) <p>The subset dataframe</p> function &lt;/&gt; <p>Extract rows with the minimum value</p><p>The original API: https://dplyr.tidyverse.org/reference/slice.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>order_by</code> \u2014 A variable or function of variables to order by.</li> <li><code>n</code> (int, optional) \u2014 Number of rows to extract.</li> <li><code>prop</code> (float, optional) \u2014 Proportion of rows to extract.</li> <li><code>with_ties</code> (bool | str, optional) \u2014 If <code>True</code>, extract all rows with the minimum value.If \"first\", extract the first row with the minimum value. If \"last\", extract the last row with the minimum value. </li> </ul> Returns (Any) <p>The subset dataframe</p> function &lt;/&gt; <p>Extract rows with the maximum value</p><p>The original API: https://dplyr.tidyverse.org/reference/slice.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>order_by</code> \u2014 A variable or function of variables to order by.</li> <li><code>n</code> (int, optional) \u2014 Number of rows to extract.</li> <li><code>prop</code> (float, optional) \u2014 Proportion of rows to extract.</li> <li><code>with_ties</code> (bool | str, optional) \u2014 If <code>True</code>, extract all rows with the maximum value.If \"first\", extract the first row with the maximum value. If \"last\", extract the last row with the maximum value. </li> </ul> Returns (Any) <p>The subset dataframe</p> function &lt;/&gt; <p>Check if a value is between two other values</p><p>The original API: https://dplyr.tidyverse.org/reference/between.html</p> Parameters <ul> <li><code>x</code> \u2014 A value</li> <li><code>left</code> \u2014 The left bound</li> <li><code>right</code> \u2014 The right bound</li> <li><code>inclusive</code> (str, optional) \u2014 Either <code>both</code>, <code>neither</code>, <code>left</code> or <code>right</code>.Include boundaries. Whether to set each bound as closed or open. </li> </ul> Returns (Any) <p>A bool value if <code>x</code> is scalar, otherwise an array of boolean valuesNote that it will be always False when NA appears in x, left or right.</p> function &lt;/&gt; <p>Cumulative mean</p><p>The original API: https://dplyr.tidyverse.org/reference/cumall.html</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>na_rm</code> (bool, optional) \u2014 If <code>True</code>, remove missing values before computing.</li> </ul> Returns (Any) <p>An array of cumulative means</p> function &lt;/&gt; <p>Get cumulative bool. All cases after first False</p><p>The original API: https://dplyr.tidyverse.org/reference/cumall.html</p> Parameters <ul> <li><code>x</code> \u2014 A logical vector</li> </ul> Returns (Any) <p>An array of cumulative conjunctions</p> function &lt;/&gt; <p>Get cumulative bool. All cases after first True</p><p>The original API: https://dplyr.tidyverse.org/reference/cumany.html</p> Parameters <ul> <li><code>x</code> \u2014 A logical vector</li> </ul> Returns (Any) <p>An array of cumulative disjunctions</p> function &lt;/&gt; <p>Replace missing values with the first non-missing value</p><p>The original API: https://dplyr.tidyverse.org/reference/coalesce.html</p> Parameters <ul> <li><code>x</code> \u2014 A vector</li> <li><code>*replace</code> \u2014 Values to replace missing values with.</li> </ul> Returns (Any) <p>An array of values</p> function &lt;/&gt; <p>Generate consecutive ids</p><p>The original API: https://dplyr.tidyverse.org/reference/consecutive_id.html</p> Parameters <ul> <li><code>x</code> \u2014 A vector</li> <li><code>*args</code> \u2014 Other vectors</li> </ul> Returns (Sequence) <p>A sequence of consecutive ids</p> function &lt;/&gt; <p>Replace values with missing values</p><p>The original API: https://dplyr.tidyverse.org/reference/na_if.html</p> Parameters <ul> <li><code>x</code> \u2014 A vector</li> <li><code>value</code> \u2014 Values to replace with missing values.</li> </ul> Returns (Any) <p>An array of values</p> function &lt;/&gt; <p>Check if values are approximately equal</p><p>The original API: https://dplyr.tidyverse.org/reference/near.html</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector</li> <li><code>y</code> \u2014 A numeric vector</li> <li><code>tol</code> (float, optional) \u2014 Tolerance</li> </ul> Returns (Any) <p>An array of boolean values</p> function &lt;/&gt; <p>Extract the nth element of a vector</p><p>The original API: https://dplyr.tidyverse.org/reference/nth.html</p> Parameters <ul> <li><code>x</code> \u2014 A vector</li> <li><code>n</code> \u2014 The index of the element to extract.</li> <li><code>order_by</code> (optional) \u2014 A variable or function of variables to order by.</li> <li><code>default</code> (optional) \u2014 A default value to return if <code>n</code> is out of bounds.</li> </ul> Returns (Any) <p>A value</p> function &lt;/&gt; <p>Extract the first element of a vector</p><p>The original API: https://dplyr.tidyverse.org/reference/nth.html</p> Parameters <ul> <li><code>x</code> \u2014 A vector</li> <li><code>order_by</code> (optional) \u2014 A variable or function of variables to order by.</li> <li><code>default</code> (optional) \u2014 A default value to return if <code>x</code> is empty.</li> </ul> Returns (Any) <p>A value</p> function &lt;/&gt; <p>Extract the last element of a vector</p><p>The original API: https://dplyr.tidyverse.org/reference/nth.html</p> Parameters <ul> <li><code>x</code> \u2014 A vector</li> <li><code>order_by</code> (optional) \u2014 A variable or function of variables to order by.</li> <li><code>default</code> (optional) \u2014 A default value to return if <code>x</code> is empty.</li> </ul> Returns (Any) <p>A value</p> function &lt;/&gt; <p>Create a grouped frame</p><p>The original API: https://dplyr.tidyverse.org/reference/group_by.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>*args</code> \u2014 A variable or function of variables to group by.</li> <li><code>_add</code> (bool, optional) \u2014 If <code>True</code>, add grouping variables to an existing group.</li> <li><code>_drop</code> (bool, optional) \u2014 If <code>True</code>, drop grouping variables from the output.</li> </ul> Returns (Any) <p>A grouped frame</p> function &lt;/&gt; <p>Remove grouping variables</p><p>The original API: https://dplyr.tidyverse.org/reference/ungroup.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> <li><code>*cols</code> (str | int) \u2014 Columns to remove grouping variables from.</li> </ul> Returns (Any) <p>A data frame</p> function &lt;/&gt; <p>Create a rowwise frame</p><p>The original API: https://dplyr.tidyverse.org/reference/rowwise.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>*cols</code> (str | int) \u2014 Columns to make rowwise.</li> </ul> Returns (Any) <p>A rowwise frame</p> function &lt;/&gt; <p>Get the default value of <code>_drop</code> of a frame</p><p>The original API: https://dplyr.tidyverse.org/reference/group_by.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> </ul> Returns (Any) <p>A bool value</p> function &lt;/&gt; <p>Get the grouping variables of a frame</p><p>The original API: https://dplyr.tidyverse.org/reference/group_vars.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> </ul> Returns (Any) <p>A list of grouping variables</p> function &lt;/&gt; <p>Get the group indices of a frame</p><p>The original API: https://dplyr.tidyverse.org/reference/group_indices.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> </ul> Returns (Any) <p>A list of group indices</p> function &lt;/&gt; <p>Get the group keys of a frame</p><p>The original API: https://dplyr.tidyverse.org/reference/group_keys.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> </ul> Returns (Any) <p>A list of group keys</p> function &lt;/&gt; <p>Get the group sizes of a frame</p><p>The original API: https://dplyr.tidyverse.org/reference/group_size.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> </ul> Returns (Any) <p>A list of group sizes</p> function &lt;/&gt; <p>Get the group rows of a frame</p><p>The original API: https://dplyr.tidyverse.org/reference/group_rows.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> </ul> Returns (Any) <p>A list of group rows</p> function &lt;/&gt; <p>Get the group columns of a frame</p><p>The original API: https://dplyr.tidyverse.org/reference/group_cols.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> </ul> Returns (Any) <p>A list of group columns</p> function &lt;/&gt; <p>Get the group data of a frame</p><p>The original API: https://dplyr.tidyverse.org/reference/group_data.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> </ul> Returns (Any) <p>A list of group data</p> function &lt;/&gt; <p>Get the number of groups of a frame</p><p>The original API: https://dplyr.tidyverse.org/reference/n_groups.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> </ul> Returns (int) <p>An int value</p> function &lt;/&gt; <p>Apply a function to each group</p><p>The original API: https://dplyr.tidyverse.org/reference/group_map.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> <li><code>_f</code> \u2014 A function to apply to each group.</li> <li><code>*args</code> \u2014 Additional arguments to pass to <code>func</code>.</li> <li><code>_keep</code> (bool, optional) \u2014 If <code>True</code>, keep the grouping variables in the output.</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to pass to <code>func</code>.</li> </ul> Returns (Any) <p>A list of results</p> function &lt;/&gt; <p>Apply a function to each group</p><p>The original API: https://dplyr.tidyverse.org/reference/group_modify.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> <li><code>_f</code> \u2014 A function to apply to each group.</li> <li><code>*args</code> \u2014 Additional arguments to pass to <code>func</code>.</li> <li><code>_keep</code> (bool, optional) \u2014 If <code>True</code>, keep the grouping variables in the output.</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to pass to <code>func</code>.</li> </ul> Returns (Any) <p>A data frame</p> function &lt;/&gt; <p>Split a grouped frame into a list of data frames</p><p>The original API: https://dplyr.tidyverse.org/reference/group_split.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> <li><code>*args</code> \u2014 Additional arguments to pass to <code>func</code>.</li> <li><code>_keep</code> (bool, optional) \u2014 If <code>True</code>, keep the grouping variables in the output.</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to pass to <code>func</code>.</li> </ul> Returns (Any) <p>A list of data frames</p> function &lt;/&gt; <p>Remove empty groups</p><p>The original API: https://dplyr.tidyverse.org/reference/group_trim.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> <li><code>_drop</code> (optional) \u2014 See <code>group_by</code>.</li> </ul> Returns (Any) <p>A grouped frame</p> function &lt;/&gt; <p>Apply a function to each group</p><p>The original API: https://dplyr.tidyverse.org/reference/group_walk.html</p> Parameters <ul> <li><code>_data</code> \u2014 A grouped frame</li> <li><code>_f</code> \u2014 A function to apply to each group.</li> <li><code>*args</code> \u2014 Additional arguments to pass to <code>func</code>.</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to pass to <code>func</code>.</li> </ul> Returns (Any) <p>A grouped frame</p> function &lt;/&gt; <p>Modify the grouping variables for a single operation.</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>_groups</code> \u2014 columns passed by group_byUse None to temporarily ungroup. </li> <li><code>_func</code> \u2014 Function to apply to regrouped data.</li> </ul> Returns (Any) <p>The new data frame with operations applied.</p> function &lt;/&gt; <p>Where condition is TRUE, the matching value from true, where it's FALSE,the matching value from false, otherwise missing.</p> <p>Note that NAs will be False in condition if missing is not specified</p> Parameters <ul> <li><code>condition</code> \u2014 the conditions</li> <li><code>true</code> \u2014 and</li> <li><code>false</code> \u2014 Values to use for TRUE and FALSE values of condition.They must be either the same length as condition, or length 1. </li> <li><code>missing</code> (optional) \u2014 If not None, will be used to replace missing values</li> </ul> Returns (Any) <p>A series with values replaced.</p> function &lt;/&gt; <p>This function allows you to vectorise multiple <code>switch()</code> statements.Each case is evaluated sequentially and the first match for each element determines the corresponding value in the output vector. If no cases match, the <code>_default</code> is used.</p> <p>The original API: https://dplyr.tidyverse.org/reference/case_match.html</p> Parameters <ul> <li><code>_x</code> (T) \u2014 A vector</li> <li><code>*args</code> \u2014 A series of condition-value pairs</li> <li><code>_default</code> (optional) \u2014 The default value</li> <li><code>_dtypes</code> (optional) \u2014 The data types of the output</li> </ul> function &lt;/&gt; <p>Vectorise multiple <code>if_else()</code> statements.</p> Parameters <ul> <li><code>cond</code> \u2014 A boolean vector</li> <li><code>value</code> \u2014 A vector with values to replace</li> <li><code>*more_cases</code> \u2014 A list of tuples (cond, value)</li> </ul> Returns (Any) <p>A vector with values replaced.</p> function &lt;/&gt; <p>Inner join two data frames by matching rows.</p><p>The original API: https://dplyr.tidyverse.org/reference/join.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>by</code> (optional) \u2014 A list of column names to join by.If None, use the intersection of the columns of x and y. </li> <li><code>copy</code> (bool, optional) \u2014 If True, always copy the data.</li> <li><code>suffix</code> (Sequence, optional) \u2014 A tuple of suffixes to apply to overlapping columns.</li> <li><code>keep</code> (bool, optional) \u2014 If True, keep the grouping variables in the output.</li> <li><code>na_matches</code> (str, optional) \u2014 How should NA values be matched?\"na\": NA values are equal. \"never\": NA values are never matched. </li> <li><code>multiple</code> (str, optional) \u2014 How should multiple matches be handled?\"all\": All matches are returned. \"first\": The first match is returned. \"last\": The last match is returned. \"any\": Any of the matched rows in y </li> <li><code>unmatched</code> (str, optional) \u2014 How should unmatched keys that would result in dropped rowsbe handled? \"drop\": Drop unmatched keys. \"error\": Raise an error. </li> <li><code>relationship</code> (str, optional) \u2014 The relationship between x and y.None: No expected relationship. \"one_to_one\": Each row in x matches at most one row in y. \"one_to_many\": Each row in x matches zero or more rows in y. \"many_to_one\": Each row in x matches at most one row in y. \"many_to_many\": Each row in x matches zero or more rows in y. </li> </ul> Returns (Any) <p>A data frame</p> function &lt;/&gt; <p>Left join two data frames by matching rows.</p><p>The original API: https://dplyr.tidyverse.org/reference/join.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>by</code> (optional) \u2014 A list of column names to join by.If None, use the intersection of the columns of x and y. </li> <li><code>copy</code> (bool, optional) \u2014 If True, always copy the data.</li> <li><code>suffix</code> (Sequence, optional) \u2014 A tuple of suffixes to apply to overlapping columns.</li> <li><code>keep</code> (bool, optional) \u2014 If True, keep the grouping variables in the output.</li> <li><code>na_matches</code> (str, optional) \u2014 How should NA values be matched?\"na\": NA values are equal. \"never\": NA values are never matched. </li> <li><code>multiple</code> (str, optional) \u2014 How should multiple matches be handled?\"all\": All matches are returned. \"first\": The first match is returned. \"last\": The last match is returned. \"any\": Any of the matched rows in y </li> <li><code>unmatched</code> (str, optional) \u2014 How should unmatched keys that would result in dropped rowsbe handled? \"drop\": Drop unmatched keys. \"error\": Raise an error. </li> <li><code>relationship</code> (str, optional) \u2014 The relationship between x and y.None: No expected relationship. \"one_to_one\": Each row in x matches at most one row in y. \"one_to_many\": Each row in x matches zero or more rows in y. \"many_to_one\": Each row in x matches at most one row in y. \"many_to_many\": Each row in x matches zero or more rows in y. </li> </ul> Returns (Any) <p>A data frame</p> function &lt;/&gt; <p>Right join two data frames by matching rows.</p><p>The original API: https://dplyr.tidyverse.org/reference/join.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>by</code> (optional) \u2014 A list of column names to join by.If None, use the intersection of the columns of x and y. </li> <li><code>copy</code> (bool, optional) \u2014 If True, always copy the data.</li> <li><code>suffix</code> (Sequence, optional) \u2014 A tuple of suffixes to apply to overlapping columns.</li> <li><code>keep</code> (bool, optional) \u2014 If True, keep the grouping variables in the output.</li> <li><code>na_matches</code> (str, optional) \u2014 How should NA values be matched?\"na\": NA values are equal. \"never\": NA values are never matched. </li> <li><code>multiple</code> (str, optional) \u2014 How should multiple matches be handled?\"all\": All matches are returned. \"first\": The first match is returned. \"last\": The last match is returned. \"any\": Any of the matched rows in y </li> <li><code>unmatched</code> (str, optional) \u2014 How should unmatched keys that would result in dropped rowsbe handled? \"drop\": Drop unmatched keys. \"error\": Raise an error. </li> <li><code>relationship</code> (str, optional) \u2014 The relationship between x and y.None: No expected relationship. \"one_to_one\": Each row in x matches at most one row in y. \"one_to_many\": Each row in x matches zero or more rows in y. \"many_to_one\": Each row in x matches at most one row in y. \"many_to_many\": Each row in x matches zero or more rows in y. </li> </ul> Returns (Any) <p>A data frame</p> function &lt;/&gt; <p>Full join two data frames by matching rows.</p><p>The original API: https://dplyr.tidyverse.org/reference/join.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>by</code> (optional) \u2014 A list of column names to join by.If None, use the intersection of the columns of x and y. </li> <li><code>copy</code> (bool, optional) \u2014 If True, always copy the data.</li> <li><code>suffix</code> (Sequence, optional) \u2014 A tuple of suffixes to apply to overlapping columns.</li> <li><code>keep</code> (bool, optional) \u2014 If True, keep the grouping variables in the output.</li> <li><code>na_matches</code> (str, optional) \u2014 How should NA values be matched?\"na\": NA values are equal. \"never\": NA values are never matched. </li> <li><code>multiple</code> (str, optional) \u2014 How should multiple matches be handled?\"all\": All matches are returned. \"first\": The first match is returned. \"last\": The last match is returned. \"any\": Any of the matched rows in y </li> <li><code>unmatched</code> (str, optional) \u2014 How should unmatched keys that would result in dropped rowsbe handled? \"drop\": Drop unmatched keys. \"error\": Raise an error. </li> <li><code>relationship</code> (str, optional) \u2014 The relationship between x and y.None: No expected relationship. \"one_to_one\": Each row in x matches at most one row in y. \"one_to_many\": Each row in x matches zero or more rows in y. \"many_to_one\": Each row in x matches at most one row in y. \"many_to_many\": Each row in x matches zero or more rows in y. </li> </ul> Returns (Any) <p>A data frame</p> function &lt;/&gt; <p>Semi join two data frames by matching rows.</p><p>The original API: https://dplyr.tidyverse.org/reference/join.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>by</code> (optional) \u2014 A list of column names to join by.If None, use the intersection of the columns of x and y. </li> <li><code>copy</code> (bool, optional) \u2014 If True, always copy the data.</li> <li><code>na_matches</code> (str, optional) \u2014 How should NA values be matched?\"na\": NA values are equal. \"never\": NA values are never matched. </li> </ul> Returns (Any) <p>A data frame</p> function &lt;/&gt; <p>Anti join two data frames by matching rows.</p><p>The original API: https://dplyr.tidyverse.org/reference/join.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>by</code> (optional) \u2014 A list of column names to join by.If None, use the intersection of the columns of x and y. </li> <li><code>copy</code> (bool, optional) \u2014 If True, always copy the data.</li> <li><code>na_matches</code> (str, optional) \u2014 How should NA values be matched?\"na\": NA values are equal. \"never\": NA values are never matched. </li> </ul> Returns (Any) <p>A data frame</p> function &lt;/&gt; <p>Nest join two data frames by matching rows.</p><p>The original API: https://dplyr.tidyverse.org/reference/join.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>by</code> (optional) \u2014 A list of column names to join by.If None, use the intersection of the columns of x and y. </li> <li><code>copy</code> (bool, optional) \u2014 If True, always copy the data.</li> <li><code>keep</code> (bool, optional) \u2014 If True, keep the grouping variables in the output.</li> <li><code>name</code> (optional) \u2014 The name of the column to store the nested data frame.</li> <li><code>na_matches</code> (str, optional) \u2014 How should NA values be matched?\"na\": NA values are equal. \"never\": NA values are never matched. </li> <li><code>unmatched</code> (str, optional) \u2014 How should unmatched keys that would result in dropped rowsbe handled? \"drop\": Drop unmatched keys. \"error\": Raise an error. </li> </ul> Returns (Any) <p>A data frame</p> function &lt;/&gt; <p>Cross joins match each row in x to every row in y, resulting in adata frame with nrow(x) * nrow(y) rows.</p> <p>The original API: https://dplyr.tidyverse.org/reference/cross_join.html</p> Parameters <ul> <li><code>x</code> (T) \u2014 A data frame</li> <li><code>y</code> (T) \u2014 A data frame</li> <li><code>copy</code> (bool, optional) \u2014 If True, always copy the data.</li> <li><code>suffix</code> (Sequence, optional) \u2014 A tuple of suffixes to apply to overlapping columns.</li> </ul> Returns (T) <p>An object of the same type as x (including the same groups).</p> function &lt;/&gt; <p>Shift a vector by <code>n</code> positions.</p><p>The original API: https://dplyr.tidyverse.org/reference/lead.html</p> Parameters <ul> <li><code>x</code> \u2014 A vector</li> <li><code>n</code> (optional) \u2014 The number of positions to shift.</li> <li><code>default</code> (optional) \u2014 The default value to use for positions that don't exist.</li> <li><code>order_by</code> (optional) \u2014 A vector of column names to order by.</li> </ul> Returns (Any) <p>A vector</p> function &lt;/&gt; <p>Shift a vector by <code>n</code> positions.</p><p>The original API: https://dplyr.tidyverse.org/reference/lag.html</p> Parameters <ul> <li><code>x</code> \u2014 A vector</li> <li><code>n</code> (optional) \u2014 The number of positions to shift.</li> <li><code>default</code> (optional) \u2014 The default value to use for positions that don't exist.</li> <li><code>order_by</code> (optional) \u2014 A vector of column names to order by.</li> </ul> Returns (Any) <p>A vector</p> function &lt;/&gt; <p>Add new columns to a data frame.</p><p>The original API: https://dplyr.tidyverse.org/reference/mutate.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>*args</code> \u2014 and</li> <li><code>_keep</code> (str, optional) \u2014 allows you to control which columns from _data are retainedin the output: <ul><li>- \"all\", the default, retains all variables.</li><li>- \"used\" keeps any variables used to make new variables;\u00a0  it's useful for checking your work as it displays inputs and\u00a0  outputs side-by-side.</li><li>- \"unused\" keeps only existing variables not used to make new\u00a0    variables.</li><li>- \"none\", only keeps grouping keys (like transmute()).</li></ul></li> <li><code>_before</code> (optional) \u2014 A list of column names to put the new columns before.</li> <li><code>_after</code> (optional) \u2014 A list of column names to put the new columns after.</li> <li><code>**kwargs</code> \u2014 Name-value pairs. The name gives the name of the columnin the output. The value can be: <ul><li>- A vector of length 1, which will be recycled to the correct\u00a0    length.</li><li>- A vector the same length as the current group (or the whole\u00a0    data frame if ungrouped).</li><li>- None to remove the column</li></ul></li> </ul> Returns (Any) <p>An object of the same type as _data. The output has the followingproperties: <ul><li>- Rows are not affected.</li><li>- Existing columns will be preserved according to the _keep\u00a0    argument. New columns will be placed according to the\u00a0    _before and _after arguments. If _keep = \"none\"\u00a0    (as in transmute()), the output order is determined only\u00a0    by ..., not the order of existing columns.</li><li>- Columns given value None will be removed</li><li>- Groups will be recomputed if a grouping variable is mutated.</li><li>- Data frame attributes are preserved.</li></ul> function &lt;/&gt; <p>Add new columns to a data frame and remove existing columnsusing mutate with <code>_keep=\"none\"</code>.</p> <p>The original API: https://dplyr.tidyverse.org/reference/mutate.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>*args</code> \u2014 and</li> <li><code>_before</code> (optional) \u2014 A list of column names to put the new columns before.</li> <li><code>_after</code> (optional) \u2014 A list of column names to put the new columns after.</li> <li><code>**kwargs</code> \u2014 Name-value pairs. The name gives the name of the columnin the output. The value can be: <ul><li>- A vector of length 1, which will be recycled to the correct\u00a0    length.</li><li>- A vector the same length as the current group (or the whole\u00a0    data frame if ungrouped).</li><li>- None to remove the column</li></ul></li> </ul> Returns (Any) <p>An object of the same type as _data. The output has the followingproperties: <ul><li>- Rows are not affected.</li><li>- Existing columns will be preserved according to the _keep\u00a0    argument. New columns will be placed according to the\u00a0    _before and _after arguments. If _keep = \"none\"\u00a0    (as in transmute()), the output order is determined only\u00a0    by ..., not the order of existing columns.</li><li>- Columns given value None will be removed</li><li>- Groups will be recomputed if a grouping variable is mutated.</li><li>- Data frame attributes are preserved.</li></ul> function &lt;/&gt; <p>Order the data by the given order</p> <p>Note</p> <p>This function should be called as an argument of a verb. If you want to call it regularly, try <code>with_order()</code></p> Examples <pre><code>&gt;&gt;&gt; df = tibble(x=c[1:6])&gt;&gt;&gt; df &gt;&gt; mutate(y=order_by(c[5:], cumsum(f.x)))\n&gt;&gt;&gt; # df.y:\n&gt;&gt;&gt; # 15, 14, 12, 9, 5\n</code></pre> Parameters <ul> <li><code>order</code> \u2014 An iterable to control the data order</li> <li><code>data</code> \u2014 The data to be ordered</li> </ul> Returns (Any) <p>A Function expression for verb to evaluate.</p> function &lt;/&gt; <p>Control argument and result of a window function</p> Examples <pre><code>&gt;&gt;&gt; with_order([5,4,3,2,1], cumsum, [1,2,3,4,5])&gt;&gt;&gt; # 15, 14, 12, 9, 5\n</code></pre> Parameters <ul> <li><code>order</code> \u2014 An iterable to order the arugment and result</li> <li><code>func</code> \u2014 The window function</li> <li><code>x</code> \u2014 The first arugment for the function</li> <li><code>*args</code> \u2014 and</li> <li><code>**kwargs</code> \u2014 Other arugments for the function</li> </ul> Returns (Any) <p>The ordered result or an expression if there is expression in arguments</p> function &lt;/&gt; <p>Pull a series or a dataframe from a dataframe</p> Parameters <ul> <li><code>_data</code> \u2014 The dataframe</li> <li><code>var</code> (str | int, optional) \u2014 The column to pull, either the name or the index</li> <li><code>name</code> (optional) \u2014 The name of the pulled value<ul><li>- If <code>to</code> is frame, or the value pulled is data frame, it will be\u00a0  the column names</li><li>- If <code>to</code> is series, it will be the series name. If multiple names\u00a0  are given, only the first name will be used.</li><li>- If <code>to</code> is series, but value pulled is a data frame, then a\u00a0  dictionary of series with the series names as keys or given <code>name</code>\u00a0  as keys.</li></ul></li> <li><code>to</code> (optional) \u2014 Type of data to return.Only works when pulling <code>a</code> for name <code>a$b</code> <ul><li>- series: Return a pandas Series object\u00a0  Group information will be lost\u00a0  If pulled value is a dataframe, it will return a dict of series,\u00a0  with the series names or the <code>name</code> provided.</li><li>- array: Return a numpy.ndarray object</li><li>- frame: Return a DataFrame with that column</li><li>- list: Return a python list</li><li>- dict: Return a dict with <code>name</code> as keys and pulled value as values\u00a0  Only a single column is allowed to pull</li><li>- If not provided: <code>series</code> when pulled data has only one columns. <code>dict</code> if <code>name</code> provided and has the same length as the pulled\u00a0    single column. Otherwise <code>frame</code>.</li></ul></li> </ul> Returns (Any) <p>The data according to <code>to</code></p> function &lt;/&gt; <p>Get the row number of x</p><p>Note that this function doesn't support piping.</p> Parameters <ul> <li><code>x</code> \u2014 The data to get row numberDefaults to <code>Symbolic()</code> so the whole data is used by default when called <code>row_number()</code> </li> </ul> Returns (Any) <p>The row number</p> function &lt;/&gt; <p>a rough rank, which breaks the input vector into n buckets.The size of the buckets may differ by up to one, larger buckets have lower rank.</p> <p>Note that this function doesn't support piping.</p> Parameters <ul> <li><code>x</code> \u2014 The data to get  rownumberDefaults to <code>Symbolic()</code> so the whole data is used by default when called <code>ntile(n=...)</code> </li> <li><code>n</code> (int, optional) \u2014 The number of groups to divide the data into</li> </ul> Returns (Any) <p>The row number</p> function &lt;/&gt; <p>Get the min rank of x</p><p>Note that this function doesn't support piping.</p> Parameters <ul> <li><code>x</code> \u2014 The data to get row numberDefaults to <code>Symbolic()</code> so the whole data is used by default when called <code>min_rank()</code> </li> <li><code>na_last</code> (str, optional) \u2014 How NA values are ranked<ul><li>- \"keep\": NA values are ranked at the end</li><li>- \"top\": NA values are ranked at the top</li><li>- \"bottom\": NA values are ranked at the bottom</li></ul></li> </ul> Returns (Any) <p>The row number</p> function &lt;/&gt; <p>Get the dense rank of x</p><p>Note that this function doesn't support piping.</p> Parameters <ul> <li><code>x</code> \u2014 The data to get row numberDefaults to <code>Symbolic()</code> so the whole data is used by default when called <code>dense_rank()</code> </li> <li><code>na_last</code> (str, optional) \u2014 How NA values are ranked<ul><li>- \"keep\": NA values are ranked at the end</li><li>- \"top\": NA values are ranked at the top</li><li>- \"bottom\": NA values are ranked at the bottom</li></ul></li> </ul> Returns (Any) <p>The row number</p> function &lt;/&gt; <p>Get the percent rank of x</p><p>Note that this function doesn't support piping.</p> Parameters <ul> <li><code>x</code> \u2014 The data to get row numberDefaults to <code>Symbolic()</code> so the whole data is used by default when called <code>percent_rank()</code> </li> <li><code>na_last</code> (str, optional) \u2014 How NA values are ranked<ul><li>- \"keep\": NA values are ranked at the end</li><li>- \"top\": NA values are ranked at the top</li><li>- \"bottom\": NA values are ranked at the bottom</li></ul></li> </ul> Returns (Any) <p>The row number</p> function &lt;/&gt; <p>Get the cume_dist of x</p><p>Note that this function doesn't support piping.</p> Parameters <ul> <li><code>x</code> \u2014 The data to get row numberDefaults to <code>Symbolic()</code> so the whole data is used by default when called <code>cume_dist()</code> </li> <li><code>na_last</code> (str, optional) \u2014 How NA values are ranked<ul><li>- \"keep\": NA values are ranked at the end</li><li>- \"top\": NA values are ranked at the top</li><li>- \"bottom\": NA values are ranked at the bottom</li></ul></li> </ul> Returns (Any) <p>The row number</p> function &lt;/&gt; <p>Recode a vector, replacing elements in it</p> Parameters <ul> <li><code>*args</code> \u2014 and</li> <li><code>_default</code> (optional) \u2014 If supplied, all values not otherwise matched will begiven this value. If not supplied and if the replacements are the same type as the original values in series, unmatched values are not changed. If not supplied and if the replacements are not compatible, unmatched values are replaced with np.nan. </li> <li><code>_missing</code> (optional) \u2014 If supplied, any missing values in .x will be replacedby this value. </li> <li><code>**kwargs</code> \u2014 replacements</li> <li><code>x</code> \u2014 A vector to modify</li> </ul> Returns (Any) <p>The vector with values replaced</p> function &lt;/&gt; <p>Recode a factor, replacing levels in it</p> Parameters <ul> <li><code>*args</code> \u2014 and</li> <li><code>_default</code> (optional) \u2014 If supplied, all values not otherwise matched will begiven this value. If not supplied and if the replacements are the same type as the original values in series, unmatched values are not changed. If not supplied and if the replacements are not compatible, unmatched values are replaced with np.nan. </li> <li><code>_missing</code> (optional) \u2014 If supplied, any missing values in .x will be replacedby this value. </li> <li><code>_ordered</code> (bool, optional) \u2014 If True, the factor will be ordered</li> <li><code>**kwargs</code> \u2014 replacements</li> <li><code>x</code> \u2014 A factor to modify</li> </ul> Returns (Any) <p>The factor with levels replaced</p> function &lt;/&gt; <p>change column positions</p><p>See original API https://dplyr.tidyverse.org/reference/relocate.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>*args</code> \u2014 and</li> <li><code>_before</code> (int | str, optional) \u2014 and</li> <li><code>_after</code> (int | str, optional) \u2014 Destination. Supplying neither will move columns tothe left-hand side; specifying both is an error. </li> <li><code>**kwargs</code> \u2014 Columns to rename and move</li> </ul> Returns (Any) <p>An object of the same type as .data. The output has the followingproperties: <ul><li>- Rows are not affected.</li><li>- The same columns appear in the output, but (usually) in a\u00a0    different place.</li><li>- Data frame attributes are preserved.</li><li>- Groups are not affected</li></ul> function &lt;/&gt; <p>Rename columns</p><p>See original API https://dplyr.tidyverse.org/reference/rename.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>**kwargs</code> \u2014 Columns to rename</li> </ul> Returns (Any) <p>The dataframe with new names</p> function &lt;/&gt; <p>Rename columns with a function</p><p>See original API https://dplyr.tidyverse.org/reference/rename.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>_fn</code> \u2014 A function to apply to column names</li> <li><code>*args</code> \u2014 the columns to rename and non-keyword arguments for the <code>_fn</code>.If <code>*args</code> is not provided, then assuming all columns, and no non-keyword arguments are allowed to pass to the function, use keyword arguments instead. </li> <li><code>**kwargs</code> \u2014 keyword arguments for <code>_fn</code></li> </ul> Returns (Any) <p>The dataframe with new names</p> function &lt;/&gt; <p>Insert rows from y into x</p><p>See original API https://dplyr.tidyverse.org/reference/rows.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>by</code> (optional) \u2014 An unnamed character vector giving the key columns.The key columns must exist in both x and y. Keys typically uniquely identify each row, but this is only enforced for the key values of y By default, we use the first column in y, since the first column is a reasonable place to put an identifier variable. </li> <li><code>conflict</code> (str, optional) \u2014 How to handle conflicts<ul><li>- \"error\": Throw an error</li><li>- \"ignore\": Ignore conflicts</li></ul></li> <li><code>**kwargs</code> \u2014 Additional arguments to pass to the backend, such as<code>copy</code> and <code>in_place</code>. Depends on the backend implementation. </li> </ul> Returns (Any) <p>A data frame with all existing rows and potentially new rows</p> function &lt;/&gt; <p>Update rows in x with values from y</p><p>See original API https://dplyr.tidyverse.org/reference/rows.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>by</code> (optional) \u2014 An unnamed character vector giving the key columns.The key columns must exist in both x and y. Keys typically uniquely identify each row, but this is only enforced for the key values of y By default, we use the first column in y, since the first column is a reasonable place to put an identifier variable. </li> <li><code>unmatched</code> (str, optional) \u2014 how should keys in y that are unmatched by the keysin x be handled? One of - \"error\", the default, will error if there are any keys in y that are unmatched by the keys in x. \"ignore\" will ignore rows in y with keys that are unmatched by the keys in x. </li> <li><code>**kwargs</code> \u2014 Additional arguments to pass to the backend, such as<code>copy</code> and <code>in_place</code>. Depends on the backend implementation. </li> </ul> Returns (Any) <p>A data frame with all existing rows and potentially new rows</p> function &lt;/&gt; <p>Patch rows in x with values from y</p><p>See original API https://dplyr.tidyverse.org/reference/rows.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>by</code> (optional) \u2014 An unnamed character vector giving the key columns.The key columns must exist in both x and y. Keys typically uniquely identify each row, but this is only enforced for the key values of y By default, we use the first column in y, since the first column is a reasonable place to put an identifier variable. </li> <li><code>unmatched</code> (str, optional) \u2014 how should keys in y that are unmatched by the keysin x be handled? One of - \"error\", the default, will error if there are any keys in y that are unmatched by the keys in x. \"ignore\" will ignore rows in y with keys that are unmatched by the keys in x. </li> <li><code>**kwargs</code> \u2014 Additional arguments to pass to the backend, such as<code>copy</code> and <code>in_place</code>. Depends on the backend implementation. </li> </ul> Returns (Any) <p>A data frame with NA values overwritten and the number of rows preserved</p> function &lt;/&gt; <p>Upsert rows in x with values from y</p><p>See original API https://dplyr.tidyverse.org/reference/rows.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>by</code> (optional) \u2014 An unnamed character vector giving the key columns.The key columns must exist in both x and y. Keys typically uniquely identify each row, but this is only enforced for the key values of y By default, we use the first column in y, since the first column is a reasonable place to put an identifier variable. </li> <li><code>**kwargs</code> \u2014 Additional arguments to pass to the backend, such as<code>copy</code> and <code>in_place</code>. Depends on the backend implementation. </li> </ul> Returns (Any) <p>A data frame with inserted or updated depending on whether or notthe key value in y already exists in x. Key values in y must be unique.</p> function &lt;/&gt; <p>Delete rows in x that match keys in y</p><p>See original API https://dplyr.tidyverse.org/reference/rows.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>by</code> (optional) \u2014 An unnamed character vector giving the key columns.The key columns must exist in both x and y. Keys typically uniquely identify each row, but this is only enforced for the key values of y By default, we use the first column in y, since the first column is a reasonable place to put an identifier variable. </li> <li><code>unmatched</code> (str, optional) \u2014 how should keys in y that are unmatched by the keysin x be handled? One of - \"error\", the default, will error if there are any keys in y that are unmatched by the keys in x. \"ignore\" will ignore rows in y with keys that are unmatched by the keys in x. </li> <li><code>**kwargs</code> \u2014 Additional arguments to pass to the backend, such as<code>copy</code> and <code>in_place</code>. Depends on the backend implementation. </li> </ul> Returns (Any) <p>A data frame with rows deleted</p> function &lt;/&gt; <p>Append rows in y to x</p><p>See original API https://dplyr.tidyverse.org/reference/rows.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> <li><code>**kwargs</code> \u2014 Additional arguments to pass to the backend, such as<code>copy</code> and <code>in_place</code>. Depends on the backend implementation. </li> </ul> Returns (Any) <p>A data frame with rows appended</p> function &lt;/&gt; <p>Select columns from a data frame.</p><p>See original API https://dplyr.tidyverse.org/reference/select.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>*args</code> \u2014 A list of columns to select</li> <li><code>**kwargs</code> \u2014 A list of columns to select</li> </ul> Returns (Any) <p>A data frame with only the selected columns</p> function &lt;/&gt; <p>Combine two data frames together.</p><p>See original API https://dplyr.tidyverse.org/reference/setops.html</p> Parameters <ul> <li><code>x</code> \u2014 A data frame</li> <li><code>y</code> \u2014 A data frame</li> </ul> Returns (Any) <p>A data frame with rows from x and y</p> function &lt;/&gt; <p>Summarise a data frame.</p><p>See original API https://dplyr.tidyverse.org/reference/summarise.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>*args</code> \u2014 and</li> <li><code>_groups</code> (str, optional) \u2014 Grouping structure of the result.<ul><li>- \"drop_last\": dropping the last level of grouping.</li><li>- \"drop\": All levels of grouping are dropped.</li><li>- \"keep\": Same grouping structure as _data.</li><li>- \"rowwise\": Each row is its own group.</li></ul></li> <li><code>**kwargs</code> \u2014 Name-value pairs, where value is the summarizeddata for each group </li> </ul> Returns (Any) <p>A data frame with the summarised columns</p> function &lt;/&gt; <p>Selects the variables for which a function returns True.</p><p>See original API https://dplyr.tidyverse.org/reference/filter.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>fn</code> (Callable) \u2014 A function that returns True or False.Currently it has to be `register_func/func_factory registered function purrr-like formula not supported yet. </li> </ul> Returns (Any) <p>The matched columns</p> function &lt;/&gt; <p>Select all variables.</p><p>See original API https://dplyr.tidyverse.org/reference/select.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> </ul> Returns (Any) <p>All columns</p> function &lt;/&gt; <p>Select the last column.</p><p>See original API https://dplyr.tidyverse.org/reference/select.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>offset</code> (int, optional) \u2014 The offset of the last column</li> <li><code>vars</code> (optional) \u2014 A list of columns to select</li> </ul> Returns (Any) <p>The last column</p> function &lt;/&gt; <p>Select columns that start with a string.</p><p>See original API https://dplyr.tidyverse.org/reference/select.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>match</code> \u2014 The string to match</li> <li><code>ignore_case</code> (bool, optional) \u2014 Ignore case when matching</li> <li><code>vars</code> (optional) \u2014 A list of columns to select</li> </ul> Returns (Any) <p>The matched columns</p> function &lt;/&gt; <p>Select columns that end with a string.</p><p>See original API https://dplyr.tidyverse.org/reference/select.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>match</code> \u2014 The string to match</li> <li><code>ignore_case</code> (bool, optional) \u2014 Ignore case when matching</li> <li><code>vars</code> (optional) \u2014 A list of columns to select</li> </ul> Returns (Any) <p>The matched columns</p> function &lt;/&gt; <p>Select columns that contain a string.</p><p>See original API https://dplyr.tidyverse.org/reference/select.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>match</code> \u2014 The string to match</li> <li><code>ignore_case</code> (bool, optional) \u2014 Ignore case when matching</li> <li><code>vars</code> (optional) \u2014 A list of columns to select</li> </ul> Returns (Any) <p>The matched columns</p> function &lt;/&gt; <p>Select columns that match a regular expression.</p><p>See original API https://dplyr.tidyverse.org/reference/select.html</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>match</code> \u2014 The regular expression to match</li> <li><code>ignore_case</code> (bool, optional) \u2014 Ignore case when matching</li> <li><code>vars</code> (optional) \u2014 A list of columns to select</li> </ul> Returns (Any) <p>The matched columns</p> function &lt;/&gt; <p>Matches a numerical range like x01, x02, x03.</p> Parameters <ul> <li><code>prefix</code> (str) \u2014 A prefix that starts the numeric range.</li> <li><code>range_</code> \u2014 A sequence of integers, like <code>range(3)</code> (produces <code>0,1,2</code>).</li> <li><code>width</code> (int, optional) \u2014 Optionally, the \"width\" of the numeric range.For example, a range of 2 gives \"01\", a range of three \"001\", etc. </li> <li><code>_data</code> \u2014 The data piped in</li> </ul> Returns (Any) <p>A list of ranges with prefix.</p> function &lt;/&gt; <p>For strict selection.</p><p>If any of the variables in the character vector is missing, an error is thrown.</p> Parameters <ul> <li><code>_data</code> \u2014 The data piped in</li> <li><code>x</code> \u2014 A set of variables to match the columns</li> </ul> Returns (Any) <p>The matched column names</p> Raises <ul> <li><code>ColumnNotExistingError</code> \u2014 When any of the elements in <code>x</code> does not existin <code>_data</code> columns </li> </ul> function &lt;/&gt; <p>For strict selection.</p><p>If any of the variables in the character vector is missing, an error is thrown.</p> Parameters <ul> <li><code>_data</code> \u2014 The data piped in</li> <li><code>x</code> \u2014 A set of variables to match the columns</li> <li><code>vars</code> (optional) \u2014 A list of columns to select</li> </ul> Returns (Any) <p>The matched column names</p> Raises <ul> <li><code>ColumnNotExistingError</code> \u2014 When any of the elements in <code>x</code> does not existin <code>_data</code> columns </li> </ul>"},{"location":"api/datar.apis.dplyr/#datarapisdplyr","title":"datar.apis.dplyr","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrpick","title":"<code>datar.apis.dplyr.</code><code>pick</code><code>(</code><code>_data</code>, <code>*args</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyracross","title":"<code>datar.apis.dplyr.</code><code>across</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_names=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#_1","title":"datar.apis.dplyr","text":"<pre><code>&gt;&gt;&gt; iris &gt;&gt; mutate(across(c(f.Sepal_Length, f.Sepal_Width), round))\n    Sepal_Length  Sepal_Width  Petal_Length  Petal_Width    Species\n       &lt;float64&gt;    &lt;float64&gt;     &lt;float64&gt;    &lt;float64&gt;   &lt;object&gt;\n0            5.0          4.0           1.4          0.2     setosa\n1            5.0          3.0           1.4          0.2     setosa\n..           ...          ...           ...          ...        ...\n</code></pre> <pre><code>&gt;&gt;&gt; iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(\n&gt;&gt;&gt;     across(starts_with(\"Sepal\"), mean)\n&gt;&gt;&gt; )\n      Species  Sepal_Length  Sepal_Width\n     &lt;object&gt;     &lt;float64&gt;    &lt;float64&gt;\n0      setosa         5.006        3.428\n1  versicolor         5.936        2.770\n2   virginica         6.588        2.974\n</code></pre>"},{"location":"api/datar.apis.dplyr/#datarapisdplyrc_across","title":"<code>datar.apis.dplyr.</code><code>c_across</code><code>(</code><code>_data</code>, <code>_cols=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrif_any","title":"<code>datar.apis.dplyr.</code><code>if_any</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_names=None</code>, <code>**kwargs</code><code>)</code> \u2192 Any","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrif_all","title":"<code>datar.apis.dplyr.</code><code>if_all</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_names=None</code>, <code>**kwargs</code><code>)</code> \u2192 Any","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrsymdiff","title":"<code>datar.apis.dplyr.</code><code>symdiff</code><code>(</code><code>x</code>, <code>y</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrarrange","title":"<code>datar.apis.dplyr.</code><code>arrange</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_by_group=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrbind_rows","title":"<code>datar.apis.dplyr.</code><code>bind_rows</code><code>(</code><code>*data</code>, <code>_id=None</code>, <code>_copy=True</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrbind_cols","title":"<code>datar.apis.dplyr.</code><code>bind_cols</code><code>(</code><code>*data</code>, <code>_name_repair='unique'</code>, <code>_copy=True</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcur_column","title":"<code>datar.apis.dplyr.</code><code>cur_column</code><code>(</code><code>_data</code>, <code>_name</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcur_data","title":"<code>datar.apis.dplyr.</code><code>cur_data</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrn","title":"<code>datar.apis.dplyr.</code><code>n</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcur_data_all","title":"<code>datar.apis.dplyr.</code><code>cur_data_all</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcur_group","title":"<code>datar.apis.dplyr.</code><code>cur_group</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcur_group_id","title":"<code>datar.apis.dplyr.</code><code>cur_group_id</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcur_group_rows","title":"<code>datar.apis.dplyr.</code><code>cur_group_rows</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcount","title":"<code>datar.apis.dplyr.</code><code>count</code><code>(</code><code>_data</code>, <code>*args</code>, <code>wt=None</code>, <code>sort=False</code>, <code>name=None</code>, <code>_drop=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrtally","title":"<code>datar.apis.dplyr.</code><code>tally</code><code>(</code><code>_data</code>, <code>wt=None</code>, <code>sort=False</code>, <code>name=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyradd_count","title":"<code>datar.apis.dplyr.</code><code>add_count</code><code>(</code><code>_data</code>, <code>*args</code>, <code>wt=None</code>, <code>sort=False</code>, <code>name='n'</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyradd_tally","title":"<code>datar.apis.dplyr.</code><code>add_tally</code><code>(</code><code>_data</code>, <code>wt=None</code>, <code>sort=False</code>, <code>name='n'</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrdesc","title":"<code>datar.apis.dplyr.</code><code>desc</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrfilter_","title":"<code>datar.apis.dplyr.</code><code>filter_</code><code>(</code><code>_data</code>, <code>*conditions</code>, <code>_preserve=False</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrdistinct","title":"<code>datar.apis.dplyr.</code><code>distinct</code><code>(</code><code>_data</code>, <code>*args</code>, <code>keep_all=False</code>, <code>_preserve=False</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrn_distinct","title":"<code>datar.apis.dplyr.</code><code>n_distinct</code><code>(</code><code>_data</code>, <code>na_rm=True</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrglimpse","title":"<code>datar.apis.dplyr.</code><code>glimpse</code><code>(</code><code>_data</code>, <code>width=None</code>, <code>formatter=None</code><code>)</code> \u2192 Any","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrslice_","title":"<code>datar.apis.dplyr.</code><code>slice_</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_preserve=False</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrslice_head","title":"<code>datar.apis.dplyr.</code><code>slice_head</code><code>(</code><code>_data</code>, <code>n=None</code>, <code>prop=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrslice_tail","title":"<code>datar.apis.dplyr.</code><code>slice_tail</code><code>(</code><code>_data</code>, <code>n=None</code>, <code>prop=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrslice_sample","title":"<code>datar.apis.dplyr.</code><code>slice_sample</code><code>(</code><code>_data</code>, <code>n=1</code>, <code>prop=None</code>, <code>weight_by=None</code>, <code>replace=False</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrslice_min","title":"<code>datar.apis.dplyr.</code><code>slice_min</code><code>(</code><code>_data</code>, <code>order_by</code>, <code>n=1</code>, <code>prop=None</code>, <code>with_ties=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrslice_max","title":"<code>datar.apis.dplyr.</code><code>slice_max</code><code>(</code><code>_data</code>, <code>order_by</code>, <code>n=1</code>, <code>prop=None</code>, <code>with_ties=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrbetween","title":"<code>datar.apis.dplyr.</code><code>between</code><code>(</code><code>x</code>, <code>left</code>, <code>right</code>, <code>inclusive='both'</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcummean","title":"<code>datar.apis.dplyr.</code><code>cummean</code><code>(</code><code>x</code>, <code>na_rm=False</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcumall","title":"<code>datar.apis.dplyr.</code><code>cumall</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcumany","title":"<code>datar.apis.dplyr.</code><code>cumany</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcoalesce","title":"<code>datar.apis.dplyr.</code><code>coalesce</code><code>(</code><code>x</code>, <code>*replace</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrconsecutive_id","title":"<code>datar.apis.dplyr.</code><code>consecutive_id</code><code>(</code><code>x</code>, <code>*args</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrna_if","title":"<code>datar.apis.dplyr.</code><code>na_if</code><code>(</code><code>x</code>, <code>value</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrnear","title":"<code>datar.apis.dplyr.</code><code>near</code><code>(</code><code>x</code>, <code>y</code>, <code>tol=1e-08</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrnth","title":"<code>datar.apis.dplyr.</code><code>nth</code><code>(</code><code>x</code>, <code>n</code>, <code>order_by=None</code>, <code>default=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrfirst","title":"<code>datar.apis.dplyr.</code><code>first</code><code>(</code><code>x</code>, <code>order_by=None</code>, <code>default=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrlast","title":"<code>datar.apis.dplyr.</code><code>last</code><code>(</code><code>x</code>, <code>order_by=None</code>, <code>default=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_by","title":"<code>datar.apis.dplyr.</code><code>group_by</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_add=False</code>, <code>_drop=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrungroup","title":"<code>datar.apis.dplyr.</code><code>ungroup</code><code>(</code><code>_data</code>, <code>*cols</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrowwise","title":"<code>datar.apis.dplyr.</code><code>rowwise</code><code>(</code><code>_data</code>, <code>*cols</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_by_drop_default","title":"<code>datar.apis.dplyr.</code><code>group_by_drop_default</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_vars","title":"<code>datar.apis.dplyr.</code><code>group_vars</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_indices","title":"<code>datar.apis.dplyr.</code><code>group_indices</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_keys","title":"<code>datar.apis.dplyr.</code><code>group_keys</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_size","title":"<code>datar.apis.dplyr.</code><code>group_size</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_rows","title":"<code>datar.apis.dplyr.</code><code>group_rows</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_cols","title":"<code>datar.apis.dplyr.</code><code>group_cols</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_data","title":"<code>datar.apis.dplyr.</code><code>group_data</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrn_groups","title":"<code>datar.apis.dplyr.</code><code>n_groups</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_map","title":"<code>datar.apis.dplyr.</code><code>group_map</code><code>(</code><code>_data</code>, <code>_f</code>, <code>*args</code>, <code>_keep=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_modify","title":"<code>datar.apis.dplyr.</code><code>group_modify</code><code>(</code><code>_data</code>, <code>_f</code>, <code>*args</code>, <code>_keep=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_split","title":"<code>datar.apis.dplyr.</code><code>group_split</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_keep=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_trim","title":"<code>datar.apis.dplyr.</code><code>group_trim</code><code>(</code><code>_data</code>, <code>_drop=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrgroup_walk","title":"<code>datar.apis.dplyr.</code><code>group_walk</code><code>(</code><code>_data</code>, <code>_f</code>, <code>*args</code>, <code>_keep=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrwith_groups","title":"<code>datar.apis.dplyr.</code><code>with_groups</code><code>(</code><code>_data</code>, <code>_groups</code>, <code>_func</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrif_else","title":"<code>datar.apis.dplyr.</code><code>if_else</code><code>(</code><code>condition</code>, <code>true</code>, <code>false</code>, <code>missing=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcase_match","title":"<code>datar.apis.dplyr.</code><code>case_match</code><code>(</code><code>_x</code>, <code>*args</code>, <code>_default=None</code>, <code>_dtypes=None</code><code>)</code> \u2192 T","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcase_when","title":"<code>datar.apis.dplyr.</code><code>case_when</code><code>(</code><code>cond</code>, <code>value</code>, <code>*more_cases</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrinner_join","title":"<code>datar.apis.dplyr.</code><code>inner_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by=None</code>, <code>copy=False</code>, <code>suffix=('_x', '_y')</code>, <code>keep=False</code>, <code>na_matches='na'</code>, <code>multiple='all'</code>, <code>unmatched='drop'</code>, <code>relationship=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrleft_join","title":"<code>datar.apis.dplyr.</code><code>left_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by=None</code>, <code>copy=False</code>, <code>suffix=('_x', '_y')</code>, <code>keep=False</code>, <code>na_matches='na'</code>, <code>multiple='all'</code>, <code>unmatched='drop'</code>, <code>relationship=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrright_join","title":"<code>datar.apis.dplyr.</code><code>right_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by=None</code>, <code>copy=False</code>, <code>suffix=('_x', '_y')</code>, <code>keep=False</code>, <code>na_matches='na'</code>, <code>multiple='all'</code>, <code>unmatched='drop'</code>, <code>relationship=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrfull_join","title":"<code>datar.apis.dplyr.</code><code>full_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by=None</code>, <code>copy=False</code>, <code>suffix=('_x', '_y')</code>, <code>keep=False</code>, <code>na_matches='na'</code>, <code>multiple='all'</code>, <code>unmatched='drop'</code>, <code>relationship=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrsemi_join","title":"<code>datar.apis.dplyr.</code><code>semi_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by=None</code>, <code>copy=False</code>, <code>na_matches='na'</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyranti_join","title":"<code>datar.apis.dplyr.</code><code>anti_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by=None</code>, <code>copy=False</code>, <code>na_matches='na'</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrnest_join","title":"<code>datar.apis.dplyr.</code><code>nest_join</code><code>(</code><code>x</code>, <code>y</code>, <code>by=None</code>, <code>copy=False</code>, <code>keep=False</code>, <code>name=None</code>, <code>na_matches='na'</code>, <code>unmatched='drop'</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcross_join","title":"<code>datar.apis.dplyr.</code><code>cross_join</code><code>(</code><code>x</code>, <code>y</code>, <code>copy=False</code>, <code>suffix=('_x', '_y')</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrlead","title":"<code>datar.apis.dplyr.</code><code>lead</code><code>(</code><code>x</code>, <code>n=1</code>, <code>default=None</code>, <code>order_by=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrlag","title":"<code>datar.apis.dplyr.</code><code>lag</code><code>(</code><code>x</code>, <code>n=1</code>, <code>default=None</code>, <code>order_by=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrmutate","title":"<code>datar.apis.dplyr.</code><code>mutate</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_keep='all'</code>, <code>_before=None</code>, <code>_after=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrtransmute","title":"<code>datar.apis.dplyr.</code><code>transmute</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_before=None</code>, <code>_after=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrorder_by","title":"<code>datar.apis.dplyr.</code><code>order_by</code><code>(</code><code>order</code>, <code>call</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrwith_order","title":"<code>datar.apis.dplyr.</code><code>with_order</code><code>(</code><code>order</code>, <code>func</code>, <code>x</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrpull","title":"<code>datar.apis.dplyr.</code><code>pull</code><code>(</code><code>_data</code>, <code>var=-1</code>, <code>name=None</code>, <code>to=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrow_number","title":"<code>datar.apis.dplyr.</code><code>row_number</code><code>(</code><code>__html__()</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrntile","title":"<code>datar.apis.dplyr.</code><code>ntile</code><code>(</code><code>__html__()</code>, <code>n=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrmin_rank","title":"<code>datar.apis.dplyr.</code><code>min_rank</code><code>(</code><code>__html__()</code>, <code>na_last='keep'</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrdense_rank","title":"<code>datar.apis.dplyr.</code><code>dense_rank</code><code>(</code><code>__html__()</code>, <code>na_last='keep'</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrpercent_rank","title":"<code>datar.apis.dplyr.</code><code>percent_rank</code><code>(</code><code>__html__()</code>, <code>na_last='keep'</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcume_dist","title":"<code>datar.apis.dplyr.</code><code>cume_dist</code><code>(</code><code>__html__()</code>, <code>na_last='keep'</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrecode","title":"<code>datar.apis.dplyr.</code><code>recode</code><code>(</code><code>_x</code>, <code>*args</code>, <code>_default=None</code>, <code>_missing=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrecode_factor","title":"<code>datar.apis.dplyr.</code><code>recode_factor</code><code>(</code><code>_x</code>, <code>*args</code>, <code>_default=None</code>, <code>_missing=None</code>, <code>_ordered=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrelocate","title":"<code>datar.apis.dplyr.</code><code>relocate</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_before=None</code>, <code>_after=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrename","title":"<code>datar.apis.dplyr.</code><code>rename</code><code>(</code><code>_data</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrename_with","title":"<code>datar.apis.dplyr.</code><code>rename_with</code><code>(</code><code>_data</code>, <code>_fn</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrows_insert","title":"<code>datar.apis.dplyr.</code><code>rows_insert</code><code>(</code><code>x</code>, <code>y</code>, <code>by=None</code>, <code>conflict='error'</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrows_update","title":"<code>datar.apis.dplyr.</code><code>rows_update</code><code>(</code><code>x</code>, <code>y</code>, <code>by=None</code>, <code>unmatched='error'</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrows_patch","title":"<code>datar.apis.dplyr.</code><code>rows_patch</code><code>(</code><code>x</code>, <code>y</code>, <code>by=None</code>, <code>unmatched='error'</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrows_upsert","title":"<code>datar.apis.dplyr.</code><code>rows_upsert</code><code>(</code><code>x</code>, <code>y</code>, <code>by=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrows_delete","title":"<code>datar.apis.dplyr.</code><code>rows_delete</code><code>(</code><code>x</code>, <code>y</code>, <code>by=None</code>, <code>unmatched='error'</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrrows_append","title":"<code>datar.apis.dplyr.</code><code>rows_append</code><code>(</code><code>x</code>, <code>y</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrselect","title":"<code>datar.apis.dplyr.</code><code>select</code><code>(</code><code>_data</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrunion_all","title":"<code>datar.apis.dplyr.</code><code>union_all</code><code>(</code><code>x</code>, <code>y</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrsummarise","title":"<code>datar.apis.dplyr.</code><code>summarise</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_groups=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrwhere","title":"<code>datar.apis.dplyr.</code><code>where</code><code>(</code><code>_data</code>, <code>fn</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyreverything","title":"<code>datar.apis.dplyr.</code><code>everything</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrlast_col","title":"<code>datar.apis.dplyr.</code><code>last_col</code><code>(</code><code>_data</code>, <code>offset=0</code>, <code>vars=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrstarts_with","title":"<code>datar.apis.dplyr.</code><code>starts_with</code><code>(</code><code>_data</code>, <code>match</code>, <code>ignore_case=True</code>, <code>vars=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrends_with","title":"<code>datar.apis.dplyr.</code><code>ends_with</code><code>(</code><code>_data</code>, <code>match</code>, <code>ignore_case=True</code>, <code>vars=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrcontains","title":"<code>datar.apis.dplyr.</code><code>contains</code><code>(</code><code>_data</code>, <code>match</code>, <code>ignore_case=True</code>, <code>vars=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrmatches","title":"<code>datar.apis.dplyr.</code><code>matches</code><code>(</code><code>_data</code>, <code>match</code>, <code>ignore_case=True</code>, <code>vars=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrnum_range","title":"<code>datar.apis.dplyr.</code><code>num_range</code><code>(</code><code>prefix</code>, <code>range_</code>, <code>width=None</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrall_of","title":"<code>datar.apis.dplyr.</code><code>all_of</code><code>(</code><code>_data</code>, <code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.dplyr/#datarapisdplyrany_of","title":"<code>datar.apis.dplyr.</code><code>any_of</code><code>(</code><code>_data</code>, <code>x</code>, <code>vars=None</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/","title":"datar.apis.forcats","text":"module &lt;/&gt; Functions <ul> <li><code>fct_anon</code><code>(</code><code>_f</code>, <code>prefix</code><code>)</code> (Any) \u2014 Anonymise factor levels&lt;/&gt;</li> <li><code>fct_c</code><code>(</code><code>*fs</code><code>)</code> (Any) \u2014 Concatenate factors, combining levels&lt;/&gt;</li> <li><code>fct_collapse</code><code>(</code><code>_f</code>, <code>other_level</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Collapse factor levels into manually defined groups&lt;/&gt;</li> <li><code>fct_count</code><code>(</code><code>_f</code>, <code>sort</code>, <code>prop</code><code>)</code> (Any) \u2014 Count entries in a factor&lt;/&gt;</li> <li><code>fct_cross</code><code>(</code><code>*fs</code>, <code>sep</code>, <code>keep_empty</code><code>)</code> (Any) \u2014 Combine levels from two or more factors to create a new factor&lt;/&gt;</li> <li><code>fct_drop</code><code>(</code><code>_f</code>, <code>only</code><code>)</code> (Any) \u2014 Drop unused levels&lt;/&gt;</li> <li><code>fct_expand</code><code>(</code><code>_f</code>, <code>*additional_levels</code><code>)</code> (Any) \u2014 Add additional levels to a factor&lt;/&gt;</li> <li><code>fct_explicit_na</code><code>(</code><code>_f</code>, <code>na_level</code><code>)</code> (Any) \u2014 Make missing values explicit&lt;/&gt;</li> <li><code>fct_infreq</code><code>(</code><code>_f</code>, <code>ordered</code><code>)</code> (Any) \u2014 Reorder factor levels by frequency&lt;/&gt;</li> <li><code>fct_inorder</code><code>(</code><code>_f</code>, <code>ordered</code><code>)</code> (Any) \u2014 Reorder factor levels by first appearance&lt;/&gt;</li> <li><code>fct_inseq</code><code>(</code><code>_f</code>, <code>ordered</code><code>)</code> (Any) \u2014 Reorder factor levels by sequence&lt;/&gt;</li> <li><code>fct_lump</code><code>(</code><code>_f</code>, <code>n</code>, <code>prop</code>, <code>w</code>, <code>other_level</code>, <code>ties_method</code><code>)</code> (Any) \u2014 Lump together factor levels into \"other\"&lt;/&gt;</li> <li><code>fct_lump_lowfreq</code><code>(</code><code>_f</code>, <code>other_level</code><code>)</code> (Any) \u2014 lumps together the least frequent levels, ensuringthat \"other\" is still the smallest level. &lt;/&gt;</li> <li><code>fct_lump_min</code><code>(</code><code>_f</code>, <code>min_</code>, <code>w</code>, <code>other_level</code><code>)</code> (Any) \u2014 lumps levels that appear fewer than <code>min_</code> times.&lt;/&gt;</li> <li><code>fct_lump_n</code><code>(</code><code>_f</code>, <code>n</code>, <code>w</code>, <code>other_level</code><code>)</code> (Any) \u2014 Lumps all levels except for the <code>n</code> most frequent.&lt;/&gt;</li> <li><code>fct_lump_prop</code><code>(</code><code>_f</code>, <code>prop</code>, <code>w</code>, <code>other_level</code><code>)</code> (Any) \u2014 Lumps levels that appear in fewer <code>prop * n</code> times.&lt;/&gt;</li> <li><code>fct_match</code><code>(</code><code>_f</code>, <code>lvls</code><code>)</code> (Any) \u2014 Test for presence of levels in a factor&lt;/&gt;</li> <li><code>fct_other</code><code>(</code><code>_f</code>, <code>keep</code>, <code>drop</code>, <code>other_level</code><code>)</code> (Any) \u2014 Replace levels with \"other\"&lt;/&gt;</li> <li><code>fct_recode</code><code>(</code><code>_f</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Change factor levels by hand&lt;/&gt;</li> <li><code>fct_relabel</code><code>(</code><code>_f</code>, <code>_fun</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Automatically relabel factor levels, collapse as necessary&lt;/&gt;</li> <li><code>fct_relevel</code><code>(</code><code>_f</code>, <code>*lvls</code>, <code>after</code><code>)</code> (Any) \u2014 Reorder factor levels by hand&lt;/&gt;</li> <li><code>fct_reorder</code><code>(</code><code>_f</code>, <code>_x</code>, <code>*args</code>, <code>_fun</code>, <code>_desc</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Reorder factor levels by a function (default: median)&lt;/&gt;</li> <li><code>fct_reorder2</code><code>(</code><code>_f</code>, <code>_x</code>, <code>*args</code>, <code>_fun</code>, <code>_desc</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Reorder factor levels by a function (default: <code>last2</code>)&lt;/&gt;</li> <li><code>fct_rev</code><code>(</code><code>_f</code><code>)</code> (Any) \u2014 Reverse the order of the levels of a factor&lt;/&gt;</li> <li><code>fct_shift</code><code>(</code><code>_f</code>, <code>n</code><code>)</code> (Any) \u2014 Shift the levels of a factor&lt;/&gt;</li> <li><code>fct_shuffle</code><code>(</code><code>_f</code><code>)</code> (Any) \u2014 Shuffle the levels of a factor&lt;/&gt;</li> <li><code>fct_unify</code><code>(</code><code>fs</code>, <code>levels</code><code>)</code> (Any) \u2014 Unify the levels in a list of factors&lt;/&gt;</li> <li><code>fct_unique</code><code>(</code><code>_f</code><code>)</code> (Any) \u2014 Unique values of a factor&lt;/&gt;</li> <li><code>first2</code><code>(</code><code>_x</code>, <code>_y</code><code>)</code> (Any) \u2014 Find the first element of <code>_y</code> ordered by <code>_x</code>&lt;/&gt;</li> <li><code>last2</code><code>(</code><code>_x</code>, <code>_y</code><code>)</code> (Any) \u2014 Find the last element of <code>_y</code> ordered by <code>_x</code>&lt;/&gt;</li> <li><code>lvls_expand</code><code>(</code><code>_f</code>, <code>new_levels</code><code>)</code> (Any) \u2014 Expands the set of levels; the new levels mustinclude the old levels. &lt;/&gt;</li> <li><code>lvls_reorder</code><code>(</code><code>_f</code>, <code>idx</code>, <code>ordered</code><code>)</code> (Any) \u2014 Leaves values of a factor as they are, but changes the order bygiven indices &lt;/&gt;</li> <li><code>lvls_revalue</code><code>(</code><code>_f</code>, <code>new_levels</code><code>)</code> (Any) \u2014 changes the values of existing levels; there mustbe one new level for each old level &lt;/&gt;</li> <li><code>lvls_union</code><code>(</code><code>fs</code><code>)</code> (Any) \u2014 Find all levels in a list of factors&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Reorder factor levels by hand</p> Parameters <ul> <li><code>_f</code> \u2014 A factor (categoriccal), or a string vector</li> <li><code>*lvls</code> \u2014 Either a function (then <code>len(lvls)</code> should equal to <code>1</code>) orthe new levels. A function will be called with the current levels as input, and the return value (which must be a character vector) will be used to relevel the factor. Any levels not mentioned will be left in their existing order, by default after the explicitly mentioned levels. </li> <li><code>after</code> (int, optional) \u2014 Where should the new values be placed?</li> </ul> Returns (Any) <p>The factor with levels replaced</p> function &lt;/&gt; <p>Reorder factor levels by first appearance</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>ordered</code> (bool, optional) \u2014 A logical which determines the \"ordered\" status of theoutput factor. </li> </ul> Returns (Any) <p>The factor with levels reordered</p> function &lt;/&gt; <p>Reorder factor levels by frequency</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>ordered</code> (bool, optional) \u2014 A logical which determines the \"ordered\" status of theoutput factor. </li> </ul> Returns (Any) <p>The factor with levels reordered</p> function &lt;/&gt; <p>Reorder factor levels by sequence</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>ordered</code> (bool, optional) \u2014 A logical which determines the \"ordered\" status of theoutput factor. </li> </ul> Returns (Any) <p>The factor with levels reordered</p> function &lt;/&gt; <p>Reorder factor levels by a function (default: median)</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>_x</code> \u2014 The data to be used to reorder the factor</li> <li><code>*args</code> \u2014 Extra arguments to be passed to <code>_fun</code></li> <li><code>_fun</code> (optional) \u2014 A function to be used to reorder the factor</li> <li><code>_desc</code> (bool, optional) \u2014 If <code>True</code>, the factor will be reordered in descending order</li> <li><code>**kwargs</code> \u2014 Extra keyword arguments to be passed to <code>_fun</code></li> </ul> Returns (Any) <p>The factor with levels reordered</p> function &lt;/&gt; <p>Reorder factor levels by a function (default: <code>last2</code>)</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>_x</code> \u2014 The data to be used to reorder the factor</li> <li><code>*args</code> \u2014 Extra arguments to be passed to <code>_fun</code></li> <li><code>_fun</code> (optional) \u2014 A function to be used to reorder the factor</li> <li><code>_desc</code> (bool, optional) \u2014 If <code>True</code>, the factor will be reordered in descending order</li> <li><code>**kwargs</code> \u2014 Extra keyword arguments to be passed to <code>_fun</code></li> </ul> Returns (Any) <p>The factor with levels reordered</p> function &lt;/&gt; <p>Shuffle the levels of a factor</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> </ul> Returns (Any) <p>The factor with levels shuffled</p> function &lt;/&gt; <p>Reverse the order of the levels of a factor</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> </ul> Returns (Any) <p>The factor with levels reversed</p> function &lt;/&gt; <p>Shift the levels of a factor</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>n</code> (int, optional) \u2014 The number of levels to shift</li> </ul> Returns (Any) <p>The factor with levels shifted</p> function &lt;/&gt; <p>Find the first element of <code>_y</code> ordered by <code>_x</code></p> Parameters <ul> <li><code>_x</code> \u2014 The vector used to order <code>_y</code></li> <li><code>_y</code> \u2014 The vector to get the first element of</li> </ul> Returns (Any) <p>First element of <code>_y</code> ordered by <code>_x</code></p> function &lt;/&gt; <p>Find the last element of <code>_y</code> ordered by <code>_x</code></p> Parameters <ul> <li><code>_x</code> \u2014 The vector used to order <code>_y</code></li> <li><code>_y</code> \u2014 The vector to get the last element of</li> </ul> Returns (Any) <p>Last element of <code>_y</code> ordered by <code>_x</code></p> function &lt;/&gt; <p>Anonymise factor levels</p> Parameters <ul> <li><code>prefix</code> (str, optional) \u2014 A character prefix to insert in front of the random labels.</li> <li><code>f</code> \u2014 A factor.</li> </ul> Returns (Any) <p>The factor with levels anonymised</p> function &lt;/&gt; <p>Change factor levels by hand</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>*args</code> \u2014 and</li> <li><code>**kwargs</code> \u2014 A sequence of named character vectors where the namegives the new level, and the value gives the old level. Levels not otherwise mentioned will be left as is. Levels can be removed by naming them <code>NULL</code>. As <code>NULL/None</code> cannot be a name of keyword arguments, replacement has to be specified as a dict (i.e. <code>fct_recode(x, {NULL: \"apple\"})</code>) If you want to replace multiple values with the same old value, use a <code>set</code>/<code>list</code>/<code>numpy.ndarray</code> (i.e. <code>fct_recode(x, fruit=[\"apple\", \"banana\"])</code>). This is a safe way, since <code>set</code>/<code>list</code>/<code>numpy.ndarray</code> is not hashable to be a level of a factor. Do NOT use a <code>tuple</code>, as it's hashable! Note that the order of the name-value is in the reverse way as <code>dplyr.recode()</code> and <code>dplyr.recode_factor()</code> </li> </ul> Returns (Any) <p>The factor recoded with given recodings</p> function &lt;/&gt; <p>Collapse factor levels into manually defined groups</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>other_level</code> (optional) \u2014 Replace all levels not named in <code>kwargs</code>.If not, don't collapse them. </li> <li><code>**kwargs</code> \u2014 The levels to collapse.Like <code>name=[old_level, old_level1, ...]</code>. The old levels will be replaced with <code>name</code> </li> </ul> Returns (Any) <p>The factor with levels collapsed.</p> function &lt;/&gt; <p>Lump together factor levels into \"other\"</p> Parameters <ul> <li><code>n</code> (optional) \u2014 Positive <code>n</code> preserves the most common <code>n</code> values.Negative <code>n</code> preserves the least common <code>-n</code> values. It there are ties, you will get at least <code>abs(n)</code> values. </li> <li><code>prop</code> (optional) \u2014 Positive <code>prop</code> lumps values which do not appear at least<code>prop</code> of the time. Negative <code>prop</code> lumps values that do not appear at most <code>-prop</code> of the time. </li> <li><code>w</code> (optional) \u2014 An optional numeric vector giving weights for frequency ofeach value (not level) in f. </li> <li><code>other_level</code> (optional) \u2014 Value of level used for \"other\" values. Alwaysplaced at end of levels. </li> <li><code>f</code> \u2014 A factor</li> <li><code>ties_method A character string specifying how ties are treated.</code> \u2014 One of: <code>average</code>, <code>first</code>, <code>dense</code>, <code>max</code>, and <code>min</code>.</li> </ul> Returns (Any) <p>The factor with levels lumped.</p> function &lt;/&gt; <p>lumps levels that appear fewer than <code>min_</code> times.</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>min_</code> \u2014 Preserve levels that appear at least <code>min_</code> number of times.</li> <li><code>w</code> (optional) \u2014 An optional numeric vector giving weights for frequency ofeach value (not level) in f. </li> <li><code>other_level</code> (optional) \u2014 Value of level used for \"other\" values. Alwaysplaced at end of levels. </li> </ul> Returns (Any) <p>The factor with levels lumped.</p> function &lt;/&gt; <p>Lumps levels that appear in fewer <code>prop * n</code> times.</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>prop</code> \u2014 Positive <code>prop</code> lumps values which do not appear at least<code>prop</code> of the time. Negative <code>prop</code> lumps values that do not appear at most <code>-prop</code> of the time. </li> <li><code>w</code> (optional) \u2014 An optional numeric vector giving weights for frequency ofeach value (not level) in f. </li> <li><code>other_level</code> (optional) \u2014 Value of level used for \"other\" values. Alwaysplaced at end of levels. </li> </ul> Returns (Any) <p>The factor with levels lumped.</p> function &lt;/&gt; <p>Lumps all levels except for the <code>n</code> most frequent.</p> Parameters <ul> <li><code>n</code> \u2014 Positive <code>n</code> preserves the most common <code>n</code> values.Negative <code>n</code> preserves the least common <code>-n</code> values. It there are ties, you will get at least <code>abs(n)</code> values. </li> <li><code>w</code> (optional) \u2014 An optional numeric vector giving weights for frequency ofeach value (not level) in f. </li> <li><code>other_level</code> (optional) \u2014 Value of level used for \"other\" values. Alwaysplaced at end of levels. </li> <li><code>f</code> \u2014 A factor</li> <li><code>ties_method A character string specifying how ties are treated.</code> \u2014 One of: <code>average</code>, <code>first</code>, <code>dense</code>, <code>max</code>, and <code>min</code>.</li> </ul> Returns (Any) <p>The factor with levels lumped.</p> function &lt;/&gt; <p>lumps together the least frequent levels, ensuringthat \"other\" is still the smallest level.</p> Parameters <ul> <li><code>other_level</code> (optional) \u2014 Value of level used for \"other\" values. Alwaysplaced at end of levels. </li> <li><code>f</code> \u2014 A factor</li> </ul> Returns (Any) <p>The factor with levels lumped.</p> function &lt;/&gt; <p>Replace levels with \"other\"</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>keep</code> (optional) \u2014 and</li> <li><code>drop</code> (optional) \u2014 Pick one of <code>keep</code> and <code>drop</code>:<ul><li>- <code>keep</code> will preserve listed levels, replacing all others with <code>other_level</code>.</li><li>- <code>drop</code> will replace listed levels with <code>other_level</code>, keeping all\u00a0    as is.</li></ul></li> <li><code>other_level</code> (optional) \u2014 Value of level used for \"other\" values. Alwaysplaced at end of levels. </li> </ul> Returns (Any) <p>The factor with levels replaced.</p> function &lt;/&gt; <p>Automatically relabel factor levels, collapse as necessary</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>_fun</code> \u2014 A function to be applied to each level. Must accept the oldlevels and return a character vector of the same length as its input. </li> <li><code>*args</code> \u2014 and</li> <li><code>**kwargs</code> \u2014 Addtional arguments to <code>_fun</code></li> </ul> Returns (Any) <p>The factor with levels relabeled</p> function &lt;/&gt; <p>Add additional levels to a factor</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>*additional_levels</code> \u2014 Additional levels to add to the factor.Levels that already exist will be silently ignored. </li> </ul> Returns (Any) <p>The factor with levels expanded</p> function &lt;/&gt; <p>Make missing values explicit</p><p>This gives missing values an explicit factor level, ensuring that they appear in summaries and on plots.</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>na_level</code> (optional) \u2014 Level to use for missing values.This is what NAs will be changed to. </li> </ul> Returns (Any) <p>The factor with explict na_levels</p> function &lt;/&gt; <p>Drop unused levels</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>only</code> (optional) \u2014 A character vector restricting the set of levels to be dropped.If supplied, only levels that have no entries and appear in this vector will be removed. </li> </ul> Returns (Any) <p>The factor with unused levels dropped</p> function &lt;/&gt; <p>Unify the levels in a list of factors</p> Parameters <ul> <li><code>fs</code> \u2014 A list of factors</li> <li><code>levels</code> (optional) \u2014 Set of levels to apply to every factor. Default to unionof all factor levels </li> </ul> Returns (Any) <p>A list of factors with the levels expanded</p> function &lt;/&gt; <p>Concatenate factors, combining levels</p><p>This is a useful ways of patching together factors from multiple sources that really should have the same levels but don't.</p> Parameters <ul> <li><code>*fs</code> \u2014 factors to concatenate</li> </ul> Returns (Any) <p>The concatenated factor</p> function &lt;/&gt; <p>Combine levels from two or more factors to create a new factor</p><p>Computes a factor whose levels are all the combinations of the levels of the input factors.</p> Parameters <ul> <li><code>*fs</code> \u2014 factors to cross</li> <li><code>sep</code> (str, optional) \u2014 A string to separate levels</li> <li><code>keep_empty</code> (bool, optional) \u2014 If True, keep combinations with no observations as levels</li> </ul> Returns (Any) <p>The new factor</p> function &lt;/&gt; <p>Count entries in a factor</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>sort</code> (bool, optional) \u2014 If True, sort the result so that the most common values float tothe top </li> <li><code>prop</code> (optional) \u2014 If True, compute the fraction of marginal table.</li> </ul> Returns (Any) <p>A data frame with columns <code>f</code>, <code>n</code> and <code>p</code>, if prop is True</p> function &lt;/&gt; <p>Test for presence of levels in a factor</p><p>Do any of <code>lvls</code> occur in <code>_f</code>?</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>lvls</code> \u2014 A vector specifying levels to look for.</li> </ul> Returns (Any) <p>A logical factor</p> function &lt;/&gt; <p>Unique values of a factor</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> </ul> Returns (Any) <p>The factor with the unique values in <code>_f</code></p> function &lt;/&gt; <p>Leaves values of a factor as they are, but changes the order bygiven indices</p> Parameters <ul> <li><code>idx</code> \u2014 A integer index, with one integer for each existing level.</li> <li><code>ordered</code> (bool, optional) \u2014 A logical which determines the \"ordered\" status of theoutput factor. <code>None</code> preserves the existing status of the factor. </li> <li><code>f</code> \u2014 A factor (or character vector).</li> <li><code>new_levels</code> \u2014 A character vector of new levels.</li> </ul> Returns (Any) <p>The factor with levels reordered</p> function &lt;/&gt; <p>changes the values of existing levels; there mustbe one new level for each old level</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>new_levels</code> \u2014 A character vector of new levels.</li> </ul> Returns (Any) <p>The factor with the new levels</p> function &lt;/&gt; <p>Expands the set of levels; the new levels mustinclude the old levels.</p> Parameters <ul> <li><code>_f</code> \u2014 A factor</li> <li><code>new_levels</code> \u2014 The new levels. Must include the old ones</li> </ul> Returns (Any) <p>The factor with the new levels</p> function &lt;/&gt; <p>Find all levels in a list of factors</p> Parameters <ul> <li><code>fs</code> \u2014 A list of factors</li> </ul> Returns (Any) <p>A list of all levels</p>"},{"location":"api/datar.apis.forcats/#datarapisforcats","title":"datar.apis.forcats","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_relevel","title":"<code>datar.apis.forcats.</code><code>fct_relevel</code><code>(</code><code>_f</code>, <code>*lvls</code>, <code>after=None</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_inorder","title":"<code>datar.apis.forcats.</code><code>fct_inorder</code><code>(</code><code>_f</code>, <code>ordered=None</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_infreq","title":"<code>datar.apis.forcats.</code><code>fct_infreq</code><code>(</code><code>_f</code>, <code>ordered=None</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_inseq","title":"<code>datar.apis.forcats.</code><code>fct_inseq</code><code>(</code><code>_f</code>, <code>ordered=None</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_reorder","title":"<code>datar.apis.forcats.</code><code>fct_reorder</code><code>(</code><code>_f</code>, <code>_x</code>, <code>*args</code>, <code>_fun=None</code>, <code>_desc=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_reorder2","title":"<code>datar.apis.forcats.</code><code>fct_reorder2</code><code>(</code><code>_f</code>, <code>_x</code>, <code>*args</code>, <code>_fun=None</code>, <code>_desc=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_shuffle","title":"<code>datar.apis.forcats.</code><code>fct_shuffle</code><code>(</code><code>_f</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_rev","title":"<code>datar.apis.forcats.</code><code>fct_rev</code><code>(</code><code>_f</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_shift","title":"<code>datar.apis.forcats.</code><code>fct_shift</code><code>(</code><code>_f</code>, <code>n=1</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfirst2","title":"<code>datar.apis.forcats.</code><code>first2</code><code>(</code><code>_x</code>, <code>_y</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatslast2","title":"<code>datar.apis.forcats.</code><code>last2</code><code>(</code><code>_x</code>, <code>_y</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_anon","title":"<code>datar.apis.forcats.</code><code>fct_anon</code><code>(</code><code>_f</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_recode","title":"<code>datar.apis.forcats.</code><code>fct_recode</code><code>(</code><code>_f</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_collapse","title":"<code>datar.apis.forcats.</code><code>fct_collapse</code><code>(</code><code>_f</code>, <code>other_level=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_lump","title":"<code>datar.apis.forcats.</code><code>fct_lump</code><code>(</code><code>_f</code>, <code>n=None</code>, <code>prop=None</code>, <code>w=None</code>, <code>other_level='Other'</code>, <code>ties_method='min'</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_lump_min","title":"<code>datar.apis.forcats.</code><code>fct_lump_min</code><code>(</code><code>_f</code>, <code>min_</code>, <code>w=None</code>, <code>other_level='Other'</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_lump_prop","title":"<code>datar.apis.forcats.</code><code>fct_lump_prop</code><code>(</code><code>_f</code>, <code>prop</code>, <code>w=None</code>, <code>other_level='Other'</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_lump_n","title":"<code>datar.apis.forcats.</code><code>fct_lump_n</code><code>(</code><code>_f</code>, <code>n</code>, <code>w=None</code>, <code>other_level='Other'</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_lump_lowfreq","title":"<code>datar.apis.forcats.</code><code>fct_lump_lowfreq</code><code>(</code><code>_f</code>, <code>other_level='Other'</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_other","title":"<code>datar.apis.forcats.</code><code>fct_other</code><code>(</code><code>_f</code>, <code>keep=None</code>, <code>drop=None</code>, <code>other_level='Other'</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_relabel","title":"<code>datar.apis.forcats.</code><code>fct_relabel</code><code>(</code><code>_f</code>, <code>_fun</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_expand","title":"<code>datar.apis.forcats.</code><code>fct_expand</code><code>(</code><code>_f</code>, <code>*additional_levels</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_explicit_na","title":"<code>datar.apis.forcats.</code><code>fct_explicit_na</code><code>(</code><code>_f</code>, <code>na_level='(Missing)'</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_drop","title":"<code>datar.apis.forcats.</code><code>fct_drop</code><code>(</code><code>_f</code>, <code>only=None</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_unify","title":"<code>datar.apis.forcats.</code><code>fct_unify</code><code>(</code><code>fs</code>, <code>levels=None</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_c","title":"<code>datar.apis.forcats.</code><code>fct_c</code><code>(</code><code>*fs</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_cross","title":"<code>datar.apis.forcats.</code><code>fct_cross</code><code>(</code><code>*fs</code>, <code>sep=':'</code>, <code>keep_empty=False</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_count","title":"<code>datar.apis.forcats.</code><code>fct_count</code><code>(</code><code>_f</code>, <code>sort=False</code>, <code>prop=False</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_match","title":"<code>datar.apis.forcats.</code><code>fct_match</code><code>(</code><code>_f</code>, <code>lvls</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatsfct_unique","title":"<code>datar.apis.forcats.</code><code>fct_unique</code><code>(</code><code>_f</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatslvls_reorder","title":"<code>datar.apis.forcats.</code><code>lvls_reorder</code><code>(</code><code>_f</code>, <code>idx</code>, <code>ordered=None</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatslvls_revalue","title":"<code>datar.apis.forcats.</code><code>lvls_revalue</code><code>(</code><code>_f</code>, <code>new_levels</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatslvls_expand","title":"<code>datar.apis.forcats.</code><code>lvls_expand</code><code>(</code><code>_f</code>, <code>new_levels</code><code>)</code>","text":""},{"location":"api/datar.apis.forcats/#datarapisforcatslvls_union","title":"<code>datar.apis.forcats.</code><code>lvls_union</code><code>(</code><code>fs</code><code>)</code>","text":""},{"location":"api/datar.apis/","title":"datar.apis","text":"package &lt;/&gt; module &lt;/&gt; <p>APIs ported from r-base</p> Functions <ul> <li><code>abs_</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the absolute value of a vector&lt;/&gt;</li> <li><code>acos</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the inverse cosine&lt;/&gt;</li> <li><code>acosh</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the inverse hyperbolic cosine&lt;/&gt;</li> <li><code>all_</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Are all elements true&lt;/&gt;</li> <li><code>any_</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Is any element true&lt;/&gt;</li> <li><code>any_na</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if anything in <code>x</code> is NA&lt;/&gt;</li> <li><code>append</code><code>(</code><code>x</code>, <code>values</code>, <code>after</code><code>)</code> (Any) \u2014 Append values to the vector&lt;/&gt;</li> <li><code>arg</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Angles of complex numbers&lt;/&gt;</li> <li><code>as_character</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to a character vector&lt;/&gt;</li> <li><code>as_complex</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to a complex vector&lt;/&gt;</li> <li><code>as_date</code><code>(</code><code>x</code>, <code>format</code>, <code>try_formats</code>, <code>optional</code>, <code>tz</code>, <code>origin</code><code>)</code> (Any) \u2014 Convert an object to a datetime.date object&lt;/&gt;</li> <li><code>as_double</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to a double vector&lt;/&gt;</li> <li><code>as_factor</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to a factor vector&lt;/&gt;</li> <li><code>as_integer</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to an integer vector&lt;/&gt;</li> <li><code>as_logical</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to a logical vector&lt;/&gt;</li> <li><code>as_null</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert anything to NULL&lt;/&gt;</li> <li><code>as_numeric</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to a numeric vector&lt;/&gt;</li> <li><code>as_ordered</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a vector to an ordered vector&lt;/&gt;</li> <li><code>asin</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the inverse sine&lt;/&gt;</li> <li><code>asinh</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the inverse hyperbolic sine&lt;/&gt;</li> <li><code>atan</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the inverse tangent&lt;/&gt;</li> <li><code>atan2</code><code>(</code><code>y</code>, <code>x</code><code>)</code> (Any) \u2014 Get the inverse tangent of y/x&lt;/&gt;</li> <li><code>atanh</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the inverse hyperbolic tangent&lt;/&gt;</li> <li><code>bessel_i</code><code>(</code><code>x</code>, <code>nu</code>, <code>expon_scaled</code><code>)</code> (Any) \u2014 Compute the modified Bessel function of the first kind&lt;/&gt;</li> <li><code>bessel_j</code><code>(</code><code>x</code>, <code>nu</code><code>)</code> (Any) \u2014 Compute the Bessel function of the first kind&lt;/&gt;</li> <li><code>bessel_k</code><code>(</code><code>x</code>, <code>nu</code>, <code>expon_scaled</code><code>)</code> (Any) \u2014 Compute the modified Bessel function of the second kind&lt;/&gt;</li> <li><code>bessel_y</code><code>(</code><code>x</code>, <code>nu</code><code>)</code> (Any) \u2014 Compute the Bessel function of the second kind&lt;/&gt;</li> <li><code>beta</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Compute the beta function&lt;/&gt;</li> <li><code>c_</code><code>(</code><code>*args</code><code>)</code> (Any) \u2014 Concatenate vectors&lt;/&gt;</li> <li><code>ceiling</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Round up to the nearest integer&lt;/&gt;</li> <li><code>chartr</code><code>(</code><code>old</code>, <code>new</code>, <code>x</code><code>)</code> (Any) \u2014 Translate characters&lt;/&gt;</li> <li><code>choose</code><code>(</code><code>n</code>, <code>k</code><code>)</code> (Any) \u2014 Compute the binomial coefficient&lt;/&gt;</li> <li><code>col_means</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the column means of a matrix&lt;/&gt;</li> <li><code>col_medians</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the column medians of a matrix&lt;/&gt;</li> <li><code>col_sds</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the column standard deviations of a matrix&lt;/&gt;</li> <li><code>col_sums</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the column sums of a matrix&lt;/&gt;</li> <li><code>colnames</code><code>(</code><code>x</code>, <code>nested</code><code>)</code> (Any) \u2014 Get the column names&lt;/&gt;</li> <li><code>complete_cases</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the complete cases&lt;/&gt;</li> <li><code>conj</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Complex conjugate&lt;/&gt;</li> <li><code>cos</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the cosine&lt;/&gt;</li> <li><code>cosh</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the hyperbolic cosine&lt;/&gt;</li> <li><code>cospi</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the cosine of pi times x&lt;/&gt;</li> <li><code>cov</code><code>(</code><code>x</code>, <code>y</code>, <code>na_rm</code>, <code>ddof</code><code>)</code> (Any) \u2014 Compute pairwise covariance between two variables&lt;/&gt;</li> <li><code>cummax</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Cumulative maxima&lt;/&gt;</li> <li><code>cummin</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Cumulative minima&lt;/&gt;</li> <li><code>cumprod</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Cumulative products&lt;/&gt;</li> <li><code>cumsum</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Cumulative sums&lt;/&gt;</li> <li><code>cut</code><code>(</code><code>x</code>, <code>breaks</code>, <code>labels</code>, <code>include_lowest</code>, <code>right</code>, <code>dig_lab</code>, <code>ordered_result</code><code>)</code> (Any) \u2014 Cut a numeric vector into bins&lt;/&gt;</li> <li><code>diag</code><code>(</code><code>x</code>, <code>nrow</code>, <code>ncol</code><code>)</code> (Any) \u2014 Get the diagonal of a matrix&lt;/&gt;</li> <li><code>diff</code><code>(</code><code>x</code>, <code>lag</code>, <code>differences</code><code>)</code> (An array of `x[lag) \u2014 Difference of a numeric vector&lt;/&gt;</li> <li><code>digamma</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the digamma function&lt;/&gt;</li> <li><code>dim</code><code>(</code><code>x</code>, <code>nested</code><code>)</code> (Any) \u2014 Get the dimensions&lt;/&gt;</li> <li><code>droplevels</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Drop unused levels of a factor&lt;/&gt;</li> <li><code>duplicated</code><code>(</code><code>x</code>, <code>incomparables</code>, <code>from_last</code><code>)</code> (Any) \u2014 Get the duplicated values&lt;/&gt;</li> <li><code>endswith</code><code>(</code><code>x</code>, <code>suffix</code><code>)</code> (Any) \u2014 Does x end with suffix&lt;/&gt;</li> <li><code>exp</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the exponential of a vector&lt;/&gt;</li> <li><code>expand_grid</code><code>(</code><code>x</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Expand a grid&lt;/&gt;</li> <li><code>factor</code><code>(</code><code>x</code>, <code>levels</code>, <code>labels</code>, <code>exclude</code>, <code>ordered</code>, <code>nmax</code><code>)</code> (Any) \u2014 Create a factor vector&lt;/&gt;</li> <li><code>factorial</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the factorial&lt;/&gt;</li> <li><code>floor</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Round down to the nearest integer&lt;/&gt;</li> <li><code>gamma</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the gamma function&lt;/&gt;</li> <li><code>grep</code><code>(</code><code>pattern</code>, <code>x</code>, <code>ignore_case</code>, <code>value</code>, <code>fixed</code>, <code>invert</code><code>)</code> (Any) \u2014 Grep for a pattern&lt;/&gt;</li> <li><code>grepl</code><code>(</code><code>pattern</code>, <code>x</code>, <code>ignore_case</code>, <code>fixed</code><code>)</code> (Any) \u2014 Grep for a pattern&lt;/&gt;</li> <li><code>gsub</code><code>(</code><code>pattern</code>, <code>replacement</code>, <code>x</code>, <code>ignore_case</code>, <code>fixed</code><code>)</code> (Any) \u2014 Substitute a pattern&lt;/&gt;</li> <li><code>head</code><code>(</code><code>x</code>, <code>n</code><code>)</code> (Any) \u2014 Get the first n rows&lt;/&gt;</li> <li><code>identity</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Identity function&lt;/&gt;</li> <li><code>im</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Imaginary part of complex numbers&lt;/&gt;</li> <li><code>intersect</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Get the intersection of two vectors&lt;/&gt;</li> <li><code>is_atomic</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Is the object atomic&lt;/&gt;</li> <li><code>is_character</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Is x a character vector&lt;/&gt;</li> <li><code>is_complex</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if a vector is complex&lt;/&gt;</li> <li><code>is_double</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Is the object a double&lt;/&gt;</li> <li><code>is_element</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Is the object an element of the table&lt;/&gt;</li> <li><code>is_factor</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if a vector is a factor&lt;/&gt;</li> <li><code>is_false</code><code>(</code><code>x</code><code>)</code> (bool) \u2014 Check if anything is false&lt;/&gt;</li> <li><code>is_finite</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if anything is finite&lt;/&gt;</li> <li><code>is_infinite</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if anything is infinite&lt;/&gt;</li> <li><code>is_integer</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Is the object an integer&lt;/&gt;</li> <li><code>is_logical</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if a vector is logical&lt;/&gt;</li> <li><code>is_na</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if anything is NA&lt;/&gt;</li> <li><code>is_null</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if anything is NULL&lt;/&gt;</li> <li><code>is_numeric</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Is the object numeric&lt;/&gt;</li> <li><code>is_ordered</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Check if a vector is ordered&lt;/&gt;</li> <li><code>is_true</code><code>(</code><code>x</code><code>)</code> (bool) \u2014 Check if anything is true&lt;/&gt;</li> <li><code>lbeta</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Compute the log beta function&lt;/&gt;</li> <li><code>lchoose</code><code>(</code><code>n</code>, <code>k</code><code>)</code> (Any) \u2014 Compute the log binomial coefficient&lt;/&gt;</li> <li><code>length</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the length of a vector&lt;/&gt;</li> <li><code>lengths</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the lengths of a list&lt;/&gt;</li> <li><code>levels</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the levels of a factor&lt;/&gt;</li> <li><code>lfactorial</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the log factorial&lt;/&gt;</li> <li><code>lgamma</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the log gamma function&lt;/&gt;</li> <li><code>log</code><code>(</code><code>x</code>, <code>base</code><code>)</code> (Any) \u2014 Compute the logarithm of a vector&lt;/&gt;</li> <li><code>log10</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the base 10 logarithm of a vector&lt;/&gt;</li> <li><code>log1p</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the logarithm of one plus a vector&lt;/&gt;</li> <li><code>log2</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the base-2 logarithm of a vector&lt;/&gt;</li> <li><code>make_names</code><code>(</code><code>names</code>, <code>unique</code><code>)</code> (Any) \u2014 Make names for a vector&lt;/&gt;</li> <li><code>make_unique</code><code>(</code><code>names</code><code>)</code> (Any) \u2014 Make a vector unique&lt;/&gt;</li> <li><code>match</code><code>(</code><code>x</code>, <code>table</code>, <code>nomatch</code><code>)</code> (Any) \u2014 Match elements of a vector&lt;/&gt;</li> <li><code>max_</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the maximum of a vector&lt;/&gt;</li> <li><code>max_col</code><code>(</code><code>x</code>, <code>ties_method</code>, <code>nested</code><code>)</code> (Any) \u2014 Get the maximum column&lt;/&gt;</li> <li><code>mean</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the mean of a vector&lt;/&gt;</li> <li><code>median</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the median of a vector&lt;/&gt;</li> <li><code>min_</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the minimum of a vector&lt;/&gt;</li> <li><code>mod</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Modulus of complex numbers&lt;/&gt;</li> <li><code>nchar</code><code>(</code><code>x</code>, <code>type_</code>, <code>allow_na</code>, <code>keep_na</code>, <code>_na_len</code><code>)</code> (Any) \u2014 Get the number of characters in a string&lt;/&gt;</li> <li><code>ncol</code><code>(</code><code>x</code>, <code>nested</code><code>)</code> (Any) \u2014 Get the number of columns&lt;/&gt;</li> <li><code>nlevels</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the number of levels of a factor&lt;/&gt;</li> <li><code>nrow</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the number of rows&lt;/&gt;</li> <li><code>nzchar</code><code>(</code><code>x</code>, <code>keep_na</code><code>)</code> (Any) \u2014 Is the string non-zero length&lt;/&gt;</li> <li><code>order</code><code>(</code><code>x</code>, <code>decreasing</code>, <code>na_last</code><code>)</code> (Any) \u2014 Order a vector&lt;/&gt;</li> <li><code>ordered</code><code>(</code><code>x</code>, <code>levels</code>, <code>labels</code>, <code>exclude</code>, <code>nmax</code><code>)</code> (Any) \u2014 Create an ordered factor vector&lt;/&gt;</li> <li><code>outer</code><code>(</code><code>x</code>, <code>y</code>, <code>fun</code><code>)</code> (Any) \u2014 Outer product of two vectors&lt;/&gt;</li> <li><code>paste</code><code>(</code><code>*args</code>, <code>sep</code>, <code>collapse</code><code>)</code> (Any) \u2014 Join a vector into a string&lt;/&gt;</li> <li><code>paste0</code><code>(</code><code>*args</code>, <code>collapse</code><code>)</code> (Any) \u2014 Join a vector into a string&lt;/&gt;</li> <li><code>pmax</code><code>(</code><code>*args</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Returns the (regular or Parallel) maxima and minima of the input values. &lt;/&gt;</li> <li><code>pmin</code><code>(</code><code>*args</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Returns the (regular or Parallel) maxima and minima of the input values. &lt;/&gt;</li> <li><code>prod</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the product of a vector&lt;/&gt;</li> <li><code>proportions</code><code>(</code><code>x</code>, <code>margin</code><code>)</code> (Any) \u2014 Get the proportion table&lt;/&gt;</li> <li><code>psigamma</code><code>(</code><code>x</code>, <code>deriv</code><code>)</code> (Any) \u2014 Compute the psi function&lt;/&gt;</li> <li><code>quantile</code><code>(</code><code>x</code>, <code>probs</code>, <code>na_rm</code>, <code>names</code>, <code>type_</code>, <code>digits</code><code>)</code> (Any) \u2014 Compute the quantiles of a vector&lt;/&gt;</li> <li><code>rank</code><code>(</code><code>x</code>, <code>na_last</code>, <code>ties_method</code><code>)</code> (Any) \u2014 Rank a numeric vector&lt;/&gt;</li> <li><code>rbinom</code><code>(</code><code>n</code>, <code>size</code>, <code>prob</code><code>)</code> (Any) \u2014 Generate random binomial variables&lt;/&gt;</li> <li><code>rcauchy</code><code>(</code><code>n</code>, <code>location</code>, <code>scale</code><code>)</code> (Any) \u2014 Generate random Cauchy variables&lt;/&gt;</li> <li><code>rchisq</code><code>(</code><code>n</code>, <code>df</code><code>)</code> (Any) \u2014 Generate random chi-squared variables&lt;/&gt;</li> <li><code>re_</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Real part of complex numbers&lt;/&gt;</li> <li><code>rep</code><code>(</code><code>x</code>, <code>times</code>, <code>length</code>, <code>each</code><code>)</code> (Any) \u2014 Replicate elements of a vector&lt;/&gt;</li> <li><code>rev</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Reverse a vector&lt;/&gt;</li> <li><code>rexp</code><code>(</code><code>n</code>, <code>rate</code><code>)</code> (Any) \u2014 Generate random exponential variables&lt;/&gt;</li> <li><code>rnorm</code><code>(</code><code>n</code>, <code>mean</code>, <code>sd</code><code>)</code> (Any) \u2014 Generate random normal variables&lt;/&gt;</li> <li><code>round_</code><code>(</code><code>x</code>, <code>digits</code><code>)</code> (Any) \u2014 Round the values of a vector&lt;/&gt;</li> <li><code>row_means</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the row means of a matrix&lt;/&gt;</li> <li><code>row_medians</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the row medians of a matrix&lt;/&gt;</li> <li><code>row_sds</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the row standard deviations of a matrix&lt;/&gt;</li> <li><code>row_sums</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the row sums of a matrix&lt;/&gt;</li> <li><code>rownames</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the row names&lt;/&gt;</li> <li><code>rpois</code><code>(</code><code>n</code>, <code>lambda_</code><code>)</code> (Any) \u2014 Generate random Poisson variables&lt;/&gt;</li> <li><code>runif</code><code>(</code><code>n</code>, <code>min</code>, <code>max</code><code>)</code> (Any) \u2014 Generate random uniform variables&lt;/&gt;</li> <li><code>sample</code><code>(</code><code>x</code>, <code>size</code>, <code>replace</code>, <code>prob</code><code>)</code> (Any) \u2014 Sample a vector&lt;/&gt;</li> <li><code>scale</code><code>(</code><code>x</code>, <code>center</code>, <code>scale_</code><code>)</code> (Any) \u2014 Center and/or scale the data&lt;/&gt;</li> <li><code>sd</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the standard deviation of a vector&lt;/&gt;</li> <li><code>seq</code><code>(</code><code>from_</code>, <code>to</code>, <code>by</code>, <code>length_out</code>, <code>along_with</code><code>)</code> (Any) \u2014 Generate a sequence&lt;/&gt;</li> <li><code>seq_along</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Generate a sequence along a vector&lt;/&gt;</li> <li><code>seq_len</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Generate a sequence of length x&lt;/&gt;</li> <li><code>set_colnames</code><code>(</code><code>x</code>, <code>names</code>, <code>nested</code><code>)</code> (Any) \u2014 Set the column names&lt;/&gt;</li> <li><code>set_levels</code><code>(</code><code>x</code>, <code>levels</code><code>)</code> (Any) \u2014 Set the levels of a factor&lt;/&gt;</li> <li><code>set_rownames</code><code>(</code><code>x</code>, <code>names</code><code>)</code> (Any) \u2014 Set the row names&lt;/&gt;</li> <li><code>set_seed</code><code>(</code><code>seed</code><code>)</code> (Any) \u2014 Set the seed of the random number generator&lt;/&gt;</li> <li><code>setdiff</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Get the difference of two vectors&lt;/&gt;</li> <li><code>setequal</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Check if two vectors are equal&lt;/&gt;</li> <li><code>sign</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the sign of a vector&lt;/&gt;</li> <li><code>signif</code><code>(</code><code>x</code>, <code>digits</code><code>)</code> (Any) \u2014 Round the values of a vector to a given number of significant digits&lt;/&gt;</li> <li><code>sin</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the sine&lt;/&gt;</li> <li><code>sinh</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the hyperbolic sine&lt;/&gt;</li> <li><code>sinpi</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the sine of pi times x&lt;/&gt;</li> <li><code>sort</code><code>(</code><code>x</code>, <code>decreasing</code>, <code>na_last</code><code>)</code> (Any) \u2014 Sort a vector&lt;/&gt;</li> <li><code>sprintf</code><code>(</code><code>fmt</code>, <code>*args</code><code>)</code> (Any) \u2014 Format a string&lt;/&gt;</li> <li><code>sqrt</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the square root of a vector&lt;/&gt;</li> <li><code>startswith</code><code>(</code><code>x</code>, <code>prefix</code><code>)</code> (Any) \u2014 Does x start with prefix&lt;/&gt;</li> <li><code>strsplit</code><code>(</code><code>x</code>, <code>split</code>, <code>fixed</code>, <code>perl</code>, <code>use_bytes</code><code>)</code> (Any) \u2014 Split a string&lt;/&gt;</li> <li><code>strtoi</code><code>(</code><code>x</code>, <code>base</code><code>)</code> (Any) \u2014 Convert a string to an integer&lt;/&gt;</li> <li><code>sub</code><code>(</code><code>pattern</code>, <code>replacement</code>, <code>x</code>, <code>ignore_case</code>, <code>fixed</code><code>)</code> (Any) \u2014 Substitute a pattern&lt;/&gt;</li> <li><code>substr</code><code>(</code><code>x</code>, <code>start</code>, <code>stop</code><code>)</code> (Any) \u2014 Get a substring&lt;/&gt;</li> <li><code>substring</code><code>(</code><code>x</code>, <code>first</code>, <code>last</code><code>)</code> (Any) \u2014 Get a substring&lt;/&gt;</li> <li><code>sum_</code><code>(</code><code>x</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the sum of a vector&lt;/&gt;</li> <li><code>t</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the transpose&lt;/&gt;</li> <li><code>table</code><code>(</code><code>x</code>, <code>*more</code>, <code>exclude</code>, <code>use_na</code>, <code>dnn</code>, <code>deparse_level</code><code>)</code> (Any) \u2014 Get the table of a vector&lt;/&gt;</li> <li><code>tabulate</code><code>(</code><code>bin</code>, <code>nbins</code><code>)</code> (Any) \u2014 Get the table of a vector&lt;/&gt;</li> <li><code>tail</code><code>(</code><code>x</code>, <code>n</code><code>)</code> (Any) \u2014 Get the last n rows&lt;/&gt;</li> <li><code>tan</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the tangent&lt;/&gt;</li> <li><code>tanh</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the hyperbolic tangent&lt;/&gt;</li> <li><code>tanpi</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the tangent of pi times x&lt;/&gt;</li> <li><code>tolower</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a string to lower case&lt;/&gt;</li> <li><code>toupper</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Convert a string to upper case&lt;/&gt;</li> <li><code>trigamma</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Compute the trigamma function&lt;/&gt;</li> <li><code>trimws</code><code>(</code><code>x</code>, <code>which</code>, <code>whitespace</code><code>)</code> (Any) \u2014 Trim whitespace from a string&lt;/&gt;</li> <li><code>trunc</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Truncate the values of a vector&lt;/&gt;</li> <li><code>union</code><code>(</code><code>x</code>, <code>y</code><code>)</code> (Any) \u2014 Get the union of two vectors&lt;/&gt;</li> <li><code>unique</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the unique values&lt;/&gt;</li> <li><code>var</code><code>(</code><code>x</code>, <code>na_rm</code>, <code>ddof</code><code>)</code> (Any) \u2014 Compute the variance of a vector&lt;/&gt;</li> <li><code>weighted_mean</code><code>(</code><code>x</code>, <code>w</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Compute the weighted mean of a vector&lt;/&gt;</li> <li><code>which</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the indices of the non-zero values&lt;/&gt;</li> <li><code>which_max</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the index of the maximum value&lt;/&gt;</li> <li><code>which_min</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Get the index of the minimum value&lt;/&gt;</li> </ul>"},{"location":"api/datar.apis/#datarapis","title":"datar.apis","text":""},{"location":"api/datar.apis/#datarapisbase","title":"datar.apis.base","text":""},{"location":"api/datar.apis.misc/","title":"datar.apis.misc","text":"module &lt;/&gt; Functions <ul> <li><code>array_ufunc</code><code>(</code><code>x</code>, <code>ufunc</code>, <code>*args</code>, <code>kind</code>, <code>**kwargs</code><code>)</code> \u2014 Implement the array ufunc&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Implement the array ufunc</p><p>Allow other backends to override the behavior of the ufunc on different types of data.</p>"},{"location":"api/datar.apis.misc/#datarapismisc","title":"datar.apis.misc","text":""},{"location":"api/datar.apis.misc/#datarapismiscarray_ufunc","title":"<code>datar.apis.misc.</code><code>array_ufunc</code><code>(</code><code>x</code>, <code>ufunc</code>, <code>*args</code>, <code>kind</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.tibble/","title":"datar.apis.tibble","text":"module &lt;/&gt; Functions <ul> <li><code>add_column</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_before</code>, <code>_after</code>, <code>_name_repair</code>, <code>_dtypes</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Add one or more columns to an existing data frame.&lt;/&gt;</li> <li><code>add_row</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_before</code>, <code>_after</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Add one or more rows of data to an existing data frame.&lt;/&gt;</li> <li><code>as_tibble</code><code>(</code><code>df</code><code>)</code> (Any) \u2014 Convert a DataFrame object to Tibble object&lt;/&gt;</li> <li><code>column_to_rownames</code><code>(</code><code>_data</code>, <code>var</code><code>)</code> (Any) \u2014 Set rownames/index with one column, and remove it&lt;/&gt;</li> <li><code>deframe</code><code>(</code><code>x</code><code>)</code> (Any) \u2014 Converts two-column data frames to a dictionaryusing the first column as name and the second column as value. If the input has only one column, a list. &lt;/&gt;</li> <li><code>enframe</code><code>(</code><code>x</code>, <code>name</code>, <code>value</code><code>)</code> (Any) \u2014 Converts mappings or lists to one- or two-column data frames.&lt;/&gt;</li> <li><code>has_rownames</code><code>(</code><code>_data</code><code>)</code> (bool) \u2014 Detect if a data frame has row names&lt;/&gt;</li> <li><code>remove_rownames</code><code>(</code><code>_data</code><code>)</code> (Any) \u2014 Remove the index/rownames of a data frame&lt;/&gt;</li> <li><code>rowid_to_column</code><code>(</code><code>_data</code>, <code>var</code><code>)</code> (Any) \u2014 Add rownames as a column&lt;/&gt;</li> <li><code>rownames_to_column</code><code>(</code><code>_data</code>, <code>var</code><code>)</code> (Any) \u2014 Add rownames as a column&lt;/&gt;</li> <li><code>tibble</code><code>(</code><code>*args</code>, <code>_name_repair</code>, <code>_rows</code>, <code>_dtypes</code>, <code>_drop_index</code>, <code>_index</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Constructs a data frame&lt;/&gt;</li> <li><code>tibble_row</code><code>(</code><code>*args</code>, <code>_name_repair</code>, <code>_dtypes</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Constructs a data frame that is guaranteed to occupy one row.Scalar values will be wrapped with <code>[]</code> &lt;/&gt;</li> <li><code>tribble</code><code>(</code><code>*dummies</code>, <code>_name_repair</code>, <code>_dtypes</code><code>)</code> (Any) \u2014 Create dataframe using an easier to read row-by-row layoutUnlike original API that uses formula (<code>f.col</code>) to indicate the column names, we use <code>f.col</code> to indicate them. &lt;/&gt;</li> </ul> function &lt;/&gt; <p>Constructs a data frame</p> Parameters <ul> <li><code>*args</code> \u2014 and</li> <li><code>_name_repair</code> (Union, optional) \u2014 treatment of problematic column names:<ul><li>- \"minimal\": No name repair or checks, beyond basic existence,</li><li>- \"unique\": Make sure names are unique and not empty,</li><li>- \"check_unique\": (default value), no name repair,\u00a0    but check they are unique,</li><li>- \"universal\": Make the names unique and syntactic</li><li>- a function: apply custom name repair</li></ul></li> <li><code>_rows</code> (int, optional) \u2014 Number of rows of a 0-col dataframe when args and kwargs arenot provided. When args or kwargs are provided, this is ignored. </li> <li><code>_dtypes</code> (optional) \u2014 The dtypes for each columns to convert to.</li> <li><code>_drop_index</code> (bool, optional) \u2014 Whether drop the index for the final data frame</li> <li><code>_index</code> (optional) \u2014 The new index of the output frame</li> <li><code>**kwargs</code> \u2014 A set of name-value pairs.</li> </ul> Returns (Any) <p>A constructed tibble</p> function &lt;/&gt; <p>Create dataframe using an easier to read row-by-row layoutUnlike original API that uses formula (<code>f.col</code>) to indicate the column names, we use <code>f.col</code> to indicate them.</p> Parameters <ul> <li><code>*dummies</code> \u2014 Arguments specifying the structure of a dataframeVariable names should be specified with <code>f.name</code> </li> <li><code>_dtypes</code> (optional) \u2014 The dtypes for each columns to convert to.</li> </ul> Examples <pre><code>&gt;&gt;&gt; tribble(&gt;&gt;&gt;     f.colA, f.colB,\n&gt;&gt;&gt;     \"a\",    1,\n&gt;&gt;&gt;     \"b\",    2,\n&gt;&gt;&gt;     \"c\",    3,\n&gt;&gt;&gt; )\n</code></pre> Returns (Any) <p>A dataframe</p> function &lt;/&gt; <p>Constructs a data frame that is guaranteed to occupy one row.Scalar values will be wrapped with <code>[]</code></p> Parameters <ul> <li><code>*args</code> \u2014 and</li> <li><code>_name_repair</code> (Union, optional) \u2014 treatment of problematic column names:<ul><li>- \"minimal\": No name repair or checks, beyond basic existence,</li><li>- \"unique\": Make sure names are unique and not empty,</li><li>- \"check_unique\": (default value), no name repair,\u00a0    but check they are unique,</li><li>- \"universal\": Make the names unique and syntactic</li><li>- a function: apply custom name repair</li></ul></li> <li><code>**kwargs</code> \u2014 A set of name-value pairs.</li> </ul> Returns (Any) <p>A constructed dataframe</p> function &lt;/&gt; <p>Convert a DataFrame object to Tibble object</p> function &lt;/&gt; <p>Converts mappings or lists to one- or two-column data frames.</p> Parameters <ul> <li><code>x</code> \u2014 a list, a dictionary or a dataframe with one or two columns</li> <li><code>name</code> (optional) \u2014 and</li> <li><code>value</code> (optional) \u2014 value Names of the columns that store the names and values.If <code>None</code>, a one-column dataframe is returned. <code>value</code> cannot be <code>None</code> </li> </ul> Returns (Any) <p>A data frame with two columns if <code>name</code> is not None (default) orone-column otherwise.</p> function &lt;/&gt; <p>Converts two-column data frames to a dictionaryusing the first column as name and the second column as value. If the input has only one column, a list.</p> Parameters <ul> <li><code>x</code> \u2014 A data frame.</li> </ul> Returns (Any) <p>A dictionary or a list if only one column in the data frame.</p> function &lt;/&gt; <p>Add one or more rows of data to an existing data frame.</p><p>Aliases <code>add_case</code></p> Parameters <ul> <li><code>_data</code> \u2014 Data frame to append to.</li> <li><code>*args</code> \u2014 and</li> <li><code>_before</code> (optional) \u2014 and</li> <li><code>_after</code> (optional) \u2014 row index where to add the new rows.(default to add after the last row) </li> <li><code>**kwargs</code> \u2014 Name-value pairs to add to the data frame.</li> </ul> Returns (Any) <p>The dataframe with the added rows</p> function &lt;/&gt; <p>Add one or more columns to an existing data frame.</p> Parameters <ul> <li><code>_data</code> \u2014 Data frame to append to</li> <li><code>*args</code> \u2014 and</li> <li><code>_before</code> (optional) \u2014 and</li> <li><code>_after</code> (optional) \u2014 Column index or name where to add the new columns(default to add after the last column) </li> <li><code>_dtypes</code> (optional) \u2014 The dtypes for the new columns, either a uniform dtype or adict of dtypes with keys the column names </li> <li><code>**kwargs</code> \u2014 Name-value pairs to add to the data frame</li> </ul> Returns (Any) <p>The dataframe with the added columns</p> function &lt;/&gt; <p>Detect if a data frame has row names</p><p>Aliases <code>has_index</code></p> Parameters <ul> <li><code>_data</code> \u2014 The data frame to check</li> </ul> Returns (bool) <p>True if the data frame has index otherwise False.</p> function &lt;/&gt; <p>Remove the index/rownames of a data frame</p><p>Aliases <code>remove_index</code>, <code>drop_index</code>, <code>remove_rownames</code></p> Parameters <ul> <li><code>_data</code> \u2014 The data frame</li> </ul> Returns (Any) <p>The data frame with index removed</p> function &lt;/&gt; <p>Add rownames as a column</p><p>Aliases <code>index_to_column</code></p> Parameters <ul> <li><code>_data</code> \u2014 The data frame</li> <li><code>var</code> (optional) \u2014 The name of the column</li> </ul> Returns (Any) <p>The data frame with rownames added as one column. Note that theoriginal index is removed.</p> function &lt;/&gt; <p>Add rownames as a column</p> Parameters <ul> <li><code>_data</code> \u2014 The data frame</li> <li><code>var</code> (optional) \u2014 The name of the column</li> </ul> Returns (Any) <p>The data frame with row ids added as one column.</p> function &lt;/&gt; <p>Set rownames/index with one column, and remove it</p><p>Aliases <code>column_to_index</code></p> Parameters <ul> <li><code>_data</code> \u2014 The data frame</li> <li><code>var</code> (optional) \u2014 The column to conver to the rownames</li> </ul> Returns (Any) <p>The data frame with the column converted to rownames</p>"},{"location":"api/datar.apis.tibble/#datarapistibble","title":"datar.apis.tibble","text":""},{"location":"api/datar.apis.tibble/#datarapistibbletibble","title":"<code>datar.apis.tibble.</code><code>tibble</code><code>(</code><code>*args</code>, <code>_name_repair='check_unique'</code>, <code>_rows=None</code>, <code>_dtypes=None</code>, <code>_drop_index=False</code>, <code>_index=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.tibble/#datarapistibbletribble","title":"<code>datar.apis.tibble.</code><code>tribble</code><code>(</code><code>*dummies</code>, <code>_name_repair='minimal'</code>, <code>_dtypes=None</code><code>)</code>","text":""},{"location":"api/datar.apis.tibble/#datarapistibbletibble_row","title":"<code>datar.apis.tibble.</code><code>tibble_row</code><code>(</code><code>*args</code>, <code>_name_repair='check_unique'</code>, <code>_dtypes=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.tibble/#datarapistibbleas_tibble","title":"<code>datar.apis.tibble.</code><code>as_tibble</code><code>(</code><code>df</code><code>)</code> \u2192 Any","text":""},{"location":"api/datar.apis.tibble/#datarapistibbleenframe","title":"<code>datar.apis.tibble.</code><code>enframe</code><code>(</code><code>x</code>, <code>name='name'</code>, <code>value='value'</code><code>)</code>","text":""},{"location":"api/datar.apis.tibble/#datarapistibbledeframe","title":"<code>datar.apis.tibble.</code><code>deframe</code><code>(</code><code>x</code><code>)</code>","text":""},{"location":"api/datar.apis.tibble/#datarapistibbleadd_row","title":"<code>datar.apis.tibble.</code><code>add_row</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_before=None</code>, <code>_after=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.tibble/#datarapistibbleadd_column","title":"<code>datar.apis.tibble.</code><code>add_column</code><code>(</code><code>_data</code>, <code>*args</code>, <code>_before=None</code>, <code>_after=None</code>, <code>_name_repair='check_unique'</code>, <code>_dtypes=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.tibble/#datarapistibblehas_rownames","title":"<code>datar.apis.tibble.</code><code>has_rownames</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.tibble/#datarapistibbleremove_rownames","title":"<code>datar.apis.tibble.</code><code>remove_rownames</code><code>(</code><code>_data</code><code>)</code>","text":""},{"location":"api/datar.apis.tibble/#datarapistibblerownames_to_column","title":"<code>datar.apis.tibble.</code><code>rownames_to_column</code><code>(</code><code>_data</code>, <code>var='rowname'</code><code>)</code>","text":""},{"location":"api/datar.apis.tibble/#datarapistibblerowid_to_column","title":"<code>datar.apis.tibble.</code><code>rowid_to_column</code><code>(</code><code>_data</code>, <code>var='rowid'</code><code>)</code>","text":""},{"location":"api/datar.apis.tibble/#datarapistibblecolumn_to_rownames","title":"<code>datar.apis.tibble.</code><code>column_to_rownames</code><code>(</code><code>_data</code>, <code>var='rowname'</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/","title":"datar.apis.tidyr","text":"module &lt;/&gt; Functions <ul> <li><code>chop</code><code>(</code><code>data</code>, <code>cols</code><code>)</code> (Any) \u2014 Makes data frame shorter by converting rows within each groupinto list-columns. &lt;/&gt;</li> <li><code>complete</code><code>(</code><code>data</code>, <code>*args</code>, <code>fill</code>, <code>explict</code><code>)</code> (Any) \u2014 Turns implicit missing values into explicit missing values.&lt;/&gt;</li> <li><code>crossing</code><code>(</code><code>*args</code>, <code>_name_repair</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 A wrapper around <code>expand_grid()</code> that de-duplicates and sorts its inputs&lt;/&gt;</li> <li><code>drop_na</code><code>(</code><code>_data</code>, <code>*columns</code>, <code>_how</code><code>)</code> (Any) \u2014 Drop rows containing missing values&lt;/&gt;</li> <li><code>expand</code><code>(</code><code>data</code>, <code>*args</code>, <code>_name_repair</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 Generates all combination of variables found in a dataset.&lt;/&gt;</li> <li><code>extract</code><code>(</code><code>data</code>, <code>col</code>, <code>into</code>, <code>regex</code>, <code>remove</code>, <code>convert</code><code>)</code> (Any) \u2014 Given a regular expression with capturing groups, extract() turns eachgroup into a new column. If the groups don't match, or the input is NA, the output will be NA. &lt;/&gt;</li> <li><code>fill</code><code>(</code><code>_data</code>, <code>*columns</code>, <code>_direction</code><code>)</code> (Any) \u2014 Fills missing values in selected columns using the next orprevious entry. &lt;/&gt;</li> <li><code>full_seq</code><code>(</code><code>x</code>, <code>period</code>, <code>tol</code><code>)</code> (Any) \u2014 Create the full sequence of values in a vector&lt;/&gt;</li> <li><code>nest</code><code>(</code><code>_data</code>, <code>_names_sep</code>, <code>**cols</code><code>)</code> (Any) \u2014 Nesting creates a list-column of data frames&lt;/&gt;</li> <li><code>nesting</code><code>(</code><code>*args</code>, <code>_name_repair</code>, <code>**kwargs</code><code>)</code> (Any) \u2014 A helper that only finds combinations already present in the data.&lt;/&gt;</li> <li><code>pack</code><code>(</code><code>_data</code>, <code>_names_sep</code>, <code>**cols</code><code>)</code> (Any) \u2014 Makes df narrow by collapsing a set of columns into a single df-column.&lt;/&gt;</li> <li><code>pivot_longer</code><code>(</code><code>_data</code>, <code>cols</code>, <code>names_to</code>, <code>names_prefix</code>, <code>names_sep</code>, <code>names_pattern</code>, <code>names_dtypes</code>, <code>names_transform</code>, <code>names_repair</code>, <code>values_to</code>, <code>values_drop_na</code>, <code>values_dtypes</code>, <code>values_transform</code><code>)</code> (Any) \u2014 \"lengthens\" data, increasing the number of rows anddecreasing the number of columns. &lt;/&gt;</li> <li><code>pivot_wider</code><code>(</code><code>_data</code>, <code>id_cols</code>, <code>names_from</code>, <code>names_prefix</code>, <code>names_sep</code>, <code>names_glue</code>, <code>names_sort</code>, <code>values_from</code>, <code>values_fill</code>, <code>values_fn</code><code>)</code> (Any) \u2014 \"widens\" data, increasing the number of columns and decreasingthe number of rows. &lt;/&gt;</li> <li><code>replace_na</code><code>(</code><code>data</code>, <code>data_or_replace</code>, <code>replace</code><code>)</code> (Any) \u2014 Replace NA with a value&lt;/&gt;</li> <li><code>separate</code><code>(</code><code>data</code>, <code>col</code>, <code>into</code>, <code>sep</code>, <code>remove</code>, <code>convert</code>, <code>extra</code>, <code>fill</code><code>)</code> (Any) \u2014 Given either a regular expression or a vector of character positions,turns a single character column into multiple columns. &lt;/&gt;</li> <li><code>separate_rows</code><code>(</code><code>data</code>, <code>*columns</code>, <code>sep</code>, <code>convert</code><code>)</code> (Any) \u2014 Separates the values and places each one in its own row.&lt;/&gt;</li> <li><code>unchop</code><code>(</code><code>data</code>, <code>cols</code>, <code>keep_empty</code>, <code>dtypes</code><code>)</code> (Any) \u2014 Makes df longer by expanding list-columns so that each elementof the list-column gets its own row in the output. &lt;/&gt;</li> <li><code>uncount</code><code>(</code><code>data</code>, <code>weights</code>, <code>_remove</code>, <code>_id</code><code>)</code> (Any) \u2014 Duplicating rows according to a weighting variable&lt;/&gt;</li> <li><code>unite</code><code>(</code><code>data</code>, <code>col</code>, <code>*columns</code>, <code>sep</code>, <code>remove</code>, <code>na_rm</code><code>)</code> (Any) \u2014 Unite multiple columns into one by pasting strings together&lt;/&gt;</li> <li><code>unnest</code><code>(</code><code>data</code>, <code>*cols</code>, <code>keep_empty</code>, <code>dtypes</code>, <code>names_sep</code>, <code>names_repair</code><code>)</code> (Any) \u2014 Flattens list-column of data frames back out into regular columns.&lt;/&gt;</li> <li><code>unpack</code><code>(</code><code>data</code>, <code>cols</code>, <code>names_sep</code>, <code>names_repair</code><code>)</code> (Any) \u2014 Makes df wider by expanding df-columns back out into individual columns.&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Create the full sequence of values in a vector</p> Parameters <ul> <li><code>x</code> \u2014 A numeric vector.</li> <li><code>period</code> \u2014 Gap between each observation. The existing data will bechecked to ensure that it is actually of this periodicity. </li> <li><code>tol</code> (optional) \u2014 Numerical tolerance for checking periodicity.</li> </ul> Returns (Any) <p>The full sequence</p> function &lt;/&gt; <p>Makes data frame shorter by converting rows within each groupinto list-columns.</p> Parameters <ul> <li><code>data</code> \u2014 A data frame</li> <li><code>cols</code> (optional) \u2014 Columns to chop</li> </ul> Returns (Any) <p>Data frame with selected columns chopped</p> function &lt;/&gt; <p>Makes df longer by expanding list-columns so that each elementof the list-column gets its own row in the output.</p> <p>See https://tidyr.tidyverse.org/reference/chop.html</p> <p>Recycling size-1 elements might be different from <code>tidyr</code> <pre><code>&gt;&gt;&gt; df = tibble(x=[1, [2,3]], y=[[2,3], 1])\n&gt;&gt;&gt; df &gt;&gt; unchop([f.x, f.y])\n&gt;&gt;&gt; # tibble(x=[1,2,3], y=[2,3,1])\n&gt;&gt;&gt; # instead of following in tidyr\n&gt;&gt;&gt; # tibble(x=[1,1,2,3], y=[2,3,1,1])\n</code></pre></p> Parameters <ul> <li><code>data</code> \u2014 A data frame.</li> <li><code>cols</code> (optional) \u2014 Columns to unchop.</li> <li><code>keep_empty</code> (bool, optional) \u2014 By default, you get one row of output for each elementof the list your unchopping/unnesting. This means that if there's a size-0 element (like NULL or an empty data frame), that entire row will be dropped from the output. If you want to preserve all rows, use <code>keep_empty</code> = <code>True</code> to replace size-0 elements with a single row of missing values. </li> <li><code>dtypes</code> (optional) \u2014 Providing the dtypes for the output columns.Could be a single dtype, which will be applied to all columns, or a dictionary of dtypes with keys for the columns and values the dtypes. For nested data frames, we need to specify <code>col$a</code> as key. If <code>col</code> is used as key, all columns of the nested data frames will be casted into that dtype. </li> </ul> Returns (Any) <p>A data frame with selected columns unchopped.</p> function &lt;/&gt; <p>Nesting creates a list-column of data frames</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>_names_sep</code> (str, optional) \u2014 If <code>None</code>, the default, the names will be left as is.Inner names will come from the former outer names If a string, the inner and outer names will be used together. The names of the new outer columns will be formed by pasting together the outer and the inner column names, separated by <code>_names_sep</code>. </li> <li><code>**cols</code> (str | int) \u2014 Columns to nest</li> </ul> Returns (Any) <p>Nested data frame.</p> function &lt;/&gt; <p>Flattens list-column of data frames back out into regular columns.</p> Parameters <ul> <li><code>data</code> \u2014 A data frame to flatten.</li> <li><code>*cols</code> (str | int) \u2014 Columns to unnest.</li> <li><code>keep_empty</code> (bool, optional) \u2014 By default, you get one row of output for each elementof the list your unchopping/unnesting. This means that if there's a size-0 element (like NULL or an empty data frame), that entire row will be dropped from the output. If you want to preserve all rows, use <code>keep_empty</code> = <code>True</code> to replace size-0 elements with a single row of missing values. </li> <li><code>dtypes</code> (optional) \u2014 Providing the dtypes for the output columns.Could be a single dtype, which will be applied to all columns, or a dictionary of dtypes with keys for the columns and values the dtypes. </li> <li><code>names_sep</code> (str, optional) \u2014 If <code>None</code>, the default, the names will be left as is.Inner names will come from the former outer names If a string, the inner and outer names will be used together. The names of the new outer columns will be formed by pasting together the outer and the inner column names, separated by <code>names_sep</code>. </li> <li><code>names_repair</code> (Union, optional) \u2014 treatment of problematic column names:<ul><li>- \"minimal\": No name repair or checks, beyond basic existence,</li><li>- \"unique\": Make sure names are unique and not empty,</li><li>- \"check_unique\": (default value), no name repair,\u00a0    but check they are unique,</li><li>- \"universal\": Make the names unique and syntactic</li><li>- a function: apply custom name repair</li></ul></li> </ul> Returns (Any) <p>Data frame with selected columns unnested.</p> function &lt;/&gt; <p>Makes df narrow by collapsing a set of columns into a single df-column.</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame</li> <li><code>_names_sep</code> (str, optional) \u2014 If <code>None</code>, the default, the names will be left as is.Inner names will come from the former outer names If a string, the inner and outer names will be used together. The names of the new outer columns will be formed by pasting together the outer and the inner column names, separated by <code>_names_sep</code>. </li> <li><code>**cols</code> (str | int) \u2014 Columns to pack</li> </ul> function &lt;/&gt; <p>Makes df wider by expanding df-columns back out into individual columns.</p><p>For empty columns, the column is kept asis, instead of removing it.</p> Parameters <ul> <li><code>data</code> \u2014 A data frame</li> <li><code>cols</code> \u2014 Columns to unpack</li> <li><code>names_sep</code> (str, optional) \u2014 If <code>None</code>, the default, the names will be left as is.Inner names will come from the former outer names If a string, the inner and outer names will be used together. The names of the new outer columns will be formed by pasting together the outer and the inner column names, separated by <code>_names_sep</code>. </li> <li><code>name_repair</code> \u2014 treatment of problematic column names:<ul><li>- \"minimal\": No name repair or checks, beyond basic existence,</li><li>- \"unique\": Make sure names are unique and not empty,</li><li>- \"check_unique\": (default value), no name repair,\u00a0    but check they are unique,</li><li>- \"universal\": Make the names unique and syntactic</li><li>- a function: apply custom name repair</li></ul></li> </ul> Returns (Any) <p>Data frame with given columns unpacked.</p> function &lt;/&gt; <p>Generates all combination of variables found in a dataset.</p> Parameters <ul> <li><code>data</code> \u2014 A data frame</li> <li><code>*args</code> \u2014 and,</li> <li><code>_name_repair</code> (Union, optional) \u2014 treatment of problematic column names:<ul><li>- \"minimal\": No name repair or checks, beyond basic existence,</li><li>- \"unique\": Make sure names are unique and not empty,</li><li>- \"check_unique\": (default value), no name repair,\u00a0    but check they are unique,</li><li>- \"universal\": Make the names unique and syntactic</li><li>- a function: apply custom name repair</li></ul></li> <li><code>**kwargs</code> \u2014 columns to expand. Columns can be atomic lists.<ul><li>- To find all unique combinations of x, y and z, including\u00a0  those not present in the data, supply each variable as a\u00a0  separate argument: <code>expand(df, x, y, z)</code>.</li><li>- To find only the combinations that occur in the data, use\u00a0  nesting: <code>expand(df, nesting(x, y, z))</code>.</li><li>- You can combine the two forms. For example, <code>expand(df, nesting(school_id, student_id), date)</code> would\u00a0  produce a row for each present school-student combination\u00a0  for all possible dates.</li></ul></li> </ul> Returns (Any) <p>A data frame with all combination of variables.</p> function &lt;/&gt; <p>A helper that only finds combinations already present in the data.</p> Parameters <ul> <li><code>*args</code> \u2014 and,</li> <li><code>_name_repair</code> (Union, optional) \u2014 treatment of problematic column names:<ul><li>- \"minimal\": No name repair or checks, beyond basic existence,</li><li>- \"unique\": Make sure names are unique and not empty,</li><li>- \"check_unique\": (default value), no name repair,\u00a0    but check they are unique,</li><li>- \"universal\": Make the names unique and syntactic</li><li>- a function: apply custom name repair</li></ul></li> <li><code>**kwargs</code> \u2014 columns to expand. Columns can be atomic lists.<ul><li>- To find all unique combinations of x, y and z, including\u00a0  those not present in the data, supply each variable as a\u00a0  separate argument: <code>expand(df, x, y, z)</code>.</li><li>- To find only the combinations that occur in the data, use\u00a0  nesting: <code>expand(df, nesting(x, y, z))</code>.</li><li>- You can combine the two forms. For example, <code>expand(df, nesting(school_id, student_id), date)</code> would\u00a0  produce a row for each present school-student combination\u00a0  for all possible dates.</li></ul></li> </ul> Returns (Any) <p>A data frame with all combinations in data.</p> function &lt;/&gt; <p>A wrapper around <code>expand_grid()</code> that de-duplicates and sorts its inputs</p><p>When values are not specified by literal <code>list</code>, they will be sorted.</p> Parameters <ul> <li><code>*args</code> \u2014 and,</li> <li><code>_name_repair</code> (Union, optional) \u2014 treatment of problematic column names:<ul><li>- \"minimal\": No name repair or checks, beyond basic existence,</li><li>- \"unique\": Make sure names are unique and not empty,</li><li>- \"check_unique\": (default value), no name repair,\u00a0    but check they are unique,</li><li>- \"universal\": Make the names unique and syntactic</li><li>- a function: apply custom name repair</li></ul></li> <li><code>**kwargs</code> \u2014 columns to expand. Columns can be atomic lists.<ul><li>- To find all unique combinations of x, y and z, including\u00a0  those not present in the data, supply each variable as a\u00a0  separate argument: <code>expand(df, x, y, z)</code>.</li><li>- To find only the combinations that occur in the data, use\u00a0  nesting: <code>expand(df, nesting(x, y, z))</code>.</li><li>- You can combine the two forms. For example, <code>expand(df, nesting(school_id, student_id), date)</code> would\u00a0  produce a row for each present school-student combination\u00a0  for all possible dates.</li></ul></li> </ul> Returns (Any) <p>A data frame with values deduplicated and sorted.</p> function &lt;/&gt; <p>Turns implicit missing values into explicit missing values.</p> Parameters <ul> <li><code>data</code> \u2014 A data frame</li> <li><code>*args</code> \u2014 columns to expand. Columns can be atomic lists.<ul><li>- To find all unique combinations of x, y and z, including\u00a0  those not present in the data, supply each variable as a\u00a0  separate argument: <code>expand(df, x, y, z)</code>.</li><li>- To find only the combinations that occur in the data, use\u00a0  nesting: <code>expand(df, nesting(x, y, z))</code>.</li><li>- You can combine the two forms. For example, <code>expand(df, nesting(school_id, student_id), date)</code> would\u00a0  produce a row for each present school-student combination\u00a0  for all possible dates.</li></ul></li> <li><code>fill</code> (optional) \u2014 A named list that for each variable supplies a single valueto use instead of NA for missing combinations. </li> <li><code>explict</code> (bool, optional) \u2014 Should both implicit (newly created) and explicit(pre-existing) missing values be filled by fill? By default, this is TRUE, but if set to FALSE this will limit the fill to only implicit missing values. </li> </ul> Returns (Any) <p>Data frame with missing values completed</p> function &lt;/&gt; <p>Drop rows containing missing values</p><p>See https://tidyr.tidyverse.org/reference/drop_na.html</p> Parameters <ul> <li><code>*columns</code> (str) \u2014 Columns to inspect for missing values.</li> <li><code>_how</code> (str, optional) \u2014 How to select the rows to drop<ul><li>- all: All columns of <code>columns</code> to be <code>NA</code>s</li><li>- any: Any columns of <code>columns</code> to be <code>NA</code>s</li></ul>(tidyr doesn't support this argument)</li> <li><code>data</code> \u2014 A data frame.</li> </ul> Returns (Any) <p>Dataframe with rows with NAs dropped and indexes dropped</p> function &lt;/&gt; <p>Given a regular expression with capturing groups, extract() turns eachgroup into a new column. If the groups don't match, or the input is NA, the output will be NA.</p> <p>See https://tidyr.tidyverse.org/reference/extract.html</p> Parameters <ul> <li><code>data</code> \u2014 The dataframe</li> <li><code>col</code> (str | int) \u2014 Column name or position.</li> <li><code>into</code> \u2014 Names of new variables to create as character vector.Use None to omit the variable in the output. </li> <li><code>regex</code> (str, optional) \u2014 a regular expression used to extract the desired values.There should be one group (defined by ()) for each element of into. </li> <li><code>remove</code> (bool, optional) \u2014 If TRUE, remove input column from output data frame.</li> <li><code>convert</code> (optional) \u2014 The universal type for the extracted columns or a dict forindividual ones </li> </ul> Returns (Any) <p>Dataframe with extracted columns.</p> function &lt;/&gt; <p>Fills missing values in selected columns using the next orprevious entry.</p> <p>See https://tidyr.tidyverse.org/reference/fill.html</p> Parameters <ul> <li><code>_data</code> \u2014 A dataframe</li> <li><code>*columns</code> (str | int) \u2014 Columns to fill</li> <li><code>_direction</code> (str, optional) \u2014 Direction in which to fill missing values.Currently either \"down\" (the default), \"up\", \"downup\" (i.e. first down and then up) or \"updown\" (first up and then down). </li> </ul> Returns (Any) <p>The dataframe with NAs being replaced.</p> function &lt;/&gt; <p>\"lengthens\" data, increasing the number of rows anddecreasing the number of columns.</p> <p>The row order is a bit different from <code>tidyr</code> and <code>pandas.DataFrame.melt</code>. <pre><code>&gt;&gt;&gt; df = tibble(x=c[1:2], y=c[3:4])\n&gt;&gt;&gt; pivot_longer(df, f[f.x:f.y])\n&gt;&gt;&gt; #    name   value\n&gt;&gt;&gt; # 0  x      1\n&gt;&gt;&gt; # 1  x      2\n&gt;&gt;&gt; # 2  y      3\n&gt;&gt;&gt; # 3  y      4\nwith `tidyr::pivot_longer`, the output will be:\n&gt;&gt;&gt; # # A tibble: 4 x 2\n&gt;&gt;&gt; # name  value\n&gt;&gt;&gt; # &lt;chr&gt; &lt;int&gt;\n&gt;&gt;&gt; # 1 x   1\n&gt;&gt;&gt; # 2 y   3\n&gt;&gt;&gt; # 3 x   2\n&gt;&gt;&gt; # 4 y   4\n</code></pre></p> Parameters <ul> <li><code>_data</code> \u2014 A data frame to pivot.</li> <li><code>cols</code> \u2014 Columns to pivot into longer format.</li> <li><code>names_to</code> (optional) \u2014 A string specifying the name of the column to create fromthe data stored in the column names of data. Can be a character vector, creating multiple columns, if names_sep or names_pattern is provided. In this case, there are two special values you can take advantage of: <ul><li>- <code>None</code>/<code>NA</code>/<code>NULL</code> will discard that component of the name.</li><li>- <code>.value</code>/<code>_value</code> indicates that component of the name defines\u00a0    the name of the column containing the cell values,\u00a0    overriding values_to.</li><li>- Different as <code>tidyr</code>: With <code>.value</code>/<code>_value</code>, if there are other\u00a0  parts of the names to distinguish the groups, they must be\u00a0  captured. For example, use <code>r'(\\w)_(\\d)'</code> to match <code>'a_1'</code> and <code>['.value', NA]</code> to discard the suffix, instead of use <code>r'(\\w)_\\d'</code> to match.</li></ul></li> <li><code>names_prefix</code> (str, optional) \u2014 A regular expression used to remove matching text fromthe start of each variable name. </li> <li><code>names_sep</code> (str, optional) \u2014 and</li> <li><code>names_pattern</code> (str, optional) \u2014 takes the same specification as extract(),a regular expression containing matching groups (()). </li> <li><code>names_dtypes</code> (optional) \u2014 and</li> <li><code>names_transform</code> (Union, optional) \u2014 and</li> <li><code>names_repair</code> (optional) \u2014 treatment of problematic column names:<ul><li>- \"minimal\": No name repair or checks, beyond basic existence,</li><li>- \"unique\": Make sure names are unique and not empty,</li><li>- \"check_unique\": (default value), no name repair,\u00a0    but check they are unique,</li><li>- \"universal\": Make the names unique and syntactic</li><li>- a function: apply custom name repair</li></ul></li> <li><code>values_to</code> (str, optional) \u2014 A string specifying the name of the column to create fromthe data stored in cell values. If names_to is a character containing the special <code>.value</code>/<code>_value</code> sentinel, this value will be ignored, and the name of the value column will be derived from part of the existing column names. </li> <li><code>values_drop_na</code> (bool, optional) \u2014 If TRUE, will drop rows that contain only NAs inthe value_to column. This effectively converts explicit missing values to implicit missing values, and should generally be used only when missing values in data were created by its structure. </li> <li><code>values_dtypes</code> (optional) \u2014 A list of column name-prototype pairs.A prototype (or dtypes for short) is a zero-length vector (like integer() or numeric()) that defines the type, class, and attributes of a vector. Use these arguments if you want to confirm that the created columns are the types that you expect. Note that if you want to change (instead of confirm) the types of specific columns, you should use names_transform or values_transform instead. </li> <li><code>values_transform</code> (Union, optional) \u2014 A list of column name-function pairs.Use these arguments if you need to change the types of specific columns. For example, names_transform = dict(week = as.integer) would convert a character variable called week to an integer. If not specified, the type of the columns generated from names_to will be character, and the type of the variables generated from values_to will be the common type of the input columns used to generate them. </li> </ul> Returns (Any) <p>The pivoted dataframe.</p> function &lt;/&gt; <p>\"widens\" data, increasing the number of columns and decreasingthe number of rows.</p> Parameters <ul> <li><code>_data</code> \u2014 A data frame to pivot.</li> <li><code>id_cols</code> (optional) \u2014 A set of columns that uniquely identifies each observation.Defaults to all columns in data except for the columns specified in names_from and values_from. </li> <li><code>names_from</code> (optional) \u2014 and</li> <li><code>names_prefix</code> (str, optional) \u2014 String added to the start of every variable name.</li> <li><code>names_sep</code> (str, optional) \u2014 If names_from or values_from contains multiple variables,this will be used to join their values together into a single string to use as a column name. </li> <li><code>names_glue</code> (str, optional) \u2014 Instead of names_sep and names_prefix, you can supplya glue specification that uses the names_from columns (and special _value) to create custom column names. </li> <li><code>names_sort</code> (bool, optional) \u2014 Should the column names be sorted? If FALSE, the default,column names are ordered by first appearance. </li> <li><code>values_from</code> (optional) \u2014 A pair of arguments describing which column(or columns) to get the name of the output column (names_from), and which column (or columns) to get the cell values from (values_from). </li> <li><code>values_fill</code> (optional) \u2014 Optionally, a (scalar) value that specifies whateach value should be filled in with when missing. </li> <li><code>values_fn</code> (Union, optional) \u2014 Optionally, a function applied to the value in each cellin the output. You will typically use this when the combination of <code>id_cols</code> and value column does not uniquely identify an observation. This can be a dict you want to apply different aggregations to different value columns. If not specified, will be <code>numpy.mean</code> </li> <li><code>names_repair</code> \u2014 todo</li> </ul> Returns (Any) <p>The pivoted dataframe.</p> function &lt;/&gt; <p>Given either a regular expression or a vector of character positions,turns a single character column into multiple columns.</p> Parameters <ul> <li><code>data</code> \u2014 The dataframe</li> <li><code>col</code> (int | str) \u2014 Column name or position.</li> <li><code>into</code> \u2014 Names of new variables to create as character vector.Use <code>None</code>/<code>NA</code>/<code>NULL</code> to omit the variable in the output. </li> <li><code>sep</code> (int | str, optional) \u2014 Separator between columns.If str, <code>sep</code> is interpreted as a regular expression. The default value is a regular expression that matches any sequence of non-alphanumeric values. If int, <code>sep</code> is interpreted as character positions to split at. </li> <li><code>remove</code> (bool, optional) \u2014 If TRUE, remove input column from output data frame.</li> <li><code>convert</code> (optional) \u2014 The universal type for the extracted columns or a dict forindividual ones Note that when given <code>TRUE</code>, <code>DataFrame.convert_dtypes()</code> is called, but it will not convert <code>str</code> to other types (For example, <code>'1'</code> to <code>1</code>). You have to specify the dtype yourself. </li> <li><code>extra</code> (str, optional) \u2014 If sep is a character vector, this controls what happens whenthere are too many pieces. There are three valid options: <ul><li>- \"warn\" (the default): emit a warning and drop extra values.</li><li>- \"drop\": drop any extra values without a warning.</li><li>- \"merge\": only splits at most length(into) times</li></ul></li> <li><code>fill</code> (str, optional) \u2014 If sep is a character vector, this controls what happens whenthere are not enough pieces. There are three valid options: <ul><li>- \"warn\" (the default): emit a warning and fill from the right</li><li>- \"right\": fill with missing values on the right</li><li>- \"left\": fill with missing values on the left</li></ul></li> </ul> Returns (Any) <p>Dataframe with separated columns.</p> function &lt;/&gt; <p>Separates the values and places each one in its own row.</p> Parameters <ul> <li><code>data</code> \u2014 The dataframe</li> <li><code>*columns</code> (str) \u2014 The columns to separate on</li> <li><code>sep</code> (str, optional) \u2014 Separator between columns.</li> <li><code>convert</code> (optional) \u2014 The universal type for the extracted columns or a dict forindividual ones </li> </ul> Returns (Any) <p>Dataframe with rows separated and repeated.</p> function &lt;/&gt; <p>Duplicating rows according to a weighting variable</p> Parameters <ul> <li><code>data</code> \u2014 A data frame</li> <li><code>weights</code> \u2014 A vector of weights. Evaluated in the context of data</li> <li><code>_remove</code> (bool, optional) \u2014 If TRUE, and weights is the name of a column in data,then this column is removed. </li> <li><code>_id</code> (str, optional) \u2014 Supply a string to create a new variable which gives aunique identifier for each created row (0-based). </li> </ul> Returns (Any) <p>dataframe with rows repeated.</p> function &lt;/&gt; <p>Unite multiple columns into one by pasting strings together</p> Parameters <ul> <li><code>data</code> \u2014 A data frame.</li> <li><code>col</code> (str) \u2014 The name of the new column, as a string or symbol.</li> <li><code>*columns</code> (str | int) \u2014 Columns to unite</li> <li><code>sep</code> (str, optional) \u2014 Separator to use between values.</li> <li><code>remove</code> (bool, optional) \u2014 If True, remove input columns from output data frame.</li> <li><code>na_rm</code> (bool, optional) \u2014 If True, missing values will be remove prior to unitingeach value. </li> </ul> Returns (Any) <p>The dataframe with selected columns united</p> function &lt;/&gt; <p>Replace NA with a value</p><p>This function can be also used not as a verb. As a function called as an argument in a verb, data is passed implicitly. Then one could pass data_or_replace as the data to replace.</p> Parameters <ul> <li><code>data</code> \u2014 The data piped in</li> <li><code>data_or_replace</code> (optional) \u2014 When called as argument of a verb, this is thedata to replace. Otherwise this is the replacement. </li> <li><code>replace</code> (optional) \u2014 The value to replace withCan only be a scalar or dict for data frame. So replace NA with a list is not supported yet. </li> </ul> Returns (Any) <p>Corresponding data with NAs replaced</p>"},{"location":"api/datar.apis.tidyr/#datarapistidyr","title":"datar.apis.tidyr","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrfull_seq","title":"<code>datar.apis.tidyr.</code><code>full_seq</code><code>(</code><code>x</code>, <code>period</code>, <code>tol=1e-06</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrchop","title":"<code>datar.apis.tidyr.</code><code>chop</code><code>(</code><code>data</code>, <code>cols=None</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrunchop","title":"<code>datar.apis.tidyr.</code><code>unchop</code><code>(</code><code>data</code>, <code>cols=None</code>, <code>keep_empty=False</code>, <code>dtypes=None</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrnest","title":"<code>datar.apis.tidyr.</code><code>nest</code><code>(</code><code>_data</code>, <code>_names_sep=None</code>, <code>**cols</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrunnest","title":"<code>datar.apis.tidyr.</code><code>unnest</code><code>(</code><code>data</code>, <code>*cols</code>, <code>keep_empty=False</code>, <code>dtypes=None</code>, <code>names_sep=None</code>, <code>names_repair='check_unique'</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrpack","title":"<code>datar.apis.tidyr.</code><code>pack</code><code>(</code><code>_data</code>, <code>_names_sep=None</code>, <code>**cols</code><code>)</code> \u2192 Any","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrunpack","title":"<code>datar.apis.tidyr.</code><code>unpack</code><code>(</code><code>data</code>, <code>cols</code>, <code>names_sep=None</code>, <code>names_repair='check_unique'</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrexpand","title":"<code>datar.apis.tidyr.</code><code>expand</code><code>(</code><code>data</code>, <code>*args</code>, <code>_name_repair='check_unique'</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrnesting","title":"<code>datar.apis.tidyr.</code><code>nesting</code><code>(</code><code>*args</code>, <code>_name_repair='check_unique'</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrcrossing","title":"<code>datar.apis.tidyr.</code><code>crossing</code><code>(</code><code>*args</code>, <code>_name_repair='check_unique'</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrcomplete","title":"<code>datar.apis.tidyr.</code><code>complete</code><code>(</code><code>data</code>, <code>*args</code>, <code>fill=None</code>, <code>explict=True</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrdrop_na","title":"<code>datar.apis.tidyr.</code><code>drop_na</code><code>(</code><code>_data</code>, <code>*columns</code>, <code>_how='any'</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrextract","title":"<code>datar.apis.tidyr.</code><code>extract</code><code>(</code><code>data</code>, <code>col</code>, <code>into</code>, <code>regex='(\\\\w+)'</code>, <code>remove=True</code>, <code>convert=False</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrfill","title":"<code>datar.apis.tidyr.</code><code>fill</code><code>(</code><code>_data</code>, <code>*columns</code>, <code>_direction='down'</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrpivot_longer","title":"<code>datar.apis.tidyr.</code><code>pivot_longer</code><code>(</code><code>_data</code>, <code>cols</code>, <code>names_to='name'</code>, <code>names_prefix=None</code>, <code>names_sep=None</code>, <code>names_pattern=None</code>, <code>names_dtypes=None</code>, <code>names_transform=None</code>, <code>names_repair='check_unique'</code>, <code>values_to='value'</code>, <code>values_drop_na=False</code>, <code>values_dtypes=None</code>, <code>values_transform=None</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrpivot_wider","title":"<code>datar.apis.tidyr.</code><code>pivot_wider</code><code>(</code><code>_data</code>, <code>id_cols=None</code>, <code>names_from='name'</code>, <code>names_prefix=''</code>, <code>names_sep='_'</code>, <code>names_glue=None</code>, <code>names_sort=False</code>, <code>values_from='value'</code>, <code>values_fill=None</code>, <code>values_fn=None</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrseparate","title":"<code>datar.apis.tidyr.</code><code>separate</code><code>(</code><code>data</code>, <code>col</code>, <code>into</code>, <code>sep='[^0-9A-Za-z]+'</code>, <code>remove=True</code>, <code>convert=False</code>, <code>extra='warn'</code>, <code>fill='warn'</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrseparate_rows","title":"<code>datar.apis.tidyr.</code><code>separate_rows</code><code>(</code><code>data</code>, <code>*columns</code>, <code>sep='[^0-9A-Za-z]+'</code>, <code>convert=False</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyruncount","title":"<code>datar.apis.tidyr.</code><code>uncount</code><code>(</code><code>data</code>, <code>weights</code>, <code>_remove=True</code>, <code>_id=None</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrunite","title":"<code>datar.apis.tidyr.</code><code>unite</code><code>(</code><code>data</code>, <code>col</code>, <code>*columns</code>, <code>sep='_'</code>, <code>remove=True</code>, <code>na_rm=True</code><code>)</code>","text":""},{"location":"api/datar.apis.tidyr/#datarapistidyrreplace_na","title":"<code>datar.apis.tidyr.</code><code>replace_na</code><code>(</code><code>data</code>, <code>data_or_replace=None</code>, <code>replace=None</code><code>)</code>","text":""},{"location":"api/datar.base/","title":"datar.base","text":"module &lt;/&gt; Functions <ul> <li><code>__getattr__</code><code>(</code><code>name</code><code>)</code> \u2014 Even when allow_conflict_names is False, datar.base.sum should be fine&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Even when allow_conflict_names is False, datar.base.sum should be fine</p>"},{"location":"api/datar.base/#datarbase","title":"datar.base","text":""},{"location":"api/datar.base/#datarbasegetattr","title":"<code>datar.base.</code><code>__getattr__</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/datar.core/","title":"datar.core","text":"package &lt;/&gt; module &lt;/&gt; <p>Operators for datar</p> Classes <ul> <li><code>DatarOperator</code> \u2014 Operator class for datar&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Plugin system to support different backends</p> Functions <ul> <li><code>base_api</code><code>(</code><code>)</code> \u2014 What is implemented the base APIs.&lt;/&gt;</li> <li><code>c_getitem</code><code>(</code><code>item</code><code>)</code> \u2014 Get item for c&lt;/&gt;</li> <li><code>dplyr_api</code><code>(</code><code>)</code> \u2014 What is implemented the dplyr APIs.&lt;/&gt;</li> <li><code>forcats_api</code><code>(</code><code>)</code> \u2014 What is implemented the forcats APIs.&lt;/&gt;</li> <li><code>get_versions</code><code>(</code><code>)</code> \u2014 Return the versions of the dependencies of the plugin.&lt;/&gt;</li> <li><code>load_dataset</code><code>(</code><code>name</code>, <code>metadata</code><code>)</code> \u2014 Implementations for load_dataset()&lt;/&gt;</li> <li><code>misc_api</code><code>(</code><code>)</code> \u2014 What is implemented the misc APIs.&lt;/&gt;</li> <li><code>operate</code><code>(</code><code>op</code>, <code>x</code>, <code>y</code><code>)</code> \u2014 Operate on x and y&lt;/&gt;</li> <li><code>setup</code><code>(</code><code>)</code> \u2014 Initialize the backend&lt;/&gt;</li> <li><code>tibble_api</code><code>(</code><code>)</code> \u2014 What is implemented the tibble APIs.&lt;/&gt;</li> <li><code>tidyr_api</code><code>(</code><code>)</code> \u2014 What is implemented the tidyr APIs.&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Utilities for datar</p> Classes <ul> <li><code>NotImplementedByCurrentBackendError</code> \u2014 Raised when a function is not implemented by the current backend&lt;/&gt;</li> <li><code>CollectionFunction</code> \u2014 Enables c[1:3] to be interpreted as 1:3&lt;/&gt;</li> </ul> Functions <ul> <li><code>arg_match</code><code>(</code><code>arg</code>, <code>argname</code>, <code>values</code>, <code>errmsg</code><code>)</code> \u2014 Make sure arg is in one of the values.&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Name repairing</p> Classes <ul> <li><code>NameNonUniqueError</code> \u2014 Error for non-unique names&lt;/&gt;</li> </ul> Functions <ul> <li><code>repair_names</code><code>(</code><code>names</code>, <code>repair</code><code>)</code> (List) \u2014 Repair names based on the method&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provide options</p> Functions <ul> <li><code>add_option</code><code>(</code><code>x</code>, <code>default</code><code>)</code> \u2014 Add an option&lt;/&gt;</li> <li><code>get_option</code><code>(</code><code>x</code>, <code>default</code><code>)</code> (Any) \u2014 Get the current value set for option <code>x</code>,or <code>default</code> (which defaults to <code>NULL</code>) if the option is unset. &lt;/&gt;</li> <li><code>options</code><code>(</code><code>*args</code>, <code>_return</code>, <code>**kwargs</code><code>)</code> (Mapping) \u2014 Allow the user to set and examine a variety of global options&lt;/&gt;</li> <li><code>options_context</code><code>(</code><code>**kwargs</code><code>)</code> \u2014 A context manager to execute code with temporary options&lt;/&gt;</li> </ul>"},{"location":"api/datar.core/#datarcore","title":"datar.core","text":""},{"location":"api/datar.core/#datarcoreoperator","title":"datar.core.operator","text":""},{"location":"api/datar.core/#datarcoreplugin","title":"datar.core.plugin","text":""},{"location":"api/datar.core/#datarcoreutils","title":"datar.core.utils","text":""},{"location":"api/datar.core/#datarcorenames","title":"datar.core.names","text":""},{"location":"api/datar.core/#datarcoreoptions","title":"datar.core.options","text":""},{"location":"api/datar.core.names/","title":"datar.core.names","text":"module &lt;/&gt; <p>Name repairing</p> Classes <ul> <li><code>NameNonUniqueError</code> \u2014 Error for non-unique names&lt;/&gt;</li> </ul> Functions <ul> <li><code>repair_names</code><code>(</code><code>names</code>, <code>repair</code><code>)</code> (List) \u2014 Repair names based on the method&lt;/&gt;</li> </ul> class &lt;/&gt; Bases ValueError Exception BaseException <p>Error for non-unique names</p> function &lt;/&gt; <p>Repair names based on the method</p> Parameters <ul> <li><code>names</code> (Iterable) \u2014 The names to be repaired</li> <li><code>repair</code> (Union) \u2014 The method to repair<ul><li>- <code>minimal</code>: Minimal names are never None or NA.\u00a0    When an element doesn't have a name, its minimal name\u00a0    is an empty string.</li><li>- <code>unique</code>: Unique names are unique. A suffix is appended to\u00a0    duplicate names to make them unique.</li><li>- <code>universal</code>: Universal names are unique and syntactic,\u00a0    meaning that you can safely use the names as variables without\u00a0    causing a syntax error (like <code>f.&lt;name&gt;</code>).</li><li>- A function, accepts either a list of names or a single name.\u00a0    Function accepts a list of names must annotate the first\u00a0    argument with <code>typing.Iterable</code> or <code>typing.Sequence</code>.</li></ul></li> </ul> Examples <pre><code>&gt;&gt;&gt; repair_names([None]*3, repair=\"minimal\")&gt;&gt;&gt; # [\"\", \"\", \"\"]\n&gt;&gt;&gt; repair_names([\"x\", NA], repair=\"minimal\")\n&gt;&gt;&gt; # [\"x\", \"\"]\n&gt;&gt;&gt; repair_names([\"\", \"x\", \"\", \"y\", \"x\", \"_2\", \"__\"], repair=\"unique\")\n&gt;&gt;&gt; # [\"__1\", \"x__2\", \"__3\", \"y\", \"x__5\", \"__6\", \"__7\"]\n&gt;&gt;&gt; repair_names([\"\", \"x\", NA, \"x\"], repair=\"universal\")\n&gt;&gt;&gt; # [\"__1\", \"x__2\", \"__3\", \"x__4\"]\n&gt;&gt;&gt; repair_names([\"(y)\"  \"_z\"  \".2fa\"  \"False\"], repair=\"universal\")\n&gt;&gt;&gt; # [\"_y_\", \"_z\", \"_2fa\", \"_False\"]\n</code></pre> Returns (List) <p>The repaired names</p> Raises <ul> <li><code>NameNonUniqueError</code> \u2014 when check_unique fails</li> <li><code>ValueError</code> \u2014 when repair is not a string or callable</li> </ul>"},{"location":"api/datar.core.names/#datarcorenames","title":"datar.core.names","text":""},{"location":"api/datar.core.names/#datarcorenamesnamenonuniqueerror","title":"<code>datar.core.names.</code><code>NameNonUniqueError</code><code>(</code><code>)</code>","text":""},{"location":"api/datar.core.names/#datarcorenamesrepair_names","title":"<code>datar.core.names.</code><code>repair_names</code><code>(</code><code>names</code>, <code>repair</code><code>)</code>","text":""},{"location":"api/datar.core.operator/","title":"datar.core.operator","text":"module &lt;/&gt; <p>Operators for datar</p> Classes <ul> <li><code>DatarOperator</code> \u2014 Operator class for datar&lt;/&gt;</li> </ul> class &lt;/&gt; Bases pipda.operator.Operator <p>Operator class for datar</p> Methods <ul> <li><code>with_backend</code><code>(</code><code>cls</code>, <code>backend</code><code>)</code> \u2014 Use a backend for the operator&lt;/&gt;</li> </ul> generator &lt;/&gt; <p>Use a backend for the operator</p>"},{"location":"api/datar.core.operator/#datarcoreoperator","title":"datar.core.operator","text":""},{"location":"api/datar.core.operator/#datarcoreoperatordataroperator","title":"<code>datar.core.operator.</code><code>DatarOperator</code><code>(</code><code>)</code>","text":""},{"location":"api/datar.core.operator/#datarcoreoperatordataroperatorwith_backend","title":"<code>with_backend</code><code>(</code><code>cls</code>, <code>backend</code><code>)</code>","text":""},{"location":"api/datar.core.options/","title":"datar.core.options","text":"module &lt;/&gt; <p>Provide options</p> Functions <ul> <li><code>add_option</code><code>(</code><code>x</code>, <code>default</code><code>)</code> \u2014 Add an option&lt;/&gt;</li> <li><code>get_option</code><code>(</code><code>x</code>, <code>default</code><code>)</code> (Any) \u2014 Get the current value set for option <code>x</code>,or <code>default</code> (which defaults to <code>NULL</code>) if the option is unset. &lt;/&gt;</li> <li><code>options</code><code>(</code><code>*args</code>, <code>_return</code>, <code>**kwargs</code><code>)</code> (Mapping) \u2014 Allow the user to set and examine a variety of global options&lt;/&gt;</li> <li><code>options_context</code><code>(</code><code>**kwargs</code><code>)</code> \u2014 A context manager to execute code with temporary options&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Allow the user to set and examine a variety of global options</p> Parameters <ul> <li><code>*args</code> (Union) \u2014 Names of options to return</li> <li><code>_return</code> (bool, optional) \u2014 Whether return the options.If <code>None</code>, turned to <code>True</code> when option names provided in <code>args</code>. </li> <li><code>**kwargs</code> (Any) \u2014 name-value pair to create/set an option</li> </ul> Returns (Mapping) <p>The options before updating if <code>_return</code> is <code>True</code>.</p> generator &lt;/&gt; <p>A context manager to execute code with temporary options</p><p>Note that this is not thread-safe.</p> function &lt;/&gt; <p>Get the current value set for option <code>x</code>,or <code>default</code> (which defaults to <code>NULL</code>) if the option is unset.</p> Parameters <ul> <li><code>x</code> (str) \u2014 The name of the option</li> <li><code>default</code> (Any, optional) \u2014 The default value if <code>x</code> is unset</li> </ul> function &lt;/&gt; <p>Add an option</p> Parameters <ul> <li><code>x</code> (str) \u2014 The name of the option</li> <li><code>default</code> (Any, optional) \u2014 The default value if <code>x</code> is unset</li> </ul>"},{"location":"api/datar.core.options/#datarcoreoptions","title":"datar.core.options","text":""},{"location":"api/datar.core.options/#datarcoreoptionsoptions","title":"<code>datar.core.options.</code><code>options</code><code>(</code><code>*args</code>, <code>_return=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.core.options/#datarcoreoptionsoptions_context","title":"<code>datar.core.options.</code><code>options_context</code><code>(</code><code>**kwargs</code><code>)</code>","text":""},{"location":"api/datar.core.options/#datarcoreoptionsget_option","title":"<code>datar.core.options.</code><code>get_option</code><code>(</code><code>x</code>, <code>default=None</code><code>)</code> \u2192 Any","text":""},{"location":"api/datar.core.options/#datarcoreoptionsadd_option","title":"<code>datar.core.options.</code><code>add_option</code><code>(</code><code>x</code>, <code>default=None</code><code>)</code>","text":""},{"location":"api/datar.core.plugin/","title":"datar.core.plugin","text":"module &lt;/&gt; <p>Plugin system to support different backends</p> Functions <ul> <li><code>base_api</code><code>(</code><code>)</code> \u2014 What is implemented the base APIs.&lt;/&gt;</li> <li><code>c_getitem</code><code>(</code><code>item</code><code>)</code> \u2014 Get item for c&lt;/&gt;</li> <li><code>dplyr_api</code><code>(</code><code>)</code> \u2014 What is implemented the dplyr APIs.&lt;/&gt;</li> <li><code>forcats_api</code><code>(</code><code>)</code> \u2014 What is implemented the forcats APIs.&lt;/&gt;</li> <li><code>get_versions</code><code>(</code><code>)</code> \u2014 Return the versions of the dependencies of the plugin.&lt;/&gt;</li> <li><code>load_dataset</code><code>(</code><code>name</code>, <code>metadata</code><code>)</code> \u2014 Implementations for load_dataset()&lt;/&gt;</li> <li><code>misc_api</code><code>(</code><code>)</code> \u2014 What is implemented the misc APIs.&lt;/&gt;</li> <li><code>operate</code><code>(</code><code>op</code>, <code>x</code>, <code>y</code><code>)</code> \u2014 Operate on x and y&lt;/&gt;</li> <li><code>setup</code><code>(</code><code>)</code> \u2014 Initialize the backend&lt;/&gt;</li> <li><code>tibble_api</code><code>(</code><code>)</code> \u2014 What is implemented the tibble APIs.&lt;/&gt;</li> <li><code>tidyr_api</code><code>(</code><code>)</code> \u2014 What is implemented the tidyr APIs.&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Initialize the backend</p> function &lt;/&gt; <p>Return the versions of the dependencies of the plugin.</p> function &lt;/&gt; <p>Implementations for load_dataset()</p> function &lt;/&gt; <p>What is implemented the base APIs.</p> function &lt;/&gt; <p>What is implemented the dplyr APIs.</p> function &lt;/&gt; <p>What is implemented the tibble APIs.</p> function &lt;/&gt; <p>What is implemented the forcats APIs.</p> function &lt;/&gt; <p>What is implemented the tidyr APIs.</p> function &lt;/&gt; <p>What is implemented the misc APIs.</p> function &lt;/&gt; <p>Get item for c</p> function &lt;/&gt; <p>Operate on x and y</p>"},{"location":"api/datar.core.plugin/#datarcoreplugin","title":"datar.core.plugin","text":""},{"location":"api/datar.core.plugin/#datarcorepluginsetup","title":"<code>datar.core.plugin.</code><code>setup</code><code>(</code><code>)</code>","text":""},{"location":"api/datar.core.plugin/#datarcorepluginget_versions","title":"<code>datar.core.plugin.</code><code>get_versions</code><code>(</code><code>)</code>","text":""},{"location":"api/datar.core.plugin/#datarcorepluginload_dataset","title":"<code>datar.core.plugin.</code><code>load_dataset</code><code>(</code><code>name</code>, <code>metadata</code><code>)</code>","text":""},{"location":"api/datar.core.plugin/#datarcorepluginbase_api","title":"<code>datar.core.plugin.</code><code>base_api</code><code>(</code><code>)</code>","text":""},{"location":"api/datar.core.plugin/#datarcoreplugindplyr_api","title":"<code>datar.core.plugin.</code><code>dplyr_api</code><code>(</code><code>)</code>","text":""},{"location":"api/datar.core.plugin/#datarcoreplugintibble_api","title":"<code>datar.core.plugin.</code><code>tibble_api</code><code>(</code><code>)</code>","text":""},{"location":"api/datar.core.plugin/#datarcorepluginforcats_api","title":"<code>datar.core.plugin.</code><code>forcats_api</code><code>(</code><code>)</code>","text":""},{"location":"api/datar.core.plugin/#datarcoreplugintidyr_api","title":"<code>datar.core.plugin.</code><code>tidyr_api</code><code>(</code><code>)</code>","text":""},{"location":"api/datar.core.plugin/#datarcorepluginmisc_api","title":"<code>datar.core.plugin.</code><code>misc_api</code><code>(</code><code>)</code>","text":""},{"location":"api/datar.core.plugin/#datarcorepluginc_getitem","title":"<code>datar.core.plugin.</code><code>c_getitem</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/datar.core.plugin/#datarcorepluginoperate","title":"<code>datar.core.plugin.</code><code>operate</code><code>(</code><code>op</code>, <code>x</code>, <code>y=None</code><code>)</code>","text":""},{"location":"api/datar.core.utils/","title":"datar.core.utils","text":"module &lt;/&gt; <p>Utilities for datar</p> Classes <ul> <li><code>NotImplementedByCurrentBackendError</code> \u2014 Raised when a function is not implemented by the current backend&lt;/&gt;</li> <li><code>CollectionFunction</code> \u2014 Enables c[1:3] to be interpreted as 1:3&lt;/&gt;</li> </ul> Functions <ul> <li><code>arg_match</code><code>(</code><code>arg</code>, <code>argname</code>, <code>values</code>, <code>errmsg</code><code>)</code> \u2014 Make sure arg is in one of the values.&lt;/&gt;</li> </ul> class &lt;/&gt; Bases NotImplementedError RuntimeError Exception BaseException <p>Raised when a function is not implemented by the current backend</p> class &lt;/&gt; <p>Enables c[1:3] to be interpreted as 1:3</p> Methods <ul> <li><code>__getitem__</code><code>(</code><code>item</code><code>)</code> \u2014 Allow c[1:3] to be interpreted as 1:3&lt;/&gt;</li> <li><code>with_backend</code><code>(</code><code>backend</code><code>)</code> \u2014 Set the backend for c[]&lt;/&gt;</li> </ul> generator &lt;/&gt; <p>Set the backend for c[]</p> method &lt;/&gt; <p>Allow c[1:3] to be interpreted as 1:3</p> function &lt;/&gt; <p>Make sure arg is in one of the values.</p><p>Mimics <code>rlang::arg_match</code>.</p>"},{"location":"api/datar.core.utils/#datarcoreutils","title":"datar.core.utils","text":""},{"location":"api/datar.core.utils/#datarcoreutilsnotimplementedbycurrentbackenderror","title":"<code>datar.core.utils.</code><code>NotImplementedByCurrentBackendError</code><code>(</code><code>func</code>, <code>data=None</code><code>)</code>","text":""},{"location":"api/datar.core.utils/#datarcoreutilscollectionfunction","title":"<code>datar.core.utils.</code><code>CollectionFunction</code><code>(</code><code>c_func</code><code>)</code>","text":""},{"location":"api/datar.core.utils/#datarcoreutilscollectionfunctionwith_backend","title":"<code>with_backend</code><code>(</code><code>backend</code><code>)</code>","text":""},{"location":"api/datar.core.utils/#datarcoreutilscollectionfunctiongetitem","title":"<code>__getitem__</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/datar.core.utils/#datarcoreutilsarg_match","title":"<code>datar.core.utils.</code><code>arg_match</code><code>(</code><code>arg</code>, <code>argname</code>, <code>values</code>, <code>errmsg=None</code><code>)</code>","text":""},{"location":"api/datar.data/","title":"datar.data","text":"package &lt;/&gt; <p>Collects datasets from R-datasets, dplyr and tidyr packages</p> Functions <ul> <li><code>add_dataset</code><code>(</code><code>name</code>, <code>meta</code><code>)</code> \u2014 Add a dataset to the registry&lt;/&gt;</li> <li><code>descr_datasets</code><code>(</code><code>*names</code><code>)</code> \u2014 Get the information of the given datasets&lt;/&gt;</li> <li><code>load_dataset</code><code>(</code><code>name</code>, <code>__backend</code><code>)</code> (Any) \u2014 Load the specific dataset&lt;/&gt;</li> </ul>"},{"location":"api/datar.data/#datardata","title":"datar.data","text":""},{"location":"api/datar.data.metadata/","title":"datar.data.metadata","text":"module &lt;/&gt; Classes <ul> <li><code>Metadata</code> \u2014 Metadata(descr, ref, index, source)&lt;/&gt;</li> </ul> class &lt;/&gt; Bases tuple <p>Metadata(descr, ref, index, source)</p>"},{"location":"api/datar.data.metadata/#datardatametadata","title":"datar.data.metadata","text":""},{"location":"api/datar.data.metadata/#datardatametadatametadata","title":"<code>datar.data.metadata.</code><code>Metadata</code><code>(</code><code>descr</code>, <code>ref</code>, <code>index</code>, <code>source</code><code>)</code>","text":""},{"location":"api/datar.datasets/","title":"datar.datasets","text":"module &lt;/&gt; Classes <ul> <li><code>DatasetsDeprecatedWarning</code> \u2014 Base class for warnings about deprecated features.&lt;/&gt;</li> </ul> class &lt;/&gt; Bases DeprecationWarning Warning Exception BaseException <p>Base class for warnings about deprecated features.</p>"},{"location":"api/datar.datasets/#datardatasets","title":"datar.datasets","text":""},{"location":"api/datar.datasets/#datardatasetsdatasetsdeprecatedwarning","title":"<code>datar.datasets.</code><code>DatasetsDeprecatedWarning</code><code>(</code><code>)</code>","text":""},{"location":"api/datar.dplyr/","title":"datar.dplyr","text":"module &lt;/&gt; Functions <ul> <li><code>__getattr__</code><code>(</code><code>name</code><code>)</code> \u2014 Even when allow_conflict_names is False, datar.base.sum should be fine&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Even when allow_conflict_names is False, datar.base.sum should be fine</p>"},{"location":"api/datar.dplyr/#datardplyr","title":"datar.dplyr","text":""},{"location":"api/datar.dplyr/#datardplyrgetattr","title":"<code>datar.dplyr.</code><code>__getattr__</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/datar/","title":"datar","text":"package &lt;/&gt; Functions <ul> <li><code>get_versions</code><code>(</code><code>prnt</code><code>)</code> (Mapping) \u2014 Return/Print the versions of the dependencies.&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Import all constants, verbs and functions</p> Functions <ul> <li><code>__getattr__</code><code>(</code><code>name</code><code>)</code> \u2014 Even when allow_conflict_names is False, datar.base.sum should be fine&lt;/&gt;</li> </ul> package &lt;/&gt; <p>Collects datasets from R-datasets, dplyr and tidyr packages</p> Functions <ul> <li><code>add_dataset</code><code>(</code><code>name</code>, <code>meta</code><code>)</code> \u2014 Add a dataset to the registry&lt;/&gt;</li> <li><code>descr_datasets</code><code>(</code><code>*names</code><code>)</code> \u2014 Get the information of the given datasets&lt;/&gt;</li> <li><code>load_dataset</code><code>(</code><code>name</code>, <code>__backend</code><code>)</code> (Any) \u2014 Load the specific dataset&lt;/&gt;</li> </ul>"},{"location":"api/datar/#datar","title":"datar","text":""},{"location":"api/datar/#datarall","title":"datar.all","text":""},{"location":"api/datar/#datardata","title":"datar.data","text":""},{"location":"api/source/datar.all/","title":"datar.all","text":""},{"location":"api/source/datar.all/","title":"SOURCE CODE datar.all DOCS","text":"<pre><code>\"\"\"Import all constants, verbs and functions\"\"\"\n\nfrom .core import load_plugins as _\nfrom .core.defaults import f\n\nfrom .base import _conflict_names as _base_conflict_names\nfrom .dplyr import _conflict_names as _dplyr_conflict_names\n\nfrom .base import *\nfrom .dplyr import *\nfrom .forcats import *\nfrom .tibble import *\nfrom .tidyr import *\nfrom .misc import *\n\n__all__ = [key for key in locals() if not key.startswith(\"_\")]\n\nif get_option(\"allow_conflict_names\"):  # noqa: F405\n    __all__.extend(_base_conflict_names | _dplyr_conflict_names)\n    for name in _base_conflict_names | _dplyr_conflict_names:\n        locals()[name] = locals()[name + \"_\"]\n\n\ndef __getattr__(name):DOCS\n    \"\"\"Even when allow_conflict_names is False, datar.base.sum should be fine\n    \"\"\"\n    if name in _base_conflict_names | _dplyr_conflict_names:\n        import sys\n        import ast\n        from executing import Source\n        node = Source.executing(sys._getframe(1)).node\n        if isinstance(node, (ast.Call, ast.Attribute)):\n            # import datar.all as d\n            # d.sum(...) or getattr(d, \"sum\")(...)\n            return globals()[name + \"_\"]\n\n    raise AttributeError\n</code></pre>"},{"location":"api/source/datar.apis.base/","title":"datar.apis.base","text":""},{"location":"api/source/datar.apis.base/","title":"SOURCE CODE datar.apis.base DOCS","text":"<pre><code>\"\"\"APIs ported from r-base\"\"\"\n# import the variables with _ so that they are not imported by *\nimport math as _math\nfrom typing import Any\nfrom string import ascii_letters as _ascii_letters\n\nfrom pipda import register_func as _register_func\n\nfrom ..core.utils import (\n    NotImplementedByCurrentBackendError as _NotImplementedByCurrentBackendError,\n    CollectionFunction as _CollectionFunction,\n)\nfrom ..core.options import options, get_option, options_context  # noqa: F401\nfrom ..core.names import repair_names as _repair_names\n\npi = _math.pi\nletters = list(_ascii_letters[:26])\nLETTERS = list(_ascii_letters[26:])\nmonth_name = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\",\n]\nmonth_abb = [m[:3] for m in month_name]\n\nFALSE = False\nTRUE = True\nNA = float(\"nan\")\nNULL = None\nNaN = float(\"nan\")\nInf = float(\"inf\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef ceiling(x) -&gt; Any:\n    \"\"\"Round up to the nearest integer\n\n    Args:\n        x: The value to be rounded up\n\n    Returns:\n        The rounded up value\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"ceiling\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef cov(x, y=None, na_rm: bool = False, ddof: int = 1) -&gt; Any:\n    \"\"\"Compute pairwise covariance between two variables\n\n    Args:\n        x: a numeric vector, matrix or data frame.\n        y: None or a vector, matrix or data frame with\n          compatible dimensions to `x`.  The default is equivalent to\n          `y = x`\n        na_rm: If `True`, remove missing values before computing\n            the covariance.\n        ddof: The denominator degrees of freedom.\n\n    Returns:\n        The covariance matrix\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cov\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef floor(x) -&gt; Any:\n    \"\"\"Round down to the nearest integer\n\n    Args:\n        x: The value to be rounded down\n\n    Returns:\n        The rounded down value\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"floor\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef mean(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the mean of a vector\n\n    Args:\n        x: A numeric vector\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The mean of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"mean\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef median(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the median of a vector\n\n    Args:\n        x: A numeric vector\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The median of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"median\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef pmax(*args, na_rm: bool = False) -&gt; Any:\n    \"\"\"Returns the (regular or Parallel) maxima and minima of the input\n     values.\n\n    Args:\n        x: A numeric vector\n        more: One or more values\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The maximum of the vector and the values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"pmax\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef pmin(*args, na_rm: bool = False) -&gt; Any:\n    \"\"\"Returns the (regular or Parallel) maxima and minima of the input\n     values.\n\n    Args:\n        x: A numeric vector\n        more: One or more values\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The minimum of the vector and the values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"pmin\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef sqrt(x) -&gt; Any:\n    \"\"\"Compute the square root of a vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The square root of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"sqrt\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef var(x, na_rm: bool = False, ddof: int = 1) -&gt; Any:\n    \"\"\"Compute the variance of a vector\n\n    Args:\n        x: A numeric vector\n        y: None or a vector, matrix or data frame with\n          compatible dimensions to `x`.  The default is equivalent to\n          `y = x`\n        na_rm: Whether to remove `NA` values\n        ddof: The degrees of freedom\n\n    Returns:\n        The variance of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"var\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef scale(x, center=True, scale_=True) -&gt; Any:\n    \"\"\"Center and/or scale the data\n\n    Args:\n        x: A numeric vector\n        center: Whether to center the data\n        scale_: Whether to scale the data\n\n    Returns:\n        The scaled data\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"scale\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef col_sums(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the column sums of a matrix\n\n    Args:\n        x: A numeric matrix\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The column sums of the matrix\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"col_sums\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef col_means(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the column means of a matrix\n\n    Args:\n        x: A numeric matrix\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The column means of the matrix\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"col_means\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef col_sds(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the column standard deviations of a matrix\n\n    Args:\n        x: A numeric matrix\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The column standard deviations of the matrix\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"col_sds\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef col_medians(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the column medians of a matrix\n\n    Args:\n        x: A numeric matrix\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The column medians of the matrix\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"col_medians\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef row_sums(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the row sums of a matrix\n\n    Args:\n        x: A numeric matrix\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The row sums of the matrix\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"row_sums\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef row_means(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the row means of a matrix\n\n    Args:\n        x: A numeric matrix\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The row means of the matrix\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"row_means\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef row_sds(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the row standard deviations of a matrix\n\n    Args:\n        x: A numeric matrix\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The row standard deviations of the matrix\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"row_sds\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef row_medians(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the row medians of a matrix\n\n    Args:\n        x: A numeric matrix\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The row medians of the matrix\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"row_medians\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef min_(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the minimum of a vector\n\n    Args:\n        x: A numeric vector\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The minimum of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"min\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef max_(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the maximum of a vector\n\n    Args:\n        x: A numeric vector\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The maximum of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"max\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef round_(x, digits: int = 0) -&gt; Any:\n    \"\"\"Round the values of a vector\n\n    Args:\n        x: A numeric vector\n        digits: The number of digits to round to\n\n    Returns:\n        The rounded values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"round\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef sum_(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the sum of a vector\n\n    Args:\n        x: A numeric vector\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The sum of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"sum\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef abs_(x) -&gt; Any:\n    \"\"\"Compute the absolute value of a vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The absolute values of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"abs\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef prod(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the product of a vector\n\n    Args:\n        x: A numeric vector\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The product of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"prod\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef sign(x) -&gt; Any:\n    \"\"\"Compute the sign of a vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The signs of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"sign\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef signif(x, digits: int = 6) -&gt; Any:\n    \"\"\"Round the values of a vector to a given number of significant digits\n\n    Args:\n        x: A numeric vector\n        digits: The number of significant digits to round to\n\n    Returns:\n        The rounded values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"signif\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef trunc(x) -&gt; Any:\n    \"\"\"Truncate the values of a vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The truncated values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"trunc\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef exp(x) -&gt; Any:\n    \"\"\"Compute the exponential of a vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The exponential values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"exp\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef log(x, base: float = _math.e) -&gt; Any:\n    \"\"\"Compute the logarithm of a vector\n\n    Args:\n        x: A numeric vector\n        base: The base of the logarithm\n\n    Returns:\n        The logarithm values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"log\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef log2(x) -&gt; Any:\n    \"\"\"Compute the base-2 logarithm of a vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The logarithm values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"log2\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef log10(x) -&gt; Any:\n    \"\"\"Compute the base 10 logarithm of a vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The logarithm values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"log10\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef log1p(x) -&gt; Any:\n    \"\"\"Compute the logarithm of one plus a vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The logarithm values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"log1p\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef sd(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the standard deviation of a vector\n\n    Args:\n        x: A numeric vector\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The standard deviation of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"sd\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef weighted_mean(x, w=None, na_rm: bool = False) -&gt; Any:\n    \"\"\"Compute the weighted mean of a vector\n\n    Args:\n        x: A numeric vector\n        w: The weights to use\n        na_rm: Whether to remove `NA` values\n\n    Returns:\n        The weighted mean of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"weighted_mean\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef quantile(\n    x,\n    probs=(0.0, 0.25, 0.5, 0.75, 1.0),\n    na_rm: bool = False,\n    names: bool = True,\n    type_: int = 7,\n    digits: int = 7,\n) -&gt; Any:\n    \"\"\"Compute the quantiles of a vector\n\n    Args:\n        x: A numeric vector\n        probs: The probabilities to use\n\n    Returns:\n        The quantiles of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"quantile\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef bessel_i(x, nu, expon_scaled: bool = False) -&gt; Any:\n    \"\"\"Compute the modified Bessel function of the first kind\n\n    Args:\n        x: A numeric vector\n        nu: The order of the Bessel function\n        expon_scaled: Whether to use the scaled version\n\n    Returns:\n        The Bessel function values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"bessel_i\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef bessel_j(x, nu) -&gt; Any:\n    \"\"\"Compute the Bessel function of the first kind\n\n    Args:\n        x: A numeric vector\n        nu: The order of the Bessel function\n\n    Returns:\n        The Bessel function values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"bessel_j\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef bessel_k(x, nu, expon_scaled: bool = False) -&gt; Any:\n    \"\"\"Compute the modified Bessel function of the second kind\n\n    Args:\n        x: A numeric vector\n        nu: The order of the Bessel function\n        expon_scaled: Whether to use the scaled version\n\n    Returns:\n        The Bessel function values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"bessel_k\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef bessel_y(x, nu) -&gt; Any:\n    \"\"\"Compute the Bessel function of the second kind\n\n    Args:\n        x: A numeric vector\n        nu: The order of the Bessel function\n\n    Returns:\n        The Bessel function values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"bessel_y\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef as_double(x) -&gt; Any:\n    \"\"\"Convert a vector to a double vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The double vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"as_double\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef as_integer(x) -&gt; Any:\n    \"\"\"Convert a vector to an integer vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The integer vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"as_integer\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef as_logical(x) -&gt; Any:\n    \"\"\"Convert a vector to a logical vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The logical vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"as_logical\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef as_character(x) -&gt; Any:\n    \"\"\"Convert a vector to a character vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The character vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"as_character\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef as_factor(x) -&gt; Any:\n    \"\"\"Convert a vector to a factor vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The factor vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"as_factor\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef as_ordered(x) -&gt; Any:\n    \"\"\"Convert a vector to an ordered vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The ordered vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"as_ordered\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef as_date(\n    x,\n    *,\n    format=None,\n    try_formats=None,\n    optional=False,\n    tz=0,\n    origin=None,\n) -&gt; Any:\n    \"\"\"Convert an object to a datetime.date object\n\n    See: https://rdrr.io/r/base/as.Date.html\n\n    Args:\n        x: Object that can be converted into a datetime.date object\n        format:  If not specified, it will try try_formats one by one on\n            the first non-np.nan element, and give an error if none works.\n            Otherwise, the processing is via strptime\n        try_formats: vector of format strings to try if format is not specified.\n            Default formats to try:\n            \"%Y-%m-%d\"\n            \"%Y/%m/%d\"\n            \"%Y-%m-%d %H:%M:%S\"\n            \"%Y/%m/%d %H:%M:%S\"\n        optional: indicating to return np.nan (instead of signalling an error)\n            if the format guessing does not succeed.\n        origin: a datetime.date/datetime object, or something which can be\n            coerced by as_date(origin, ...) to such an object.\n        tz: a time zone offset or a datetime.timedelta object.\n            Note that time zone name is not supported yet.\n\n    Returns:\n        The datetime.date object\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"as_date\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef as_numeric(x) -&gt; Any:\n    \"\"\"Convert a vector to a numeric vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The numeric vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"as_numeric\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef arg(x) -&gt; Any:\n    \"\"\"Angles of complex numbers\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The angles\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"arg\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef conj(x) -&gt; Any:\n    \"\"\"Complex conjugate\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The complex conjugates\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"conj\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef mod(x) -&gt; Any:\n    \"\"\"Modulus of complex numbers\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The modulus\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"mod\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef re_(x) -&gt; Any:\n    \"\"\"Real part of complex numbers\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The real parts\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"re\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef im(x) -&gt; Any:\n    \"\"\"Imaginary part of complex numbers\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The imaginary parts\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"im\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef as_complex(x) -&gt; Any:\n    \"\"\"Convert a vector to a complex vector\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The complex vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"as_complex\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_complex(x) -&gt; Any:\n    \"\"\"Check if a vector is complex\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        Whether the vector is complex\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_complex\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef cummax(x) -&gt; Any:\n    \"\"\"Cumulative maxima\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The cumulative maxima\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cummax\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef cummin(x) -&gt; Any:\n    \"\"\"Cumulative minima\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The cumulative minima\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cummin\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef cumprod(x) -&gt; Any:\n    \"\"\"Cumulative products\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The cumulative products\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cumprod\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef cumsum(x) -&gt; Any:\n    \"\"\"Cumulative sums\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The cumulative sums\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cumsum\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef droplevels(x) -&gt; Any:\n    \"\"\"Drop unused levels of a factor\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The factor vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"droplevels\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef levels(x) -&gt; Any:\n    \"\"\"Get the levels of a factor\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The factor vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"levels\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef set_levels(x, levels) -&gt; Any:\n    \"\"\"Set the levels of a factor\n\n    Args:\n        x: A numeric vector\n        levels: The new levels\n\n    Returns:\n        The factor vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"set_levels\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_factor(x) -&gt; Any:\n    \"\"\"Check if a vector is a factor\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        Whether the vector is a factor\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_factor\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_ordered(x) -&gt; Any:\n    \"\"\"Check if a vector is ordered\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        Whether the vector is ordered\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_ordered\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef nlevels(x) -&gt; Any:\n    \"\"\"Get the number of levels of a factor\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The number of levels\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"nlevels\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef factor(\n    x=None,\n    *,\n    levels=None,\n    labels=None,\n    exclude=None,\n    ordered=False,\n    nmax=None,\n) -&gt; Any:\n    \"\"\"Create a factor vector\n\n    Args:\n        x: A numeric vector\n        levels: The levels\n        labels: The labels\n        exclude: The excluded levels\n        ordered: Whether the factor is ordered\n        nmax: The maximum number of levels\n\n    Returns:\n        The factor vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"factor\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef ordered(x, levels=None, labels=None, exclude=None, nmax=None) -&gt; Any:\n    \"\"\"Create an ordered factor vector\n\n    Args:\n        x: A numeric vector\n        levels: The levels\n        labels: The labels\n        exclude: The excluded levels\n        nmax: The maximum number of levels\n\n    Returns:\n        The ordered factor vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"ordered\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef cut(\n    x,\n    breaks,\n    labels=None,\n    include_lowest=False,\n    right=True,\n    dig_lab=3,\n    ordered_result=False,\n) -&gt; Any:\n    \"\"\"Cut a numeric vector into bins\n\n    Args:\n        x: A numeric vector\n        breaks: The breaks\n        labels: The labels\n        include_lowest: Whether to include the lowest value\n        right: Whether to include the rightmost value\n        dig_lab: The number of digits for labels\n        ordered_result: Whether to return an ordered factor\n\n    Returns:\n        The factor vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cut\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef diff(x, lag: int = 1, differences: int = 1) -&gt; Any:\n    \"\"\"Difference of a numeric vector\n\n    Args:\n        x: A numeric vector\n        lag: The lag to use. Could be negative.\n            It always calculates `x[lag:] - x[:-lag]` even when `lag` is\n            negative\n        differences: The order of the difference\n\n    Returns:\n        An array of `x[lag:] \u2013 x[:-lag]`.\n        If `differences &gt; 1`, the rule applies `differences` times on `x`\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"diff\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef expand_grid(x, *args, **kwargs) -&gt; Any:\n    \"\"\"Expand a grid\n\n    Args:\n        x: A numeric vector\n        *args: Additional numeric vectors\n        **kwargs: Additional keyword arguments\n\n    Returns:\n        The expanded grid\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"expand_grid\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef outer(x, y, fun=\"*\") -&gt; Any:\n    \"\"\"Outer product of two vectors\n\n    Args:\n        x: A numeric vector\n        y: A numeric vector\n        fun: The function to handle how the result of the elements from\n            the first and second vectors should be computed.\n            The function has to be vectorized at the second argument, and\n            return the same shape as y.\n\n    Returns:\n        The outer product\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"outer\", x)\n\n\n@_register_func(cls=object, pipeable=True, dispatchable=True)DOCS\ndef make_names(names, unique: bool = True) -&gt; Any:\n    \"\"\"Make names for a vector\n\n    Args:\n        names: character vector to be coerced to syntactically valid names.\n            This is coerced to character if necessary.\n        unique: Whether to make the names unique\n\n    Returns:\n        The names\n    \"\"\"\n    try:\n        from slugify import slugify\n    except ImportError as imerr:  # pragma: no cover\n        raise ValueError(\n            \"`make_names()` requires `python-slugify` package.\\n\"\n            \"Try: pip install -U slugify\"\n        ) from imerr\n\n    if isinstance(names, str):\n        names = [names]\n    try:\n        iter(names)\n    except TypeError:\n        names = [names]\n\n    names = [\n        slugify(str(name), separator=\"_\", lowercase=False)\n        for name in names\n    ]\n    names = [f\"_{name}\" if name[0].isdigit() else name for name in names]\n    if unique:\n        return _repair_names(names, \"unique\")\n    return names\n\n\n@_register_func(cls=object, pipeable=True, dispatchable=True)DOCS\ndef make_unique(names) -&gt; Any:\n    \"\"\"Make a vector unique\n\n    Args:\n        names: a character vector\n\n    Returns:\n        The unique vector\n    \"\"\"\n    return make_names(names, unique=True, __ast_fallback=\"normal\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef rank(x, na_last: bool = True, ties_method: str = \"average\") -&gt; Any:\n    \"\"\"Rank a numeric vector\n\n    Args:\n        x: A numeric vector\n        na_last: Whether to put NA at the end\n        ties_method: The method to handle ties. One of \"average\", \"first\",\n            \"last\", \"random\", \"max\", \"min\"\n\n    Returns:\n        The ranks\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rank\", x)\n\n\n@_register_func(cls=object, pipeable=True, dispatchable=True)DOCS\ndef identity(x) -&gt; Any:\n    \"\"\"Identity function\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        The same vector\n    \"\"\"\n    return x\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_logical(x) -&gt; Any:\n    \"\"\"Check if a vector is logical\n\n    Args:\n        x: A numeric vector\n\n    Returns:\n        Whether the vector is logical\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_logical\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_true(x) -&gt; bool:\n    \"\"\"Check if anything is true\n\n    Args:\n        x: object to be tested\n\n    Returns:\n        Whether `x` is true\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_true\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_false(x) -&gt; bool:\n    \"\"\"Check if anything is false\n\n    Args:\n        x: object to be tested\n\n    Returns:\n        Whether `x` is false\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_false\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_na(x) -&gt; Any:\n    \"\"\"Check if anything is NA\n\n    Args:\n        x: object to be tested\n\n    Returns:\n        Whether `x` is NA\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_na\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_finite(x) -&gt; Any:\n    \"\"\"Check if anything is finite\n\n    Args:\n        x: object to be tested\n\n    Returns:\n        Whether `x` is finite\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_finite\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_infinite(x) -&gt; Any:\n    \"\"\"Check if anything is infinite\n\n    Args:\n        x: object to be tested\n\n    Returns:\n        Whether `x` is infinite\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_infinite\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef any_na(x) -&gt; Any:\n    \"\"\"Check if anything in `x` is NA\n\n    Args:\n        x: object to be tested\n\n    Returns:\n        Whether anything in `x` is NA\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"any_na\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef as_null(x) -&gt; Any:\n    \"\"\"Convert anything to NULL\n\n    Args:\n        x: object to be converted\n\n    Returns:\n        NULL\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"as_null\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_null(x) -&gt; Any:\n    \"\"\"Check if anything is NULL\n\n    Args:\n        x: object to be tested\n\n    Returns:\n        Whether `x` is NULL\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_null\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef set_seed(seed) -&gt; Any:\n    \"\"\"Set the seed of the random number generator\n\n    Args:\n        seed: The seed\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"set_seed\", seed)\n\n\n@_register_func(pipeable=True, dispatchable=\"all\")DOCS\ndef rep(x, times=1, length=None, each=1) -&gt; Any:\n    \"\"\"Replicate elements of a vector\n\n    Args:\n        x: a vector or scaler\n        times: number of times to repeat each element if of length len(x),\n            or to repeat the whole vector if of length 1\n        length: non-negative integer. The desired length of the output vector\n        each: non-negative integer. Each element of x is repeated each times.\n\n    Returns:\n        The replicated vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rep\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef c_(*args) -&gt; Any:\n    \"\"\"Concatenate vectors\n\n    Args:\n        args: vectors to be concatenated\n\n    Returns:\n        The concatenated vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"c\", *args)\n\n\nc = _CollectionFunction(c_)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef length(x) -&gt; Any:\n    \"\"\"Get the length of a vector\n\n    Args:\n        x: a vector or scaler\n\n    Returns:\n        The length of the vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"length\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef lengths(x) -&gt; Any:\n    \"\"\"Get the lengths of a list\n\n    Args:\n        x: a list\n\n    Returns:\n        The lengths of the list\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"lengths\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef order(x, decreasing: bool = False, na_last: bool = True) -&gt; Any:\n    \"\"\"Order a vector\n\n    Args:\n        x: a vector or scaler\n        decreasing: Whether to order in decreasing order\n        na_last: Whether to put NA at the end\n\n    Returns:\n        The order\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"order\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef sort(x, decreasing: bool = False, na_last: bool = True) -&gt; Any:\n    \"\"\"Sort a vector\n\n    Args:\n        x: a vector or scaler\n        decreasing: Whether to sort in decreasing order\n        na_last: Whether to put NA at the end\n\n    Returns:\n        The sorted vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"sort\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef rev(x) -&gt; Any:\n    \"\"\"Reverse a vector\n\n    Args:\n        x: a vector or scaler\n\n    Returns:\n        The reversed vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rev\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef sample(x, size=None, replace: bool = False, prob=None) -&gt; Any:\n    \"\"\"Sample a vector\n\n    Args:\n        x: a vector or scaler\n        size: the size of the sample\n        replace: whether to sample with replacement\n        prob: the probabilities of sampling each element\n\n    Returns:\n        The sampled vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"sample\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef seq(from_=None, to=None, by=None, length_out=None, along_with=None) -&gt; Any:\n    \"\"\"Generate a sequence\n\n    Args:\n        from_: the start of the sequence\n        to: the end of the sequence\n        by: the step of the sequence\n        length_out: the length of the sequence\n        along_with: the sequence to be aligned with\n\n    Returns:\n        The sequence\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"seq\", from_)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef seq_along(x) -&gt; Any:\n    \"\"\"Generate a sequence along a vector\n\n    Args:\n        x: a vector or scaler\n\n    Returns:\n        The sequence\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"seq_along\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef seq_len(x) -&gt; Any:\n    \"\"\"Generate a sequence of length x\n\n    Args:\n        x: a vector or scaler\n\n    Returns:\n        The sequence\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"seq_len\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef match(x, table, nomatch=-1) -&gt; Any:\n    \"\"\"Match elements of a vector\n\n    Args:\n        x: a vector or scaler\n        table: the table to match\n        nomatch: the value to use for no match\n\n    Returns:\n        The matched vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"match\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef beta(x, y) -&gt; Any:\n    \"\"\"Compute the beta function\n\n    Args:\n        x: a vector or scaler\n        y: a vector or scaler\n\n    Returns:\n        The beta function\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"beta\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef lgamma(x) -&gt; Any:\n    \"\"\"Compute the log gamma function\n\n    Args:\n        x: a vector or scaler\n\n    Returns:\n        The log gamma function\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"lgamma\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef digamma(x) -&gt; Any:\n    \"\"\"Compute the digamma function\n\n    Args:\n        x: a vector or scaler\n\n    Returns:\n        The digamma function\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"digamma\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef trigamma(x) -&gt; Any:\n    \"\"\"Compute the trigamma function\n\n    Args:\n        x: a vector or scaler\n\n    Returns:\n        The trigamma function\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"trigamma\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef choose(n, k) -&gt; Any:\n    \"\"\"Compute the binomial coefficient\n\n    Args:\n        n: a vector or scaler\n        k: a vector or scaler\n\n    Returns:\n        The binomial coefficient\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"choose\", n)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef factorial(x) -&gt; Any:\n    \"\"\"Compute the factorial\n\n    Args:\n        x: a vector or scaler\n\n    Returns:\n        The factorial\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"factorial\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef gamma(x) -&gt; Any:\n    \"\"\"Compute the gamma function\n\n    Args:\n        x: a vector or scaler\n\n    Returns:\n        The gamma function\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"gamma\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef lfactorial(x) -&gt; Any:\n    \"\"\"Compute the log factorial\n\n    Args:\n        x: a vector or scaler\n\n    Returns:\n        The log factorial\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"lfactorial\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef lchoose(n, k) -&gt; Any:\n    \"\"\"Compute the log binomial coefficient\n\n    Args:\n        n: a vector or scaler\n        k: a vector or scaler\n\n    Returns:\n        The log binomial coefficient\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"lchoose\", n)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef lbeta(x, y) -&gt; Any:\n    \"\"\"Compute the log beta function\n\n    Args:\n        x: a vector or scaler\n        y: a vector or scaler\n\n    Returns:\n        The log beta function\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"lbeta\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef psigamma(x, deriv) -&gt; Any:\n    \"\"\"Compute the psi function\n\n    Args:\n        x: a vector or scaler\n        deriv: the derivative\n\n    Returns:\n        The psi function\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"psigamma\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef rnorm(n, mean=0, sd=1) -&gt; Any:\n    \"\"\"Generate random normal variables\n\n    Args:\n        n: the number of random variables\n        mean: the mean of the random variables\n        sd: the standard deviation of the random variables\n\n    Returns:\n        The random normal variables\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rnorm\", n)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef runif(n, min=0, max=1) -&gt; Any:\n    \"\"\"Generate random uniform variables\n\n    Args:\n        n: the number of random variables\n        min: the minimum of the random variables\n        max: the maximum of the random variables\n\n    Returns:\n        The random uniform variables\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"runif\", n)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef rpois(n, lambda_) -&gt; Any:\n    \"\"\"Generate random Poisson variables\n\n    Args:\n        n: the number of random variables\n        lambda_: the lambda of the random variables\n\n    Returns:\n        The random Poisson variables\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rpois\", n)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef rbinom(n, size, prob) -&gt; Any:\n    \"\"\"Generate random binomial variables\n\n    Args:\n        n: the number of random variables\n        size: the size of the random variables\n        prob: the probability of the random variables\n\n    Returns:\n        The random binomial variables\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rbinom\", n)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef rcauchy(n, location=0, scale=1) -&gt; Any:\n    \"\"\"Generate random Cauchy variables\n\n    Args:\n        n: the number of random variables\n        location: the location of the random variables\n        scale: the scale of the random variables\n\n    Returns:\n        The random Cauchy variables\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rcauchy\", n)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef rchisq(n, df) -&gt; Any:\n    \"\"\"Generate random chi-squared variables\n\n    Args:\n        n: the number of random variables\n        df: the degrees of freedom of the random variables\n\n    Returns:\n        The random chi-squared variables\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rchisq\", n)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef rexp(n, rate) -&gt; Any:\n    \"\"\"Generate random exponential variables\n\n    Args:\n        n: the number of random variables\n        rate: the rate of the random variables\n\n    Returns:\n        The random exponential variables\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rexp\", n)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_character(x) -&gt; Any:\n    \"\"\"Is x a character vector\n\n    Args:\n        x: a vector or scaler\n\n    Returns:\n        True if x is a character vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_character\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef grep(\n    pattern,\n    x,\n    ignore_case=False,\n    value=False,\n    fixed=False,\n    invert=False,\n) -&gt; Any:\n    \"\"\"Grep for a pattern\n\n    Args:\n        pattern: the pattern to search for\n        x: the vector to search\n        ignore_case: ignore case\n        value: return the value\n        fixed: use fixed string matching\n        invert: invert the match\n\n    Returns:\n        The indices of the matches\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"grep\", pattern)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef grepl(pattern, x, ignore_case=False, fixed=False) -&gt; Any:\n    \"\"\"Grep for a pattern\n\n    Args:\n        pattern: the pattern to search for\n        x: the vector to search\n        ignore_case: ignore case\n        fixed: use fixed string matching\n\n    Returns:\n        The indices of the matches\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"grepl\", pattern)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef sub(pattern, replacement, x, ignore_case=False, fixed=False) -&gt; Any:\n    \"\"\"Substitute a pattern\n\n    Args:\n        pattern: the pattern to search for\n        replacement: the replacement\n        x: the vector to search\n        ignore_case: ignore case\n        fixed: use fixed string matching\n\n    Returns:\n        The vector with the substitutions\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"sub\", pattern)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef gsub(pattern, replacement, x, ignore_case=False, fixed=False) -&gt; Any:\n    \"\"\"Substitute a pattern\n\n    Args:\n        pattern: the pattern to search for\n        replacement: the replacement\n        x: the vector to search\n        ignore_case: ignore case\n        fixed: use fixed string matching\n\n    Returns:\n        The vector with the substitutions\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"gsub\", pattern)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef strsplit(x, split, fixed=False, perl=False, use_bytes=False) -&gt; Any:\n    \"\"\"Split a string\n\n    Args:\n        x: the vector to split\n        split: the pattern to split on\n        fixed: use fixed string matching\n        perl: use perl regular expressions\n        use_bytes: use bytes\n\n    Returns:\n        The vector with the splits\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"strsplit\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef paste(*args, sep=\" \", collapse=None) -&gt; Any:\n    \"\"\"Join a vector into a string\n\n    Args:\n        *args: the vector to join\n        sep: the separator\n        collapse: collapse the vector\n\n    Returns:\n        The vector joined into a string\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"paste\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef paste0(*args, collapse=None) -&gt; Any:\n    \"\"\"Join a vector into a string\n\n    Args:\n        *args: the vector to join\n        collapse: collapse the vector\n\n    Returns:\n        The vector joined into a string\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"paste0\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef sprintf(fmt, *args) -&gt; Any:\n    \"\"\"Format a string\n\n    Args:\n        fmt: the format string\n        args: the arguments to the format string\n\n    Returns:\n        The formatted string\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"sprintf\", fmt)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef substr(x, start, stop) -&gt; Any:\n    \"\"\"Get a substring\n\n    Args:\n        x: the string to get the substring from\n        start: the start of the substring\n        stop: the stop of the substring\n\n    Returns:\n        The substring\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"substr\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef substring(x, first, last=None) -&gt; Any:\n    \"\"\"Get a substring\n\n    Args:\n        x: the string to get the substring from\n        first: the start of the substring\n        last: the stop of the substring\n\n    Returns:\n        The substring\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"substring\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef startswith(x, prefix) -&gt; Any:\n    \"\"\"Does x start with prefix\n\n    Args:\n        x: the string to check\n        prefix: the prefix to check\n\n    Returns:\n        True if x starts with prefix\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"startswith\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef endswith(x, suffix) -&gt; Any:\n    \"\"\"Does x end with suffix\n\n    Args:\n        x: the string to check\n        suffix: the suffix to check\n\n    Returns:\n        True if x ends with suffix\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"endswith\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef strtoi(x, base=0) -&gt; Any:\n    \"\"\"Convert a string to an integer\n\n    Args:\n        x: the string to convert\n        base: the base of the integer\n\n    Returns:\n        The integer\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"strtoi\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef trimws(x, which=\"both\", whitespace=r\" \\t\") -&gt; Any:\n    \"\"\"Trim whitespace from a string\n\n    Args:\n        x: the string to trim\n        which: which whitespace to trim\n        whitespace: the whitespace to trim\n\n    Returns:\n        The trimmed string\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"trimws\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef toupper(x) -&gt; Any:\n    \"\"\"Convert a string to upper case\n\n    Args:\n        x: the string to convert\n\n    Returns:\n        The upper case string\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"toupper\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef tolower(x) -&gt; Any:\n    \"\"\"Convert a string to lower case\n\n    Args:\n        x: the string to convert\n\n    Returns:\n        The lower case string\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"tolower\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef chartr(old, new, x) -&gt; Any:\n    \"\"\"Translate characters\n\n    Args:\n        old: the characters to translate\n        new: the new characters\n        x: the string to translate\n\n    Returns:\n        The translated string\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"chartr\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef nchar(\n    x,\n    type_=\"width\",\n    allow_na: bool = True,\n    keep_na: bool = False,\n    _na_len: int = 2,\n) -&gt; Any:\n    \"\"\"Get the number of characters in a string\n\n    Args:\n        x: the string to count\n        type: the type of count\n        allow_na: allow NA\n        keep_na: keep NA\n\n    Returns:\n        The number of characters\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"nchar\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef nzchar(x, keep_na: bool = False) -&gt; Any:\n    \"\"\"Is the string non-zero length\n\n    Args:\n        x: the string to check\n        keep_na: keep NA\n\n    Returns:\n        True if the string is non-zero length\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"nzchar\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef table(\n    x,\n    *more,\n    exclude=None,\n    use_na=\"no\",\n    dnn=None,\n    deparse_level=1,\n) -&gt; Any:\n    \"\"\"Get the table of a vector\n\n    Args:\n        x: the vector to get the table of\n        more: more vectors\n        exclude: exclude these values\n        use_na: use NA\n        dnn: the names of the vectors\n        deparse_level: the deparse level\n\n    Returns:\n        The table\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"table\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef tabulate(bin, nbins=None) -&gt; Any:\n    \"\"\"Get the table of a vector\n\n    Args:\n        bin: the vector to get the table of\n        nbins: the number of bins\n\n    Returns:\n        An integer valued 'integer' vector (without names).\n        There is a bin for each of the values '1, ..., nbins'\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"tabulate\", bin)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_atomic(x) -&gt; Any:\n    \"\"\"Is the object atomic\n\n    Args:\n        x: the object to check\n\n    Returns:\n        True if the object is atomic\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_atomic\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_double(x) -&gt; Any:\n    \"\"\"Is the object a double\n\n    Args:\n        x: the object to check\n\n    Returns:\n        True if the object is a double\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_double\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_element(x, y) -&gt; Any:\n    \"\"\"Is the object an element of the table\n\n    Args:\n        x: the object to check\n        y: the pool to check\n\n    Returns:\n        True if the object is an element of the pool\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_element\", x)\n\n\nis_in = is_element\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_integer(x) -&gt; Any:\n    \"\"\"Is the object an integer\n\n    Args:\n        x: the object to check\n\n    Returns:\n        True if the object is an integer\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_integer\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef is_numeric(x) -&gt; Any:\n    \"\"\"Is the object numeric\n\n    Args:\n        x: the object to check\n\n    Returns:\n        True if the object is numeric\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"is_numeric\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef any_(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Is any element true\n\n    Args:\n        x: the vector to check\n        na_rm: remove NA\n\n    Returns:\n        True if any element is true\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"any\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef all_(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Are all elements true\n\n    Args:\n        x: the vector to check\n        na_rm: remove NA\n\n    Returns:\n        True if all elements are true\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"all\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef acos(x) -&gt; Any:\n    \"\"\"Get the inverse cosine\n\n    Args:\n        x: the value to get the inverse cosine of\n\n    Returns:\n        The inverse cosine\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"acos\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef acosh(x) -&gt; Any:\n    \"\"\"Get the inverse hyperbolic cosine\n\n    Args:\n        x: the value to get the inverse hyperbolic cosine of\n\n    Returns:\n        The inverse hyperbolic cosine\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"acosh\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef asin(x) -&gt; Any:\n    \"\"\"Get the inverse sine\n\n    Args:\n        x: the value to get the inverse sine of\n\n    Returns:\n        The inverse sine\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"asin\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef asinh(x) -&gt; Any:\n    \"\"\"Get the inverse hyperbolic sine\n\n    Args:\n        x: the value to get the inverse hyperbolic sine of\n\n    Returns:\n        The inverse hyperbolic sine\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"asinh\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef atan(x) -&gt; Any:\n    \"\"\"Get the inverse tangent\n\n    Args:\n        x: the value to get the inverse tangent of\n\n    Returns:\n        The inverse tangent\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"atan\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef atanh(x) -&gt; Any:\n    \"\"\"Get the inverse hyperbolic tangent\n\n    Args:\n        x: the value to get the inverse hyperbolic tangent of\n\n    Returns:\n        The inverse hyperbolic tangent\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"atanh\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef cos(x) -&gt; Any:\n    \"\"\"Get the cosine\n\n    Args:\n        x: the value to get the cosine of\n\n    Returns:\n        The cosine\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cos\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef cosh(x) -&gt; Any:\n    \"\"\"Get the hyperbolic cosine\n\n    Args:\n        x: the value to get the hyperbolic cosine of\n\n    Returns:\n        The hyperbolic cosine\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cosh\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef cospi(x) -&gt; Any:\n    \"\"\"Get the cosine of pi times x\n\n    Args:\n        x: the value to get the cosine of pi times x of\n\n    Returns:\n        The cosine of pi times x\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cospi\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef sin(x) -&gt; Any:\n    \"\"\"Get the sine\n\n    Args:\n        x: the value to get the sine of\n\n    Returns:\n        The sine\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"sin\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef sinh(x) -&gt; Any:\n    \"\"\"Get the hyperbolic sine\n\n    Args:\n        x: the value to get the hyperbolic sine of\n\n    Returns:\n        The hyperbolic sine\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"sinh\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef sinpi(x) -&gt; Any:\n    \"\"\"Get the sine of pi times x\n\n    Args:\n        x: the value to get the sine of pi times x of\n\n    Returns:\n        The sine of pi times x\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"sinpi\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef tan(x) -&gt; Any:\n    \"\"\"Get the tangent\n\n    Args:\n        x: the value to get the tangent of\n\n    Returns:\n        The tangent\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"tan\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef tanh(x) -&gt; Any:\n    \"\"\"Get the hyperbolic tangent\n\n    Args:\n        x: the value to get the hyperbolic tangent of\n\n    Returns:\n        The hyperbolic tangent\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"tanh\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef tanpi(x) -&gt; Any:\n    \"\"\"Get the tangent of pi times x\n\n    Args:\n        x: the value to get the tangent of pi times x of\n\n    Returns:\n        The tangent of pi times x\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"tanpi\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef atan2(y, x) -&gt; Any:\n    \"\"\"Get the inverse tangent of y/x\n\n    Args:\n        y: the numerator\n        x: the denominator\n\n    Returns:\n        The inverse tangent of y/x\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"atan2\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef append(x, values, after: int = -1) -&gt; Any:\n    \"\"\"Append values to the vector\n\n    Args:\n        x: the vector to append to\n        values: the values to append\n        after: the index to append after\n\n    Returns:\n        The vector with the values appended\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"append\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef colnames(x, nested: bool = True) -&gt; Any:\n    \"\"\"Get the column names\n\n    Args:\n        x: the data frame to get the column names of\n        nested: whether x is a nested data frame\n\n    Returns:\n        The column names\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"colnames\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef set_colnames(x, names, nested: bool = True) -&gt; Any:\n    \"\"\"Set the column names\n\n    Args:\n        x: the data frame to set the column names of\n        names: the column names to set\n        nested: whether the frame are nested\n\n    Returns:\n        The data frame with the column names set\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"set_colnames\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef rownames(x) -&gt; Any:\n    \"\"\"Get the row names\n\n    Args:\n        x: the data frame to get the row names of\n\n    Returns:\n        The row names\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rownames\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef set_rownames(x, names) -&gt; Any:\n    \"\"\"Set the row names\n\n    Args:\n        x: the data frame to set the row names of\n        names: the row names to set\n\n    Returns:\n        The data frame with the row names set\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"set_rownames\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef dim(x, nested: bool = True) -&gt; Any:\n    \"\"\"Get the dimensions\n\n    Args:\n        x: the data frame to get the dimensions of\n        nested: whether x is a nested data frame\n\n    Returns:\n        The dimensions\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"dim\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef diag(x, nrow=None, ncol=None) -&gt; Any:\n    \"\"\"Get the diagonal of a matrix\n\n    Args:\n        x: the matrix to get the diagonal of\n        nrow: the number of rows\n        ncol: the number of columns\n\n    Returns:\n        The diagonal of the matrix\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"diag\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef duplicated(x, incomparables=None, from_last: bool = False) -&gt; Any:\n    \"\"\"Get the duplicated values\n\n    Args:\n        x: the vector to get the duplicated values of\n        incomparables: the incomparables\n        from_last: whether to search from the last\n\n    Returns:\n        The duplicated values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"duplicated\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef intersect(x, y) -&gt; Any:\n    \"\"\"Get the intersection of two vectors\n\n    Args:\n        x: the first vector\n        y: the second vector\n\n    Returns:\n        The intersection of the two vectors\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"intersect\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef ncol(x, nested: bool = True) -&gt; Any:\n    \"\"\"Get the number of columns\n\n    Args:\n        x: the data frame to get the number of columns of\n        nested: whether x is a nested data frame\n\n    Returns:\n        The number of columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"ncol\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef nrow(x) -&gt; Any:\n    \"\"\"Get the number of rows\n\n    Args:\n        x: the data frame to get the number of rows of\n\n    Returns:\n        The number of rows\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"nrow\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef proportions(x, margin: int = 1) -&gt; Any:\n    \"\"\"Get the proportion table\n\n    Args:\n        x: the data frame to get the proportion table of\n        margin: the margin\n\n    Returns:\n        The proportion table\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"proportions\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef setdiff(x, y) -&gt; Any:\n    \"\"\"Get the difference of two vectors\n\n    Args:\n        x: the first vector\n        y: the second vector\n\n    Returns:\n        The difference of the two vectors\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"setdiff\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef setequal(x, y) -&gt; Any:\n    \"\"\"Check if two vectors are equal\n\n    Args:\n        x: the first vector\n        y: the second vector\n\n    Returns:\n        Whether the two vectors are equal\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"setequal\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef unique(x) -&gt; Any:\n    \"\"\"Get the unique values\n\n    Args:\n        x: the vector to get the unique values of\n\n    Returns:\n        The unique values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"unique\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef t(x) -&gt; Any:\n    \"\"\"Get the transpose\n\n    Args:\n        x: the matrix to get the transpose of\n\n    Returns:\n        The transpose\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"t\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef union(x, y) -&gt; Any:\n    \"\"\"Get the union of two vectors\n\n    Args:\n        x: the first vector\n        y: the second vector\n\n    Returns:\n        The union of the two vectors\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"union\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef max_col(x, ties_method: str = \"random\", nested: bool = True) -&gt; Any:\n    \"\"\"Get the maximum column\n\n    Args:\n        x: the data frame to get the maximum column of\n        ties_method: the ties method\n        nested: whether x is a nested data frame\n\n    Returns:\n        The maximum column\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"max_col\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef complete_cases(x) -&gt; Any:\n    \"\"\"Get the complete cases\n\n    Args:\n        x: the data frame to get the complete cases of\n\n    Returns:\n        The complete cases\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"complete_cases\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef head(x, n: int = 6) -&gt; Any:\n    \"\"\"Get the first n rows\n\n    Args:\n        x: the data frame to get the first n rows of\n        n: the number of rows to get\n\n    Returns:\n        The first n rows\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"head\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef tail(x, n: int = 6) -&gt; Any:\n    \"\"\"Get the last n rows\n\n    Args:\n        x: the data frame to get the last n rows of\n        n: the number of rows to get\n\n    Returns:\n        The last n rows\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"tail\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef which(x) -&gt; Any:\n    \"\"\"Get the indices of the non-zero values\n\n    Args:\n        x: the vector to get the indices of the non-zero values of\n\n    Returns:\n        The indices of the non-zero values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"which\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef which_max(x) -&gt; Any:\n    \"\"\"Get the index of the maximum value\n\n    Args:\n        x: the vector to get the index of the maximum value of\n\n    Returns:\n        The index of the maximum value\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"which_max\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef which_min(x) -&gt; Any:\n    \"\"\"Get the index of the minimum value\n\n    Args:\n        x: the vector to get the index of the minimum value of\n\n    Returns:\n        The index of the minimum value\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"which_min\", x)\n</code></pre>"},{"location":"api/source/datar.apis.dplyr/","title":"datar.apis.dplyr","text":""},{"location":"api/source/datar.apis.dplyr/","title":"SOURCE CODE datar.apis.dplyr DOCS","text":"<pre><code># import the variables with _ so that they are not imported by *\nfrom __future__ import annotations as _\nfrom typing import (\n    Any,\n    Callable as _Callable,\n    Sequence as _Sequence,\n    TypeVar as _TypeVar,\n)\n\nfrom pipda import (\n    register_verb as _register_verb,\n    register_func as _register_func,\n)\n\nfrom ..core.defaults import f as _f_symbolic\nfrom ..core.utils import (\n    NotImplementedByCurrentBackendError as _NotImplementedByCurrentBackendError,\n)\nfrom .base import intersect, setdiff, setequal, union  # noqa: F401\n\nT = _TypeVar(\"T\")\n\n\n@_register_verb(dependent=True)DOCS\ndef pick(_data: T, *args) -&gt; T:\n    \"\"\"Pick columns by name\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/pick.html\n\n    Args:\n        _data: The dataframe\n        *args: The columns to pick\n\n    Returns:\n        The picked dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"pick\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef across(_data: T, *args, _names=None, **kwargs) -&gt; T:\n    \"\"\"Apply the same transformation to multiple columns\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/across.html\n\n    Examples:\n        #\n        &gt;&gt;&gt; iris &gt;&gt; mutate(across(c(f.Sepal_Length, f.Sepal_Width), round))\n            Sepal_Length  Sepal_Width  Petal_Length  Petal_Width    Species\n               &lt;float64&gt;    &lt;float64&gt;     &lt;float64&gt;    &lt;float64&gt;   &lt;object&gt;\n        0            5.0          4.0           1.4          0.2     setosa\n        1            5.0          3.0           1.4          0.2     setosa\n        ..           ...          ...           ...          ...        ...\n\n        &gt;&gt;&gt; iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(\n        &gt;&gt;&gt;     across(starts_with(\"Sepal\"), mean)\n        &gt;&gt;&gt; )\n              Species  Sepal_Length  Sepal_Width\n             &lt;object&gt;     &lt;float64&gt;    &lt;float64&gt;\n        0      setosa         5.006        3.428\n        1  versicolor         5.936        2.770\n        2   virginica         6.588        2.974\n\n    Args:\n        _data: The dataframe.\n        *args: If given, the first 2 elements should be columns and functions\n            apply to each of the selected columns. The rest of them will be\n            the arguments for the functions.\n        _names: A glue specification that describes how to name\n            the output columns. This can use `{_col}` to stand for the\n            selected column name, and `{_fn}` to stand for the name of\n            the function being applied.\n            The default (None) is equivalent to `{_col}` for the\n            single function case and `{_col}_{_fn}` for the case where\n            a list is used for _fns. In such a case, `{_fn}` is 0-based.\n            To use 1-based index, use `{_fn1}`\n        _fn_context: Defines the context to evaluate the arguments for functions\n            if they are plain functions.\n            Note that registered functions will use its own context\n        **kwargs: Keyword arguments for the functions\n\n    Returns:\n        A dataframe with one column for each column and each function.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"across\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef c_across(_data: T, _cols=None) -&gt; T:\n    \"\"\"Apply the same transformation to multiple columns rowwisely\n\n    Args:\n        _data: The dataframe\n        _cols: The columns\n\n    Returns:\n        A rowwise tibble\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"c_across\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef if_any(_data, *args, _names=None, **kwargs) -&gt; Any:\n    \"\"\"Apply the same predicate function to a selection of columns and combine\n    the results True if any element is True.\n\n    See Also:\n        [`across()`](datar.dplyr.across.across)\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"if_any\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef if_all(_data, *args, _names=None, **kwargs) -&gt; Any:\n    \"\"\"Apply the same predicate function to a selection of columns and combine\n    the results True if all elements are True.\n\n    See Also:\n        [`across()`](datar.dplyr.across.across)\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"if_all\", _data)\n\n\n@_register_verb()DOCS\ndef symdiff(x: T, y: T) -&gt; T:\n    \"\"\"Get the symmetric difference of two dataframes\n\n    It computes the symmetric difference, i.e. all rows in x that aren't in y\n    and all rows in y that aren't in x.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/setops.html\n\n    Args:\n        x: A dataframe\n        y: A dataframe\n\n    Returns:\n        The symmetric difference of x and y\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"symdiff\", x)\n\n\n@_register_verb()DOCS\ndef arrange(_data, *args, _by_group=False, **kwargs) -&gt; Any:\n    \"\"\"orders the rows of a data frame by the values of selected columns.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/arrange.html\n\n    Args:\n        _data: A data frame\n        *series: Variables, or functions of variables.\n            Use desc() to sort a variable in descending order.\n        _by_group: If TRUE, will sort first by grouping variable.\n            Applies to grouped data frames only.\n        **kwargs: Name-value pairs that apply with mutate\n\n    Returns:\n        An object of the same type as _data.\n        The output has the following properties:\n            All rows appear in the output, but (usually) in a different place.\n            Columns are not modified.\n            Groups are not modified.\n            Data frame attributes are preserved.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"arrange\", _data)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef bind_rows(*data, _id=None, _copy: bool = True, **kwargs) -&gt; Any:\n    \"\"\"Bind rows of give dataframes\n\n    Original APIs https://dplyr.tidyverse.org/reference/bind.html\n\n    Args:\n        *data: Dataframes to combine\n        _id: The name of the id columns\n        _copy: If `False`, do not copy data unnecessarily.\n            Original API does not support this. This argument will be\n            passed by to `pandas.concat()` as `copy` argument.\n        **kwargs: A mapping of dataframe, keys will be used as _id col.\n\n    Returns:\n        The combined dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"bind_rows\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef bind_cols(*data, _name_repair=\"unique\", _copy: bool = True) -&gt; Any:\n    \"\"\"Bind columns of give dataframes\n\n    Note that unlike `dplyr`, mismatched dimensions are allowed and\n    missing rows will be filled with `NA`s\n\n    Args:\n        *data: Dataframes to bind\n        _name_repair: treatment of problematic column names:\n            - \"minimal\": No name repair or checks, beyond basic existence,\n            - \"unique\": Make sure names are unique and not empty,\n            - \"check_unique\": (default value), no name repair,\n                but check they are unique,\n            - \"universal\": Make the names unique and syntactic\n            - a function: apply custom name repair\n        _copy: If `False`, do not copy data unnecessarily.\n            Original API does not support this. This argument will be\n            passed by to `pandas.concat()` as `copy` argument.\n\n    Returns:\n        The combined dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"bind_cols\")\n\n\n# context\n@_register_func(plain=True)DOCS\ndef cur_column(_data, _name) -&gt; Any:\n    \"\"\"Get the current column\n\n    Args:\n        _data: The dataframe\n        _name: The column name\n\n    Returns:\n        The current column\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cur_column\")\n\n\n@_register_verb(dependent=True)DOCS\ndef cur_data(_data) -&gt; Any:\n    \"\"\"Get the current dataframe\n\n    Args:\n        _data: The dataframe\n\n    Returns:\n        The current dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cur_data\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef n(_data) -&gt; Any:\n    \"\"\"Get the current group size\n\n    Args:\n        _data: The dataframe\n\n    Returns:\n        The number of rows\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"n\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef cur_data_all(_data) -&gt; Any:\n    \"\"\"Get the current data for the current group including\n    the grouping variables\n\n    Args:\n        _data: The dataframe\n\n    Returns:\n        The current dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cur_data_all\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef cur_group(_data) -&gt; Any:\n    \"\"\"Get the current group\n\n    Args:\n        _data: The dataframe\n\n    Returns:\n        The current group\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cur_group\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef cur_group_id(_data) -&gt; Any:\n    \"\"\"Get the current group id\n\n    Args:\n        _data: The dataframe\n\n    Returns:\n        The current group id\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cur_group_id\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef cur_group_rows(_data) -&gt; Any:\n    \"\"\"Get the current group row indices\n\n    Args:\n        _data: The dataframe\n\n    Returns:\n        The current group rows\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cur_group_rows\", _data)\n\n\n# count_tally\n@_register_verb()DOCS\ndef count(\n    _data,\n    *args,\n    wt=None,\n    sort=False,\n    name=None,\n    _drop=None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Count the number of rows in each group\n\n    Original API:\n    https://dplyr.tidyverse.org/reference/count.html\n\n    Args:\n        _data: A data frame\n        *args: Variables, or functions of variables.\n            Use desc() to sort a variable in descending order.\n        wt: A variable or function of variables to weight by.\n        sort: If TRUE, the result will be sorted by the count.\n        name: The name of the count column.\n        _drop: If `False`, keep grouping variables even if they are not used.\n            Original API does not support this.\n        **kwargs: Name-value pairs that apply with mutate\n\n    Returns:\n        A data frame with the same number of rows as the number of groups.\n        The output has the following properties:\n            All rows appear in the output, but (usually) in a different place.\n            Columns are not modified.\n            Groups are not modified.\n            Data frame attributes are preserved.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"count\", _data)\n\n\n@_register_verb()DOCS\ndef tally(_data, wt=None, sort=False, name=None) -&gt; Any:\n    \"\"\"Count the number of rows in each group\n\n    Original API:\n    https://dplyr.tidyverse.org/reference/count.html\n\n    Args:\n        _data: A data frame\n        wt: A variable or function of variables to weight by.\n        sort: If TRUE, the result will be sorted by the count.\n        name: The name of the count column.\n\n    Returns:\n        A data frame with the same number of rows as the number of groups.\n        The output has the following properties:\n            All rows appear in the output, but (usually) in a different place.\n            Columns are not modified.\n            Groups are not modified.\n            Data frame attributes are preserved.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"tally\", _data)\n\n\n@_register_verb()DOCS\ndef add_count(_data, *args, wt=None, sort=False, name=\"n\", **kwargs) -&gt; Any:\n    \"\"\"Add a count column to a data frame\n\n    Original API:\n    https://dplyr.tidyverse.org/reference/count.html\n\n    Args:\n        _data: A data frame\n        *args: Variables, or functions of variables.\n            Use desc() to sort a variable in descending order.\n        wt: A variable or function of variables to weight by.\n        sort: If TRUE, the result will be sorted by the count.\n        name: The name of the count column.\n        **kwargs: Name-value pairs that apply with mutate\n\n    Returns:\n        A data frame with the same number of rows as the number of groups.\n        The output has the following properties:\n            All rows appear in the output, but (usually) in a different place.\n            Columns are not modified.\n            Groups are not modified.\n            Data frame attributes are preserved.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"add_count\", _data)\n\n\n@_register_verb()DOCS\ndef add_tally(_data, wt=None, sort=False, name=\"n\") -&gt; Any:\n    \"\"\"Add a count column to a data frame\n\n    Original API:\n    https://dplyr.tidyverse.org/reference/count.html\n\n    Args:\n        _data: A data frame\n        wt: A variable or function of variables to weight by.\n        sort: If TRUE, the result will be sorted by the count.\n        name: The name of the count column.\n\n    Returns:\n        A data frame with the same number of rows as the number of groups.\n        The output has the following properties:\n            All rows appear in the output, but (usually) in a different place.\n            Columns are not modified.\n            Groups are not modified.\n            Data frame attributes are preserved.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"add_tally\", _data)\n\n\n# desc\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef desc(x) -&gt; Any:\n    \"\"\"Transform a vector into a format that will be sorted in descending order\n\n    This is useful within arrange().\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/desc.html\n\n    Args:\n        x: vector to transform\n\n    Returns:\n        The descending order of x\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"desc\", x)\n\n\n# filter\n@_register_verb()DOCS\ndef filter_(_data, *conditions, _preserve: bool = False) -&gt; Any:\n    \"\"\"Filter a data frame based on conditions\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/filter.html\n\n    Args:\n        _data: A data frame\n        *conditions: Conditions to filter by.\n        _preserve: If `True`, keep grouping variables even if they are not used.\n\n    Returns:\n        The subset dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"filter\", _data)\n\n\n# distinct\n@_register_verb()DOCS\ndef distinct(\n    _data,\n    *args,\n    keep_all: bool = False,\n    _preserve: bool = False,\n) -&gt; Any:\n    \"\"\"Filter a data frame based on conditions\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/distinct.html\n\n    Args:\n        _data: A data frame\n        *args: Variables to filter by.\n        keep_all: If `True`, keep all rows that match.\n        _preserve: If `True`, keep grouping variables even if they are not used.\n\n    Returns:\n        The subset dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"distinct\", _data)\n\n\n@_register_verb()DOCS\ndef n_distinct(_data, na_rm: bool = True) -&gt; Any:\n    \"\"\"Count the number of distinct values\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/distinct.html\n\n    Args:\n        _data: A data frame\n        na_rm: If `True`, remove missing values before counting.\n\n    Returns:\n        The number of distinct values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"n_distinct\", _data)\n\n\n# glimpse\n@_register_verb()DOCS\ndef glimpse(_data, width: int = None, formatter=None) -&gt; Any:\n    \"\"\"Display a summary of a data frame\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/glimpse.html\n\n    Args:\n        _data: A data frame\n        width: Width of output, defaults to the width of the console.\n        formatter: A single-dispatch function to format a single element.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"glimpse\", _data)\n\n\n# slice\n@_register_verb()DOCS\ndef slice_(_data, *args, _preserve: bool = False) -&gt; Any:\n    \"\"\"Extract rows by their position\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/slice.html\n\n    Args:\n        _data: A data frame\n        *args: Positions to extract.\n        _preserve: If `True`, keep grouping variables even if they are not used.\n\n    Returns:\n        The subset dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"slice\", _data)\n\n\n@_register_verb()DOCS\ndef slice_head(_data, n: int = None, prop: float = None) -&gt; Any:\n    \"\"\"Extract the first rows\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/slice.html\n\n    Args:\n        _data: A data frame\n        n: Number of rows to extract.\n        prop: Proportion of rows to extract.\n\n    Returns:\n        The subset dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"slice_head\", _data)\n\n\n@_register_verb()DOCS\ndef slice_tail(_data, n: int = None, prop: float = None) -&gt; Any:\n    \"\"\"Extract the last rows\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/slice.html\n\n    Args:\n        _data: A data frame\n        n: Number of rows to extract.\n        prop: Proportion of rows to extract.\n\n    Returns:\n        The subset dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"slice_tail\", _data)\n\n\n@_register_verb()DOCS\ndef slice_sample(\n    _data,\n    n: int = 1,\n    prop: float = None,\n    weight_by=None,\n    replace: bool = False,\n) -&gt; Any:\n    \"\"\"Extract rows by sampling\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/slice.html\n\n    Args:\n        _data: A data frame\n        n: Number of rows to extract.\n        prop: Proportion of rows to extract.\n        weight_by: A variable or function of variables to weight by.\n        replace: If `True`, sample with replacement.\n\n    Returns:\n        The subset dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"slice_sample\", _data)\n\n\n@_register_verb()DOCS\ndef slice_min(\n    _data,\n    order_by,\n    n: int = 1,\n    prop: float = None,\n    with_ties: bool | str = None,\n) -&gt; Any:\n    \"\"\"Extract rows with the minimum value\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/slice.html\n\n    Args:\n        _data: A data frame\n        order_by: A variable or function of variables to order by.\n        n: Number of rows to extract.\n        prop: Proportion of rows to extract.\n        with_ties: If `True`, extract all rows with the minimum value.\n            If \"first\", extract the first row with the minimum value.\n            If \"last\", extract the last row with the minimum value.\n\n    Returns:\n        The subset dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"slice_min\", _data)\n\n\n@_register_verb()DOCS\ndef slice_max(\n    _data,\n    order_by,\n    n: int = 1,\n    prop: float = None,\n    with_ties: bool | str = None,\n) -&gt; Any:\n    \"\"\"Extract rows with the maximum value\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/slice.html\n\n    Args:\n        _data: A data frame\n        order_by: A variable or function of variables to order by.\n        n: Number of rows to extract.\n        prop: Proportion of rows to extract.\n        with_ties: If `True`, extract all rows with the maximum value.\n            If \"first\", extract the first row with the maximum value.\n            If \"last\", extract the last row with the maximum value.\n\n    Returns:\n        The subset dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"slice_max\", _data)\n\n\n# misc funs\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef between(x, left, right, inclusive: str = \"both\") -&gt; Any:\n    \"\"\"Check if a value is between two other values\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/between.html\n\n    Args:\n        x: A value\n        left: The left bound\n        right: The right bound\n        inclusive: Either `both`, `neither`, `left` or `right`.\n            Include boundaries. Whether to set each bound as closed or open.\n\n    Returns:\n        A bool value if `x` is scalar, otherwise an array of boolean values\n        Note that it will be always False when NA appears in x, left or right.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"between\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef cummean(x, na_rm: bool = False) -&gt; Any:\n    \"\"\"Cumulative mean\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/cumall.html\n\n    Args:\n        x: A numeric vector\n        na_rm: If `True`, remove missing values before computing.\n\n    Returns:\n        An array of cumulative means\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cummean\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef cumall(x) -&gt; Any:\n    \"\"\"Get cumulative bool. All cases after first False\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/cumall.html\n\n    Args:\n        x: A logical vector\n\n    Returns:\n        An array of cumulative conjunctions\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cumall\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef cumany(x) -&gt; Any:\n    \"\"\"Get cumulative bool. All cases after first True\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/cumany.html\n\n    Args:\n        x: A logical vector\n\n    Returns:\n        An array of cumulative disjunctions\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cumany\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef coalesce(x, *replace) -&gt; Any:\n    \"\"\"Replace missing values with the first non-missing value\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/coalesce.html\n\n    Args:\n        x: A vector\n        *replace: Values to replace missing values with.\n\n    Returns:\n        An array of values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"coalesce\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef consecutive_id(x, *args) -&gt; _Sequence[int]:\n    \"\"\"Generate consecutive ids\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/consecutive_id.html\n\n    Args:\n        x: A vector\n        *args: Other vectors\n\n    Returns:\n        A sequence of consecutive ids\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"consecutive_id\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef na_if(x, value) -&gt; Any:\n    \"\"\"Replace values with missing values\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/na_if.html\n\n    Args:\n        x: A vector\n        value: Values to replace with missing values.\n\n    Returns:\n        An array of values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"na_if\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef near(x, y, tol: float = 1e-8) -&gt; Any:\n    \"\"\"Check if values are approximately equal\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/near.html\n\n    Args:\n        x: A numeric vector\n        y: A numeric vector\n        tol: Tolerance\n\n    Returns:\n        An array of boolean values\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"near\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef nth(x, n, order_by=None, default=None) -&gt; Any:\n    \"\"\"Extract the nth element of a vector\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/nth.html\n\n    Args:\n        x: A vector\n        n: The index of the element to extract.\n        order_by: A variable or function of variables to order by.\n        default: A default value to return if `n` is out of bounds.\n\n    Returns:\n        A value\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"nth\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef first(x, order_by=None, default=None) -&gt; Any:\n    \"\"\"Extract the first element of a vector\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/nth.html\n\n    Args:\n        x: A vector\n        order_by: A variable or function of variables to order by.\n        default: A default value to return if `x` is empty.\n\n    Returns:\n        A value\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"first\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef last(x, order_by=None, default=None) -&gt; Any:\n    \"\"\"Extract the last element of a vector\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/nth.html\n\n    Args:\n        x: A vector\n        order_by: A variable or function of variables to order by.\n        default: A default value to return if `x` is empty.\n\n    Returns:\n        A value\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"last\", x)\n\n\n# group_by\n@_register_verb()DOCS\ndef group_by(_data, *args, _add: bool = False, _drop: bool = None) -&gt; Any:\n    \"\"\"Create a grouped frame\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_by.html\n\n    Args:\n        _data: A data frame\n        *args: A variable or function of variables to group by.\n        _add: If `True`, add grouping variables to an existing group.\n        _drop: If `True`, drop grouping variables from the output.\n\n    Returns:\n        A grouped frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_by\", _data)\n\n\n@_register_verb()DOCS\ndef ungroup(_data, *cols: str | int) -&gt; Any:\n    \"\"\"Remove grouping variables\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/ungroup.html\n\n    Args:\n        _data: A grouped frame\n        *cols: Columns to remove grouping variables from.\n\n    Returns:\n        A data frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"ungroup\", _data)\n\n\n@_register_verb()DOCS\ndef rowwise(_data, *cols: str | int) -&gt; Any:\n    \"\"\"Create a rowwise frame\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/rowwise.html\n\n    Args:\n        _data: A data frame\n        *cols: Columns to make rowwise.\n\n    Returns:\n        A rowwise frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rowwise\", _data)\n\n\n@_register_verb()DOCS\ndef group_by_drop_default(_data) -&gt; Any:\n    \"\"\"Get the default value of `_drop` of a frame\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_by.html\n\n    Args:\n        _data: A data frame\n\n    Returns:\n        A bool value\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_by_drop_default\", _data)\n\n\n@_register_verb()DOCS\ndef group_vars(_data) -&gt; Any:\n    \"\"\"Get the grouping variables of a frame\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_vars.html\n\n    Args:\n        _data: A grouped frame\n\n    Returns:\n        A list of grouping variables\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_vars\", _data)\n\n\n@_register_verb()DOCS\ndef group_indices(_data) -&gt; Any:\n    \"\"\"Get the group indices of a frame\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_indices.html\n\n    Args:\n        _data: A grouped frame\n\n    Returns:\n        A list of group indices\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_indices\", _data)\n\n\n@_register_verb()DOCS\ndef group_keys(_data) -&gt; Any:\n    \"\"\"Get the group keys of a frame\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_keys.html\n\n    Args:\n        _data: A grouped frame\n\n    Returns:\n        A list of group keys\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_keys\", _data)\n\n\n@_register_verb()DOCS\ndef group_size(_data) -&gt; Any:\n    \"\"\"Get the group sizes of a frame\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_size.html\n\n    Args:\n        _data: A grouped frame\n\n    Returns:\n        A list of group sizes\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_size\", _data)\n\n\n@_register_verb()DOCS\ndef group_rows(_data) -&gt; Any:\n    \"\"\"Get the group rows of a frame\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_rows.html\n\n    Args:\n        _data: A grouped frame\n\n    Returns:\n        A list of group rows\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_rows\", _data)\n\n\n@_register_verb()DOCS\ndef group_cols(_data) -&gt; Any:\n    \"\"\"Get the group columns of a frame\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_cols.html\n\n    Args:\n        _data: A grouped frame\n\n    Returns:\n        A list of group columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_cols\", _data)\n\n\n@_register_verb()DOCS\ndef group_data(_data) -&gt; Any:\n    \"\"\"Get the group data of a frame\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_data.html\n\n    Args:\n        _data: A grouped frame\n\n    Returns:\n        A list of group data\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_data\", _data)\n\n\n@_register_verb()DOCS\ndef n_groups(_data) -&gt; int:\n    \"\"\"Get the number of groups of a frame\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/n_groups.html\n\n    Args:\n        _data: A grouped frame\n\n    Returns:\n        An int value\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"n_groups\", _data)\n\n\n@_register_verb()DOCS\ndef group_map(_data, _f, *args, _keep: bool = False, **kwargs) -&gt; Any:\n    \"\"\"Apply a function to each group\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_map.html\n\n    Args:\n        _data: A grouped frame\n        _f: A function to apply to each group.\n        *args: Additional arguments to pass to `func`.\n        _keep: If `True`, keep the grouping variables in the output.\n        **kwargs: Additional keyword arguments to pass to `func`.\n\n    Returns:\n        A list of results\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_map\", _data)\n\n\n@_register_verb()DOCS\ndef group_modify(_data, _f, *args, _keep: bool = False, **kwargs) -&gt; Any:\n    \"\"\"Apply a function to each group\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_modify.html\n\n    Args:\n        _data: A grouped frame\n        _f: A function to apply to each group.\n        *args: Additional arguments to pass to `func`.\n        _keep: If `True`, keep the grouping variables in the output.\n        **kwargs: Additional keyword arguments to pass to `func`.\n\n    Returns:\n        A data frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_modify\", _data)\n\n\n@_register_verb()DOCS\ndef group_split(_data, *args, _keep: bool = False, **kwargs) -&gt; Any:\n    \"\"\"Split a grouped frame into a list of data frames\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_split.html\n\n    Args:\n        _data: A grouped frame\n        *args: Additional arguments to pass to `func`.\n        _keep: If `True`, keep the grouping variables in the output.\n        **kwargs: Additional keyword arguments to pass to `func`.\n\n    Returns:\n        A list of data frames\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_split\", _data)\n\n\n@_register_verb()DOCS\ndef group_trim(_data, _drop=None) -&gt; Any:\n    \"\"\"Remove empty groups\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_trim.html\n\n    Args:\n        _data: A grouped frame\n        _drop: See `group_by`.\n\n    Returns:\n        A grouped frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_trim\", _data)\n\n\n@_register_verb()DOCS\ndef group_walk(_data, _f, *args, _keep: bool = False, **kwargs) -&gt; Any:\n    \"\"\"Apply a function to each group\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/group_walk.html\n\n    Args:\n        _data: A grouped frame\n        _f: A function to apply to each group.\n        *args: Additional arguments to pass to `func`.\n        **kwargs: Additional keyword arguments to pass to `func`.\n\n    Returns:\n        A grouped frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"group_walk\", _data)\n\n\n@_register_verb()DOCS\ndef with_groups(_data, _groups, _func, *args, **kwargs) -&gt; Any:\n    \"\"\"Modify the grouping variables for a single operation.\n\n    Args:\n        _data: A data frame\n        _groups: columns passed by group_by\n            Use None to temporarily ungroup.\n        _func: Function to apply to regrouped data.\n\n    Returns:\n        The new data frame with operations applied.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"with_groups\", _data)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef if_else(condition, true, false, missing=None) -&gt; Any:\n    \"\"\"Where condition is TRUE, the matching value from true, where it's FALSE,\n    the matching value from false, otherwise missing.\n\n    Note that NAs will be False in condition if missing is not specified\n\n    Args:\n        condition: the conditions\n        true: and\n        false: Values to use for TRUE and FALSE values of condition.\n            They must be either the same length as condition, or length 1.\n        missing: If not None, will be used to replace missing values\n\n    Returns:\n        A series with values replaced.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"if_else\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef case_match(_x: T, *args, _default=None, _dtypes=None) -&gt; T:\n    \"\"\"This function allows you to vectorise multiple `switch()` statements.\n    Each case is evaluated sequentially and the first match for each element\n    determines the corresponding value in the output vector.\n    If no cases match, the `_default` is used.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/case_match.html\n\n    Args:\n        _x: A vector\n        *args: A series of condition-value pairs\n        _default: The default value\n        _dtypes: The data types of the output\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"case_match\", _x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef case_when(cond, value, *more_cases) -&gt; Any:\n    \"\"\"Vectorise multiple `if_else()` statements.\n\n    Args:\n        cond: A boolean vector\n        value: A vector with values to replace\n        *more_cases: A list of tuples (cond, value)\n\n    Returns:\n        A vector with values replaced.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"case_when\")\n\n\n# join\n@_register_verb()DOCS\ndef inner_join(\n    x,\n    y,\n    by=None,\n    copy: bool = False,\n    suffix: _Sequence[str] = (\"_x\", \"_y\"),\n    keep: bool = False,\n    na_matches: str = \"na\",\n    multiple: str = \"all\",\n    unmatched: str = \"drop\",\n    relationship: str = None,\n) -&gt; Any:\n    \"\"\"Inner join two data frames by matching rows.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/join.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        by: A list of column names to join by.\n            If None, use the intersection of the columns of x and y.\n        copy: If True, always copy the data.\n        suffix: A tuple of suffixes to apply to overlapping columns.\n        keep: If True, keep the grouping variables in the output.\n        na_matches: How should NA values be matched?\n            \"na\": NA values are equal.\n            \"never\": NA values are never matched.\n        multiple: How should multiple matches be handled?\n            \"all\": All matches are returned.\n            \"first\": The first match is returned.\n            \"last\": The last match is returned.\n            \"any\": Any of the matched rows in y\n        unmatched: How should unmatched keys that would result in dropped rows\n            be handled?\n            \"drop\": Drop unmatched keys.\n            \"error\": Raise an error.\n        relationship: The relationship between x and y.\n            None: No expected relationship.\n            \"one_to_one\": Each row in x matches at most one row in y.\n            \"one_to_many\": Each row in x matches zero or more rows in y.\n            \"many_to_one\": Each row in x matches at most one row in y.\n            \"many_to_many\": Each row in x matches zero or more rows in y.\n\n    Returns:\n        A data frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"inner_join\", x)\n\n\n@_register_verb()DOCS\ndef left_join(\n    x,\n    y,\n    by=None,\n    copy: bool = False,\n    suffix: _Sequence[str] = (\"_x\", \"_y\"),\n    keep: bool = False,\n    na_matches: str = \"na\",\n    multiple: str = \"all\",\n    unmatched: str = \"drop\",\n    relationship: str = None,\n) -&gt; Any:\n    \"\"\"Left join two data frames by matching rows.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/join.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        by: A list of column names to join by.\n            If None, use the intersection of the columns of x and y.\n        copy: If True, always copy the data.\n        suffix: A tuple of suffixes to apply to overlapping columns.\n        keep: If True, keep the grouping variables in the output.\n        na_matches: How should NA values be matched?\n            \"na\": NA values are equal.\n            \"never\": NA values are never matched.\n        multiple: How should multiple matches be handled?\n            \"all\": All matches are returned.\n            \"first\": The first match is returned.\n            \"last\": The last match is returned.\n            \"any\": Any of the matched rows in y\n        unmatched: How should unmatched keys that would result in dropped rows\n            be handled?\n            \"drop\": Drop unmatched keys.\n            \"error\": Raise an error.\n        relationship: The relationship between x and y.\n            None: No expected relationship.\n            \"one_to_one\": Each row in x matches at most one row in y.\n            \"one_to_many\": Each row in x matches zero or more rows in y.\n            \"many_to_one\": Each row in x matches at most one row in y.\n            \"many_to_many\": Each row in x matches zero or more rows in y.\n\n    Returns:\n        A data frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"left_join\", x)\n\n\n@_register_verb()DOCS\ndef right_join(\n    x,\n    y,\n    by=None,\n    copy: bool = False,\n    suffix: _Sequence[str] = (\"_x\", \"_y\"),\n    keep: bool = False,\n    na_matches: str = \"na\",\n    multiple: str = \"all\",\n    unmatched: str = \"drop\",\n    relationship: str = None,\n) -&gt; Any:\n    \"\"\"Right join two data frames by matching rows.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/join.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        by: A list of column names to join by.\n            If None, use the intersection of the columns of x and y.\n        copy: If True, always copy the data.\n        suffix: A tuple of suffixes to apply to overlapping columns.\n        keep: If True, keep the grouping variables in the output.\n        na_matches: How should NA values be matched?\n            \"na\": NA values are equal.\n            \"never\": NA values are never matched.\n        multiple: How should multiple matches be handled?\n            \"all\": All matches are returned.\n            \"first\": The first match is returned.\n            \"last\": The last match is returned.\n            \"any\": Any of the matched rows in y\n        unmatched: How should unmatched keys that would result in dropped rows\n            be handled?\n            \"drop\": Drop unmatched keys.\n            \"error\": Raise an error.\n        relationship: The relationship between x and y.\n            None: No expected relationship.\n            \"one_to_one\": Each row in x matches at most one row in y.\n            \"one_to_many\": Each row in x matches zero or more rows in y.\n            \"many_to_one\": Each row in x matches at most one row in y.\n            \"many_to_many\": Each row in x matches zero or more rows in y.\n\n    Returns:\n        A data frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"right_join\", x)\n\n\n@_register_verb()DOCS\ndef full_join(\n    x,\n    y,\n    by=None,\n    copy: bool = False,\n    suffix: _Sequence[str] = (\"_x\", \"_y\"),\n    keep: bool = False,\n    na_matches: str = \"na\",\n    multiple: str = \"all\",\n    unmatched: str = \"drop\",\n    relationship: str = None,\n) -&gt; Any:\n    \"\"\"Full join two data frames by matching rows.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/join.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        by: A list of column names to join by.\n            If None, use the intersection of the columns of x and y.\n        copy: If True, always copy the data.\n        suffix: A tuple of suffixes to apply to overlapping columns.\n        keep: If True, keep the grouping variables in the output.\n        na_matches: How should NA values be matched?\n            \"na\": NA values are equal.\n            \"never\": NA values are never matched.\n        multiple: How should multiple matches be handled?\n            \"all\": All matches are returned.\n            \"first\": The first match is returned.\n            \"last\": The last match is returned.\n            \"any\": Any of the matched rows in y\n        unmatched: How should unmatched keys that would result in dropped rows\n            be handled?\n            \"drop\": Drop unmatched keys.\n            \"error\": Raise an error.\n        relationship: The relationship between x and y.\n            None: No expected relationship.\n            \"one_to_one\": Each row in x matches at most one row in y.\n            \"one_to_many\": Each row in x matches zero or more rows in y.\n            \"many_to_one\": Each row in x matches at most one row in y.\n            \"many_to_many\": Each row in x matches zero or more rows in y.\n\n    Returns:\n        A data frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"full_join\", x)\n\n\n@_register_verb()DOCS\ndef semi_join(\n    x,\n    y,\n    by=None,\n    copy: bool = False,\n    na_matches: str = \"na\",\n) -&gt; Any:\n    \"\"\"Semi join two data frames by matching rows.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/join.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        by: A list of column names to join by.\n            If None, use the intersection of the columns of x and y.\n        copy: If True, always copy the data.\n        na_matches: How should NA values be matched?\n            \"na\": NA values are equal.\n            \"never\": NA values are never matched.\n\n    Returns:\n        A data frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"semi_join\", x)\n\n\n@_register_verb()DOCS\ndef anti_join(\n    x,\n    y,\n    by=None,\n    copy: bool = False,\n    na_matches: str = \"na\",\n) -&gt; Any:\n    \"\"\"Anti join two data frames by matching rows.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/join.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        by: A list of column names to join by.\n            If None, use the intersection of the columns of x and y.\n        copy: If True, always copy the data.\n        na_matches: How should NA values be matched?\n            \"na\": NA values are equal.\n            \"never\": NA values are never matched.\n\n    Returns:\n        A data frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"anti_join\", x)\n\n\n@_register_verb()DOCS\ndef nest_join(\n    x,\n    y,\n    by=None,\n    copy: bool = False,\n    keep: bool = False,\n    name=None,\n    na_matches: str = \"na\",\n    unmatched: str = \"drop\",\n) -&gt; Any:\n    \"\"\"Nest join two data frames by matching rows.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/join.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        by: A list of column names to join by.\n            If None, use the intersection of the columns of x and y.\n        copy: If True, always copy the data.\n        keep: If True, keep the grouping variables in the output.\n        name: The name of the column to store the nested data frame.\n        na_matches: How should NA values be matched?\n            \"na\": NA values are equal.\n            \"never\": NA values are never matched.\n        unmatched: How should unmatched keys that would result in dropped rows\n            be handled?\n            \"drop\": Drop unmatched keys.\n            \"error\": Raise an error.\n\n    Returns:\n        A data frame\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"nest_join\", x)\n\n\n@_register_verb()DOCS\ndef cross_join(\n    x: T,\n    y: T,\n    copy: bool = False,\n    suffix: _Sequence[str] = (\"_x\", \"_y\"),\n) -&gt; T:\n    \"\"\"Cross joins match each row in x to every row in y, resulting in a\n    data frame with nrow(x) * nrow(y) rows.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/cross_join.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        copy: If True, always copy the data.\n        suffix: A tuple of suffixes to apply to overlapping columns.\n\n    Returns:\n        An object of the same type as x (including the same groups).\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"cross_join\", x)\n\n\n# lead/lag\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef lead(x, n=1, default=None, order_by=None) -&gt; Any:\n    \"\"\"Shift a vector by `n` positions.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/lead.html\n\n    Args:\n        x: A vector\n        n: The number of positions to shift.\n        default: The default value to use for positions that don't exist.\n        order_by: A vector of column names to order by.\n\n    Returns:\n        A vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"lead\", x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef lag(x, n=1, default=None, order_by=None) -&gt; Any:\n    \"\"\"Shift a vector by `n` positions.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/lag.html\n\n    Args:\n        x: A vector\n        n: The number of positions to shift.\n        default: The default value to use for positions that don't exist.\n        order_by: A vector of column names to order by.\n\n    Returns:\n        A vector\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"lag\", x)\n\n\n# mutate\n@_register_verb()DOCS\ndef mutate(\n    _data, *args, _keep: str = \"all\", _before=None, _after=None, **kwargs\n) -&gt; Any:\n    \"\"\"Add new columns to a data frame.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/mutate.html\n\n    Args:\n        _data: A data frame\n        _keep: allows you to control which columns from _data are retained\n            in the output:\n            - \"all\", the default, retains all variables.\n            - \"used\" keeps any variables used to make new variables;\n              it's useful for checking your work as it displays inputs and\n              outputs side-by-side.\n            - \"unused\" keeps only existing variables not used to make new\n                variables.\n            - \"none\", only keeps grouping keys (like transmute()).\n        _before: A list of column names to put the new columns before.\n        _after: A list of column names to put the new columns after.\n        *args: and\n        **kwargs: Name-value pairs. The name gives the name of the column\n            in the output. The value can be:\n            - A vector of length 1, which will be recycled to the correct\n                length.\n            - A vector the same length as the current group (or the whole\n                data frame if ungrouped).\n            - None to remove the column\n\n    Returns:\n        An object of the same type as _data. The output has the following\n        properties:\n        - Rows are not affected.\n        - Existing columns will be preserved according to the _keep\n            argument. New columns will be placed according to the\n            _before and _after arguments. If _keep = \"none\"\n            (as in transmute()), the output order is determined only\n            by ..., not the order of existing columns.\n        - Columns given value None will be removed\n        - Groups will be recomputed if a grouping variable is mutated.\n        - Data frame attributes are preserved.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"mutate\", _data)\n\n\n@_register_verb()DOCS\ndef transmute(_data, *args, _before=None, _after=None, **kwargs) -&gt; Any:\n    \"\"\"Add new columns to a data frame and remove existing columns\n    using mutate with `_keep=\"none\"`.\n\n    The original API:\n    https://dplyr.tidyverse.org/reference/mutate.html\n\n    Args:\n        _data: A data frame\n        _before: A list of column names to put the new columns before.\n        _after: A list of column names to put the new columns after.\n        *args: and\n        **kwargs: Name-value pairs. The name gives the name of the column\n            in the output. The value can be:\n            - A vector of length 1, which will be recycled to the correct\n                length.\n            - A vector the same length as the current group (or the whole\n                data frame if ungrouped).\n            - None to remove the column\n\n    Returns:\n        An object of the same type as _data. The output has the following\n        properties:\n        - Rows are not affected.\n        - Existing columns will be preserved according to the _keep\n            argument. New columns will be placed according to the\n            _before and _after arguments. If _keep = \"none\"\n            (as in transmute()), the output order is determined only\n            by ..., not the order of existing columns.\n        - Columns given value None will be removed\n        - Groups will be recomputed if a grouping variable is mutated.\n        - Data frame attributes are preserved.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"transmute\", _data)\n\n\n# order_by\n@_register_func(plain=True)DOCS\ndef order_by(order, call) -&gt; Any:\n    \"\"\"Order the data by the given order\n\n    Note:\n        This function should be called as an argument\n        of a verb. If you want to call it regularly, try `with_order()`\n\n    Examples:\n        &gt;&gt;&gt; df = tibble(x=c[1:6])\n        &gt;&gt;&gt; df &gt;&gt; mutate(y=order_by(c[5:], cumsum(f.x)))\n        &gt;&gt;&gt; # df.y:\n        &gt;&gt;&gt; # 15, 14, 12, 9, 5\n\n    Args:\n        order: An iterable to control the data order\n        data: The data to be ordered\n\n    Returns:\n        A Function expression for verb to evaluate.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"order_by\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef with_order(order, func, x, *args, **kwargs) -&gt; Any:\n    \"\"\"Control argument and result of a window function\n\n    Examples:\n        &gt;&gt;&gt; with_order([5,4,3,2,1], cumsum, [1,2,3,4,5])\n        &gt;&gt;&gt; # 15, 14, 12, 9, 5\n\n    Args:\n        order: An iterable to order the arugment and result\n        func: The window function\n        x: The first arugment for the function\n        *args: and\n        **kwargs: Other arugments for the function\n\n    Returns:\n        The ordered result or an expression if there is expression in arguments\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"with_order\", order)\n\n\n# pull\n@_register_verb()DOCS\ndef pull(_data, var: str | int = -1, name=None, to=None) -&gt; Any:\n    \"\"\"Pull a series or a dataframe from a dataframe\n\n    Args:\n        _data: The dataframe\n        var: The column to pull, either the name or the index\n        name: The name of the pulled value\n            - If `to` is frame, or the value pulled is data frame, it will be\n              the column names\n            - If `to` is series, it will be the series name. If multiple names\n              are given, only the first name will be used.\n            - If `to` is series, but value pulled is a data frame, then a\n              dictionary of series with the series names as keys or given `name`\n              as keys.\n        to: Type of data to return.\n            Only works when pulling `a` for name `a$b`\n            - series: Return a pandas Series object\n              Group information will be lost\n              If pulled value is a dataframe, it will return a dict of series,\n              with the series names or the `name` provided.\n            - array: Return a numpy.ndarray object\n            - frame: Return a DataFrame with that column\n            - list: Return a python list\n            - dict: Return a dict with `name` as keys and pulled value as values\n              Only a single column is allowed to pull\n            - If not provided: `series` when pulled data has only one columns.\n                `dict` if `name` provided and has the same length as the pulled\n                single column. Otherwise `frame`.\n\n    Returns:\n        The data according to `to`\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"pull\", _data)\n\n\ndef row_number(x=_f_symbolic) -&gt; Any:DOCS\n    \"\"\"Get the row number of x\n\n    Note that this function doesn't support piping.\n\n    Args:\n        x: The data to get row number\n            Defaults to `Symbolic()` so the whole data is used by default\n            when called `row_number()`\n\n    Returns:\n        The row number\n    \"\"\"\n    return row_number_(x, __ast_fallback=\"normal\")\n\n\n@_register_func(pipeable=True, dispatchable=True)\ndef row_number_(x) -&gt; Any:\n    raise _NotImplementedByCurrentBackendError(\"row_number\", x)\n\n\ndef ntile(x=_f_symbolic, *, n: int = None) -&gt; Any:DOCS\n    \"\"\"a rough rank, which breaks the input vector into n buckets.\n    The size of the buckets may differ by up to one, larger buckets\n    have lower rank.\n\n    Note that this function doesn't support piping.\n\n    Args:\n        x: The data to get  rownumber\n            Defaults to `Symbolic()` so the whole data is used by default\n            when called `ntile(n=...)`\n        n: The number of groups to divide the data into\n\n    Returns:\n        The row number\n    \"\"\"\n    return ntile_(x, n=n, __ast_fallback=\"normal\")\n\n\n@_register_func(pipeable=True, dispatchable=True)\ndef ntile_(x, *, n: int = None) -&gt; Any:\n    raise _NotImplementedByCurrentBackendError(\"ntile\", x)\n\n\ndef min_rank(x=_f_symbolic, *, na_last: str = \"keep\") -&gt; Any:DOCS\n    \"\"\"Get the min rank of x\n\n    Note that this function doesn't support piping.\n\n    Args:\n        x: The data to get row number\n            Defaults to `Symbolic()` so the whole data is used by default\n            when called `min_rank()`\n        na_last: How NA values are ranked\n            - \"keep\": NA values are ranked at the end\n            - \"top\": NA values are ranked at the top\n            - \"bottom\": NA values are ranked at the bottom\n\n    Returns:\n        The row number\n    \"\"\"\n    return min_rank_(x, na_last=na_last, __ast_fallback=\"normal\")\n\n\n@_register_func(pipeable=True, dispatchable=True)\ndef min_rank_(x, *, na_last: str = \"keep\") -&gt; Any:\n    raise _NotImplementedByCurrentBackendError(\"min_rank\", x)\n\n\ndef dense_rank(x=_f_symbolic, *, na_last: str = \"keep\") -&gt; Any:DOCS\n    \"\"\"Get the dense rank of x\n\n    Note that this function doesn't support piping.\n\n    Args:\n        x: The data to get row number\n            Defaults to `Symbolic()` so the whole data is used by default\n            when called `dense_rank()`\n        na_last: How NA values are ranked\n            - \"keep\": NA values are ranked at the end\n            - \"top\": NA values are ranked at the top\n            - \"bottom\": NA values are ranked at the bottom\n\n    Returns:\n        The row number\n    \"\"\"\n    return dense_rank_(x, na_last=na_last, __ast_fallback=\"normal\")\n\n\n@_register_func(pipeable=True, dispatchable=True)\ndef dense_rank_(x, *, na_last: str = \"keep\") -&gt; Any:\n    raise _NotImplementedByCurrentBackendError(\"dense_rank\", x)\n\n\ndef percent_rank(x=_f_symbolic, *, na_last: str = \"keep\") -&gt; Any:DOCS\n    \"\"\"Get the percent rank of x\n\n    Note that this function doesn't support piping.\n\n    Args:\n        x: The data to get row number\n            Defaults to `Symbolic()` so the whole data is used by default\n            when called `percent_rank()`\n        na_last: How NA values are ranked\n            - \"keep\": NA values are ranked at the end\n            - \"top\": NA values are ranked at the top\n            - \"bottom\": NA values are ranked at the bottom\n\n    Returns:\n        The row number\n    \"\"\"\n    return percent_rank_(x, na_last=na_last, __ast_fallback=\"normal\")\n\n\n@_register_func(pipeable=True, dispatchable=True)\ndef percent_rank_(x, *, na_last: str = \"keep\") -&gt; Any:\n    raise _NotImplementedByCurrentBackendError(\"percent_rank\", x)\n\n\ndef cume_dist(x=_f_symbolic, *, na_last: str = \"keep\") -&gt; Any:DOCS\n    \"\"\"Get the cume_dist of x\n\n    Note that this function doesn't support piping.\n\n    Args:\n        x: The data to get row number\n            Defaults to `Symbolic()` so the whole data is used by default\n            when called `cume_dist()`\n        na_last: How NA values are ranked\n            - \"keep\": NA values are ranked at the end\n            - \"top\": NA values are ranked at the top\n            - \"bottom\": NA values are ranked at the bottom\n\n    Returns:\n        The row number\n    \"\"\"\n    return cume_dist_(x, na_last=na_last, __ast_fallback=\"normal\")\n\n\n@_register_func(pipeable=True, dispatchable=True)\ndef cume_dist_(x, *, na_last: str = \"keep\") -&gt; Any:\n    raise _NotImplementedByCurrentBackendError(\"cume_dist\", x)\n\n\n# recode\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef recode(_x, *args, _default=None, _missing=None, **kwargs) -&gt; Any:\n    \"\"\"Recode a vector, replacing elements in it\n\n    Args:\n        x: A vector to modify\n        *args: and\n        **kwargs: replacements\n        _default: If supplied, all values not otherwise matched will be\n            given this value. If not supplied and if the replacements are\n            the same type as the original values in series, unmatched values\n            are not changed. If not supplied and if the replacements are\n            not compatible, unmatched values are replaced with np.nan.\n        _missing: If supplied, any missing values in .x will be replaced\n            by this value.\n\n    Returns:\n        The vector with values replaced\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"recode\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef recode_factor(\n    _x,\n    *args,\n    _default=None,\n    _missing=None,\n    _ordered: bool = False,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Recode a factor, replacing levels in it\n\n    Args:\n        x: A factor to modify\n        *args: and\n        **kwargs: replacements\n        _default: If supplied, all values not otherwise matched will be\n            given this value. If not supplied and if the replacements are\n            the same type as the original values in series, unmatched values\n            are not changed. If not supplied and if the replacements are\n            not compatible, unmatched values are replaced with np.nan.\n        _missing: If supplied, any missing values in .x will be replaced\n            by this value.\n        _ordered: If True, the factor will be ordered\n\n    Returns:\n        The factor with levels replaced\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"recode_factor\")\n\n\n@_register_verb()DOCS\ndef relocate(\n    _data,\n    *args,\n    _before: int | str = None,\n    _after: int | str = None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"change column positions\n\n    See original API\n    https://dplyr.tidyverse.org/reference/relocate.html\n\n    Args:\n        _data: A data frame\n        *args: and\n        **kwargs: Columns to rename and move\n        _before: and\n        _after: Destination. Supplying neither will move columns to\n            the left-hand side; specifying both is an error.\n\n    Returns:\n        An object of the same type as .data. The output has the following\n        properties:\n        - Rows are not affected.\n        - The same columns appear in the output, but (usually) in a\n            different place.\n        - Data frame attributes are preserved.\n        - Groups are not affected\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"relocate\", _data)\n\n\n@_register_verb()DOCS\ndef rename(_data, **kwargs) -&gt; Any:\n    \"\"\"Rename columns\n\n    See original API\n    https://dplyr.tidyverse.org/reference/rename.html\n\n    Args:\n        _data: A data frame\n        **kwargs: Columns to rename\n\n    Returns:\n        The dataframe with new names\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rename\", _data)\n\n\n@_register_verb()DOCS\ndef rename_with(_data, _fn, *args, **kwargs) -&gt; Any:\n    \"\"\"Rename columns with a function\n\n    See original API\n    https://dplyr.tidyverse.org/reference/rename.html\n\n    Args:\n        _data: A data frame\n        _fn: A function to apply to column names\n        *args: the columns to rename and non-keyword arguments for the `_fn`.\n            If `*args` is not provided, then assuming all columns, and\n            no non-keyword arguments are allowed to pass to the function, use\n            keyword arguments instead.\n        **kwargs: keyword arguments for `_fn`\n\n    Returns:\n        The dataframe with new names\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rename_with\", _data)\n\n\n# rows\n@_register_verb()DOCS\ndef rows_insert(\n    x,\n    y,\n    by=None,\n    conflict: str = \"error\",\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Insert rows from y into x\n\n    See original API\n    https://dplyr.tidyverse.org/reference/rows.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        by: An unnamed character vector giving the key columns.\n            The key columns must exist in both x and y.\n            Keys typically uniquely identify each row, but this is only\n            enforced for the key values of y\n            By default, we use the first column in y, since the first column is\n            a reasonable place to put an identifier variable.\n        conflict: How to handle conflicts\n            - \"error\": Throw an error\n            - \"ignore\": Ignore conflicts\n        **kwargs: Additional arguments to pass to the backend, such as\n            `copy` and `in_place`. Depends on the backend implementation.\n\n    Returns:\n        A data frame with all existing rows and potentially new rows\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rows_insert\", x)\n\n\n@_register_verb()DOCS\ndef rows_update(\n    x,\n    y,\n    by=None,\n    unmatched: str = \"error\",\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Update rows in x with values from y\n\n    See original API\n    https://dplyr.tidyverse.org/reference/rows.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        by: An unnamed character vector giving the key columns.\n            The key columns must exist in both x and y.\n            Keys typically uniquely identify each row, but this is only\n            enforced for the key values of y\n            By default, we use the first column in y, since the first column is\n            a reasonable place to put an identifier variable.\n        unmatched: how should keys in y that are unmatched by the keys\n            in x be handled?\n            One of -\n            \"error\", the default, will error if there are any keys in y that\n            are unmatched by the keys in x.\n            \"ignore\" will ignore rows in y with keys that are unmatched\n            by the keys in x.\n        **kwargs: Additional arguments to pass to the backend, such as\n            `copy` and `in_place`. Depends on the backend implementation.\n\n    Returns:\n        A data frame with all existing rows and potentially new rows\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rows_update\", x)\n\n\n@_register_verb()DOCS\ndef rows_patch(\n    x,\n    y,\n    by=None,\n    unmatched: str = \"error\",\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Patch rows in x with values from y\n\n    See original API\n    https://dplyr.tidyverse.org/reference/rows.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        by: An unnamed character vector giving the key columns.\n            The key columns must exist in both x and y.\n            Keys typically uniquely identify each row, but this is only\n            enforced for the key values of y\n            By default, we use the first column in y, since the first column is\n            a reasonable place to put an identifier variable.\n        unmatched: how should keys in y that are unmatched by the keys\n            in x be handled?\n            One of -\n            \"error\", the default, will error if there are any keys in y that\n            are unmatched by the keys in x.\n            \"ignore\" will ignore rows in y with keys that are unmatched\n            by the keys in x.\n        **kwargs: Additional arguments to pass to the backend, such as\n            `copy` and `in_place`. Depends on the backend implementation.\n\n    Returns:\n        A data frame with NA values overwritten and the number of rows preserved\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rows_patch\", x)\n\n\n@_register_verb()DOCS\ndef rows_upsert(x, y, by=None, **kwargs) -&gt; Any:\n    \"\"\"Upsert rows in x with values from y\n\n    See original API\n    https://dplyr.tidyverse.org/reference/rows.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        by: An unnamed character vector giving the key columns.\n            The key columns must exist in both x and y.\n            Keys typically uniquely identify each row, but this is only\n            enforced for the key values of y\n            By default, we use the first column in y, since the first column is\n            a reasonable place to put an identifier variable.\n        **kwargs: Additional arguments to pass to the backend, such as\n            `copy` and `in_place`. Depends on the backend implementation.\n\n    Returns:\n        A data frame with inserted or updated depending on whether or not\n        the key value in y already exists in x. Key values in y must be unique.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rows_upsert\", x)\n\n\n@_register_verb()DOCS\ndef rows_delete(\n    x,\n    y,\n    by=None,\n    unmatched: str = \"error\",\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Delete rows in x that match keys in y\n\n    See original API\n    https://dplyr.tidyverse.org/reference/rows.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        by: An unnamed character vector giving the key columns.\n            The key columns must exist in both x and y.\n            Keys typically uniquely identify each row, but this is only\n            enforced for the key values of y\n            By default, we use the first column in y, since the first column is\n            a reasonable place to put an identifier variable.\n        unmatched: how should keys in y that are unmatched by the keys\n            in x be handled?\n            One of -\n            \"error\", the default, will error if there are any keys in y that\n            are unmatched by the keys in x.\n            \"ignore\" will ignore rows in y with keys that are unmatched\n            by the keys in x.\n        **kwargs: Additional arguments to pass to the backend, such as\n            `copy` and `in_place`. Depends on the backend implementation.\n\n    Returns:\n        A data frame with rows deleted\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rows_delete\", x)\n\n\n@_register_verb()DOCS\ndef rows_append(x, y, **kwargs) -&gt; Any:\n    \"\"\"Append rows in y to x\n\n    See original API\n    https://dplyr.tidyverse.org/reference/rows.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n        **kwargs: Additional arguments to pass to the backend, such as\n            `copy` and `in_place`. Depends on the backend implementation.\n\n    Returns:\n        A data frame with rows appended\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rows_append\", x)\n\n\n@_register_verb()DOCS\ndef select(_data, *args, **kwargs) -&gt; Any:\n    \"\"\"Select columns from a data frame.\n\n    See original API\n    https://dplyr.tidyverse.org/reference/select.html\n\n    Args:\n        _data: A data frame\n        *args: A list of columns to select\n        **kwargs: A list of columns to select\n\n    Returns:\n        A data frame with only the selected columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"select\", _data)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef union_all(x, y) -&gt; Any:\n    \"\"\"Combine two data frames together.\n\n    See original API\n    https://dplyr.tidyverse.org/reference/setops.html\n\n    Args:\n        x: A data frame\n        y: A data frame\n\n    Returns:\n        A data frame with rows from x and y\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"union_all\", x)\n\n\n@_register_verb()DOCS\ndef summarise(_data, *args, _groups: str = None, **kwargs) -&gt; Any:\n    \"\"\"Summarise a data frame.\n\n    See original API\n    https://dplyr.tidyverse.org/reference/summarise.html\n\n    Args:\n        _data: A data frame\n        _groups: Grouping structure of the result.\n            - \"drop_last\": dropping the last level of grouping.\n            - \"drop\": All levels of grouping are dropped.\n            - \"keep\": Same grouping structure as _data.\n            - \"rowwise\": Each row is its own group.\n        *args: and\n        **kwargs: Name-value pairs, where value is the summarized\n            data for each group\n\n    Returns:\n        A data frame with the summarised columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"summarise\", _data)\n\n\nsummarize = summarise\n\n\n@_register_verb(dependent=True)DOCS\ndef where(_data, fn: _Callable) -&gt; Any:\n    \"\"\"Selects the variables for which a function returns True.\n\n    See original API\n    https://dplyr.tidyverse.org/reference/filter.html\n\n    Args:\n        _data: A data frame\n        fn: A function that returns True or False.\n            Currently it has to be `register_func/func_factory\n            registered function purrr-like formula not supported yet.\n\n    Returns:\n        The matched columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"where\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef everything(_data) -&gt; Any:\n    \"\"\"Select all variables.\n\n    See original API\n    https://dplyr.tidyverse.org/reference/select.html\n\n    Args:\n        _data: A data frame\n\n    Returns:\n        All columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"everything\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef last_col(_data, offset: int = 0, vars=None) -&gt; Any:\n    \"\"\"Select the last column.\n\n    See original API\n    https://dplyr.tidyverse.org/reference/select.html\n\n    Args:\n        _data: A data frame\n        offset: The offset of the last column\n        vars: A list of columns to select\n\n    Returns:\n        The last column\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"last_col\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef starts_with(_data, match, ignore_case: bool = True, vars=None) -&gt; Any:\n    \"\"\"Select columns that start with a string.\n\n    See original API\n    https://dplyr.tidyverse.org/reference/select.html\n\n    Args:\n        _data: A data frame\n        match: The string to match\n        ignore_case: Ignore case when matching\n        vars: A list of columns to select\n\n    Returns:\n        The matched columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"starts_with\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef ends_with(_data, match, ignore_case: bool = True, vars=None) -&gt; Any:\n    \"\"\"Select columns that end with a string.\n\n    See original API\n    https://dplyr.tidyverse.org/reference/select.html\n\n    Args:\n        _data: A data frame\n        match: The string to match\n        ignore_case: Ignore case when matching\n        vars: A list of columns to select\n\n    Returns:\n        The matched columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"ends_with\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef contains(_data, match, ignore_case: bool = True, vars=None) -&gt; Any:\n    \"\"\"Select columns that contain a string.\n\n    See original API\n    https://dplyr.tidyverse.org/reference/select.html\n\n    Args:\n        _data: A data frame\n        match: The string to match\n        ignore_case: Ignore case when matching\n        vars: A list of columns to select\n\n    Returns:\n        The matched columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"contains\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef matches(_data, match, ignore_case: bool = True, vars=None) -&gt; Any:\n    \"\"\"Select columns that match a regular expression.\n\n    See original API\n    https://dplyr.tidyverse.org/reference/select.html\n\n    Args:\n        _data: A data frame\n        match: The regular expression to match\n        ignore_case: Ignore case when matching\n        vars: A list of columns to select\n\n    Returns:\n        The matched columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"matches\", _data)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef num_range(prefix: str, range_, width: int = None) -&gt; Any:\n    \"\"\"Matches a numerical range like x01, x02, x03.\n\n    Args:\n        _data: The data piped in\n        prefix: A prefix that starts the numeric range.\n        range_: A sequence of integers, like `range(3)` (produces `0,1,2`).\n        width: Optionally, the \"width\" of the numeric range.\n            For example, a range of 2 gives \"01\", a range of three \"001\", etc.\n\n    Returns:\n        A list of ranges with prefix.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"num_range\")\n\n\n@_register_verb(dependent=True)DOCS\ndef all_of(_data, x) -&gt; Any:\n    \"\"\"For strict selection.\n\n    If any of the variables in the character vector is missing,\n    an error is thrown.\n\n    Args:\n        _data: The data piped in\n        x: A set of variables to match the columns\n\n    Returns:\n        The matched column names\n\n    Raises:\n        ColumnNotExistingError: When any of the elements in `x` does not exist\n            in `_data` columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"all_of\", _data)\n\n\n@_register_verb(dependent=True)DOCS\ndef any_of(_data, x, vars=None) -&gt; Any:\n    \"\"\"For strict selection.\n\n    If any of the variables in the character vector is missing,\n    an error is thrown.\n\n    Args:\n        _data: The data piped in\n        x: A set of variables to match the columns\n        vars: A list of columns to select\n\n    Returns:\n        The matched column names\n\n    Raises:\n        ColumnNotExistingError: When any of the elements in `x` does not exist\n            in `_data` columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"any_of\", _data)\n</code></pre>"},{"location":"api/source/datar.apis.forcats/","title":"datar.apis.forcats","text":""},{"location":"api/source/datar.apis.forcats/","title":"SOURCE CODE datar.apis.forcats DOCS","text":"<pre><code>from typing import Any\n\nfrom pipda import register_func as _register_func\n\nfrom ..core.utils import (\n    NotImplementedByCurrentBackendError as _NotImplementedByCurrentBackendError,\n)\nfrom .base import as_factor  # noqa: F401\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_relevel(_f, *lvls, after: int = None) -&gt; Any:\n    \"\"\"Reorder factor levels by hand\n\n    Args:\n        _f: A factor (categoriccal), or a string vector\n        *lvls: Either a function (then `len(lvls)` should equal to `1`) or\n            the new levels.\n            A function will be called with the current levels as input, and the\n            return value (which must be a character vector) will be used to\n            relevel the factor.\n            Any levels not mentioned will be left in their existing order,\n            by default after the explicitly mentioned levels.\n        after: Where should the new values be placed?\n\n    Returns:\n        The factor with levels replaced\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_relevel\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_inorder(_f, ordered: bool = None) -&gt; Any:\n    \"\"\"Reorder factor levels by first appearance\n\n    Args:\n        _f: A factor\n        ordered: A logical which determines the \"ordered\" status of the\n            output factor.\n\n    Returns:\n        The factor with levels reordered\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_inorder\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_infreq(_f, ordered: bool = None) -&gt; Any:\n    \"\"\"Reorder factor levels by frequency\n\n    Args:\n        _f: A factor\n        ordered: A logical which determines the \"ordered\" status of the\n            output factor.\n\n    Returns:\n        The factor with levels reordered\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_infreq\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_inseq(_f, ordered: bool = None) -&gt; Any:\n    \"\"\"Reorder factor levels by sequence\n\n    Args:\n        _f: A factor\n        ordered: A logical which determines the \"ordered\" status of the\n            output factor.\n\n    Returns:\n        The factor with levels reordered\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_inseq\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_reorder(_f, _x, *args, _fun=None, _desc: bool = False, **kwargs) -&gt; Any:\n    \"\"\"Reorder factor levels by a function (default: median)\n\n    Args:\n        _f: A factor\n        _x: The data to be used to reorder the factor\n        _fun: A function to be used to reorder the factor\n        _desc: If `True`, the factor will be reordered in descending order\n        *args: Extra arguments to be passed to `_fun`\n        **kwargs: Extra keyword arguments to be passed to `_fun`\n\n    Returns:\n        The factor with levels reordered\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_reorder\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_reorder2(\n    _f,\n    _x,\n    *args,\n    _fun=None,\n    _desc: bool = False,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Reorder factor levels by a function (default: `last2`)\n\n    Args:\n        _f: A factor\n        _x: The data to be used to reorder the factor\n        _fun: A function to be used to reorder the factor\n        _desc: If `True`, the factor will be reordered in descending order\n        *args: Extra arguments to be passed to `_fun`\n        **kwargs: Extra keyword arguments to be passed to `_fun`\n\n    Returns:\n        The factor with levels reordered\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_reorder2\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_shuffle(_f) -&gt; Any:\n    \"\"\"Shuffle the levels of a factor\n\n    Args:\n        _f: A factor\n\n    Returns:\n        The factor with levels shuffled\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_shuffle\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_rev(_f) -&gt; Any:\n    \"\"\"Reverse the order of the levels of a factor\n\n    Args:\n        _f: A factor\n\n    Returns:\n        The factor with levels reversed\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_rev\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_shift(_f, n: int = 1) -&gt; Any:\n    \"\"\"Shift the levels of a factor\n\n    Args:\n        _f: A factor\n        n: The number of levels to shift\n\n    Returns:\n        The factor with levels shifted\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_shift\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef first2(_x, _y) -&gt; Any:\n    \"\"\"Find the first element of `_y` ordered by `_x`\n\n    Args:\n        _x: The vector used to order `_y`\n        _y: The vector to get the first element of\n\n    Returns:\n        First element of `_y` ordered by `_x`\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"first2\", _x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef last2(_x, _y) -&gt; Any:\n    \"\"\"Find the last element of `_y` ordered by `_x`\n\n    Args:\n        _x: The vector used to order `_y`\n        _y: The vector to get the last element of\n\n    Returns:\n        Last element of `_y` ordered by `_x`\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"last2\", _x)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_anon(_f, prefix: str = \"\") -&gt; Any:\n    \"\"\"Anonymise factor levels\n\n    Args:\n        f: A factor.\n        prefix: A character prefix to insert in front of the random labels.\n\n    Returns:\n        The factor with levels anonymised\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_anon\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_recode(_f, *args, **kwargs) -&gt; Any:\n    \"\"\"Change factor levels by hand\n\n    Args:\n        _f: A factor\n        *args: and\n        **kwargs: A sequence of named character vectors where the name\n            gives the new level, and the value gives the old level.\n            Levels not otherwise mentioned will be left as is. Levels can\n            be removed by naming them `NULL`.\n            As `NULL/None` cannot be a name of keyword arguments, replacement\n            has to be specified as a dict\n            (i.e. `fct_recode(x, {NULL: \"apple\"})`)\n            If you want to replace multiple values with the same old value,\n            use a `set`/`list`/`numpy.ndarray`\n            (i.e. `fct_recode(x, fruit=[\"apple\", \"banana\"])`).\n            This is a safe way, since `set`/`list`/`numpy.ndarray` is\n            not hashable to be a level of a factor.\n            Do NOT use a `tuple`, as it's hashable!\n\n            Note that the order of the name-value is in the reverse way as\n            `dplyr.recode()` and `dplyr.recode_factor()`\n\n    Returns:\n        The factor recoded with given recodings\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_recode\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_collapse(_f, other_level=None, **kwargs) -&gt; Any:\n    \"\"\"Collapse factor levels into manually defined groups\n\n    Args:\n        _f: A factor\n        **kwargs: The levels to collapse.\n            Like `name=[old_level, old_level1, ...]`. The old levels will\n            be replaced with `name`\n        other_level: Replace all levels not named in `kwargs`.\n            If not, don't collapse them.\n\n    Returns:\n        The factor with levels collapsed.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_collapse\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_lump(\n    _f,\n    n=None,\n    prop=None,\n    w=None,\n    other_level=\"Other\",\n    ties_method: str = \"min\",\n) -&gt; Any:\n    \"\"\"Lump together factor levels into \"other\"\n\n    Args:\n        f: A factor\n        n: Positive `n` preserves the most common `n` values.\n            Negative `n` preserves the least common `-n` values.\n            It there are ties, you will get at least `abs(n)` values.\n        prop: Positive `prop` lumps values which do not appear at least\n            `prop` of the time. Negative `prop` lumps values that\n            do not appear at most `-prop` of the time.\n        w: An optional numeric vector giving weights for frequency of\n            each value (not level) in f.\n        other_level: Value of level used for \"other\" values. Always\n            placed at end of levels.\n        ties_method A character string specifying how ties are treated.\n            One of: `average`, `first`, `dense`, `max`, and `min`.\n\n    Returns:\n        The factor with levels lumped.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_lump\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_lump_min(_f, min_, w=None, other_level=\"Other\") -&gt; Any:\n    \"\"\"lumps levels that appear fewer than `min_` times.\n\n    Args:\n        _f: A factor\n        min_: Preserve levels that appear at least `min_` number of times.\n        w: An optional numeric vector giving weights for frequency of\n            each value (not level) in f.\n        other_level: Value of level used for \"other\" values. Always\n            placed at end of levels.\n\n    Returns:\n        The factor with levels lumped.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_lump_min\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_lump_prop(_f, prop, w=None, other_level=\"Other\") -&gt; Any:\n    \"\"\"Lumps levels that appear in fewer `prop * n` times.\n\n    Args:\n        _f: A factor\n        prop: Positive `prop` lumps values which do not appear at least\n            `prop` of the time. Negative `prop` lumps values that\n            do not appear at most `-prop` of the time.\n        w: An optional numeric vector giving weights for frequency of\n            each value (not level) in f.\n        other_level: Value of level used for \"other\" values. Always\n            placed at end of levels.\n\n    Returns:\n        The factor with levels lumped.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_lump_prop\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_lump_n(_f, n, w=None, other_level=\"Other\") -&gt; Any:\n    \"\"\"Lumps all levels except for the `n` most frequent.\n\n    Args:\n        f: A factor\n        n: Positive `n` preserves the most common `n` values.\n            Negative `n` preserves the least common `-n` values.\n            It there are ties, you will get at least `abs(n)` values.\n        w: An optional numeric vector giving weights for frequency of\n            each value (not level) in f.\n        other_level: Value of level used for \"other\" values. Always\n            placed at end of levels.\n        ties_method A character string specifying how ties are treated.\n            One of: `average`, `first`, `dense`, `max`, and `min`.\n\n    Returns:\n        The factor with levels lumped.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_lump_n\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_lump_lowfreq(_f, other_level=\"Other\") -&gt; Any:\n    \"\"\"lumps together the least frequent levels, ensuring\n    that \"other\" is still the smallest level.\n\n    Args:\n        f: A factor\n        other_level: Value of level used for \"other\" values. Always\n            placed at end of levels.\n\n    Returns:\n        The factor with levels lumped.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_lump_lowfreq\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_other(_f, keep=None, drop=None, other_level=\"Other\") -&gt; Any:\n    \"\"\"Replace levels with \"other\"\n\n    Args:\n        _f: A factor\n        keep: and\n        drop: Pick one of `keep` and `drop`:\n            - `keep` will preserve listed levels, replacing all others with\n                `other_level`.\n            - `drop` will replace listed levels with `other_level`, keeping all\n                as is.\n        other_level: Value of level used for \"other\" values. Always\n            placed at end of levels.\n\n    Returns:\n        The factor with levels replaced.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_other\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_relabel(_f, _fun, *args, **kwargs) -&gt; Any:\n    \"\"\"Automatically relabel factor levels, collapse as necessary\n\n    Args:\n        _f: A factor\n        _fun: A function to be applied to each level. Must accept the old\n            levels and return a character vector of the same length\n            as its input.\n        *args: and\n        **kwargs: Addtional arguments to `_fun`\n\n    Returns:\n        The factor with levels relabeled\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_relabel\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_expand(_f, *additional_levels) -&gt; Any:\n    \"\"\"Add additional levels to a factor\n\n    Args:\n        _f: A factor\n        *additional_levels: Additional levels to add to the factor.\n            Levels that already exist will be silently ignored.\n\n    Returns:\n        The factor with levels expanded\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_expand\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_explicit_na(_f, na_level=\"(Missing)\") -&gt; Any:\n    \"\"\"Make missing values explicit\n\n    This gives missing values an explicit factor level, ensuring that they\n    appear in summaries and on plots.\n\n    Args:\n        _f: A factor\n        na_level: Level to use for missing values.\n            This is what NAs will be changed to.\n\n    Returns:\n        The factor with explict na_levels\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_explicit_na\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_drop(_f, only=None) -&gt; Any:\n    \"\"\"Drop unused levels\n\n    Args:\n        _f: A factor\n        only: A character vector restricting the set of levels to be dropped.\n            If supplied, only levels that have no entries and appear in\n            this vector will be removed.\n\n    Returns:\n        The factor with unused levels dropped\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_drop\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_unify(\n    fs,\n    levels=None,\n) -&gt; Any:\n    \"\"\"Unify the levels in a list of factors\n\n    Args:\n        fs: A list of factors\n        levels: Set of levels to apply to every factor. Default to union\n            of all factor levels\n\n    Returns:\n        A list of factors with the levels expanded\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_unify\", fs)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_c(*fs) -&gt; Any:\n    \"\"\"Concatenate factors, combining levels\n\n    This is a useful ways of patching together factors from multiple sources\n    that really should have the same levels but don't.\n\n    Args:\n        *fs: factors to concatenate\n\n    Returns:\n        The concatenated factor\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_c\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_cross(\n    *fs,\n    sep: str = \":\",\n    keep_empty: bool = False,\n) -&gt; Any:\n    \"\"\"Combine levels from two or more factors to create a new factor\n\n    Computes a factor whose levels are all the combinations of\n    the levels of the input factors.\n\n    Args:\n        *fs: factors to cross\n        sep: A string to separate levels\n        keep_empty: If True, keep combinations with no observations as levels\n\n    Returns:\n        The new factor\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_cross\")\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_count(_f, sort: bool = False, prop=False) -&gt; Any:\n    \"\"\"Count entries in a factor\n\n    Args:\n        _f: A factor\n        sort: If True, sort the result so that the most common values float to\n            the top\n        prop: If True, compute the fraction of marginal table.\n\n    Returns:\n        A data frame with columns `f`, `n` and `p`, if prop is True\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_count\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_match(_f, lvls) -&gt; Any:\n    \"\"\"Test for presence of levels in a factor\n\n    Do any of `lvls` occur in `_f`?\n\n    Args:\n        _f: A factor\n        lvls: A vector specifying levels to look for.\n\n    Returns:\n        A logical factor\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_match\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef fct_unique(_f) -&gt; Any:\n    \"\"\"Unique values of a factor\n\n    Args:\n        _f: A factor\n\n    Returns:\n        The factor with the unique values in `_f`\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fct_unique\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef lvls_reorder(\n    _f,\n    idx,\n    ordered: bool = None,\n) -&gt; Any:\n    \"\"\"Leaves values of a factor as they are, but changes the order by\n    given indices\n\n    Args:\n        f: A factor (or character vector).\n        idx: A integer index, with one integer for each existing level.\n        new_levels: A character vector of new levels.\n        ordered: A logical which determines the \"ordered\" status of the\n          output factor. `None` preserves the existing status of the factor.\n\n    Returns:\n        The factor with levels reordered\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"lvls_reorder\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef lvls_revalue(\n    _f,\n    new_levels,\n) -&gt; Any:\n    \"\"\"changes the values of existing levels; there must\n    be one new level for each old level\n\n    Args:\n        _f: A factor\n        new_levels: A character vector of new levels.\n\n    Returns:\n        The factor with the new levels\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"lvls_revalue\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef lvls_expand(\n    _f,\n    new_levels,\n) -&gt; Any:\n    \"\"\"Expands the set of levels; the new levels must\n    include the old levels.\n\n    Args:\n        _f: A factor\n        new_levels: The new levels. Must include the old ones\n\n    Returns:\n        The factor with the new levels\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"lvls_expand\", _f)\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef lvls_union(fs) -&gt; Any:\n    \"\"\"Find all levels in a list of factors\n\n    Args:\n        fs: A list of factors\n\n    Returns:\n        A list of all levels\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"lvls_union\", fs)\n</code></pre>"},{"location":"api/source/datar.apis/","title":"datar.apis","text":""},{"location":"api/source/datar.apis/","title":"SOURCE CODE datar.apis DOCS","text":""},{"location":"api/source/datar.apis.misc/","title":"datar.apis.misc","text":""},{"location":"api/source/datar.apis.misc/","title":"SOURCE CODE datar.apis.misc DOCS","text":"<pre><code>from contextlib import contextmanager\n\nfrom pipda import register_func\n\n\n@contextmanager\ndef _array_ufunc_with_backend(backend: str):\n    \"\"\"Use a backend for the operator\"\"\"\n    old_backend = array_ufunc.backend\n    array_ufunc.backend = backend\n    yield\n    array_ufunc.backend = old_backend\n\n\n@register_func(cls=object, dispatchable=\"first\")DOCS\ndef array_ufunc(x, ufunc, *args, kind, **kwargs):\n    \"\"\"Implement the array ufunc\n\n    Allow other backends to override the behavior of the ufunc on\n    different types of data.\n    \"\"\"\n    return ufunc(x, *args, **kwargs)\n\n\narray_ufunc.backend = None\narray_ufunc.with_backend = _array_ufunc_with_backend\n</code></pre>"},{"location":"api/source/datar.apis.tibble/","title":"datar.apis.tibble","text":""},{"location":"api/source/datar.apis.tibble/","title":"SOURCE CODE datar.apis.tibble DOCS","text":"<pre><code>from __future__ import annotations as _\nfrom typing import Any, Callable as _Callable\n\nfrom pipda import (\n    register_verb as _register_verb,\n    register_func as _register_func,\n)\n\nfrom ..core.utils import (\n    NotImplementedByCurrentBackendError as _NotImplementedByCurrentBackendError,\n)\n\n\n@_register_func(plain=True)DOCS\ndef tibble(\n    *args,\n    _name_repair: str | _Callable = \"check_unique\",\n    _rows: int = None,\n    _dtypes=None,\n    _drop_index: bool = False,\n    _index=None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Constructs a data frame\n\n    Args:\n        *args: and\n        **kwargs: A set of name-value pairs.\n        _name_repair: treatment of problematic column names:\n            - \"minimal\": No name repair or checks, beyond basic existence,\n            - \"unique\": Make sure names are unique and not empty,\n            - \"check_unique\": (default value), no name repair,\n                but check they are unique,\n            - \"universal\": Make the names unique and syntactic\n            - a function: apply custom name repair\n        _rows: Number of rows of a 0-col dataframe when args and kwargs are\n            not provided. When args or kwargs are provided, this is ignored.\n        _dtypes: The dtypes for each columns to convert to.\n        _drop_index: Whether drop the index for the final data frame\n        _index: The new index of the output frame\n\n    Returns:\n        A constructed tibble\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"tibble\")\n\n\n@_register_func(pipeable=True, dispatchable=True)\ndef tibble_(\n    *args,\n    _name_repair: str | _Callable = \"check_unique\",\n    _rows: int = None,\n    _dtypes=None,\n    _drop_index: bool = False,\n    _index=None,\n    **kwargs,\n) -&gt; Any:\n    raise _NotImplementedByCurrentBackendError(\"tibble_\")\n\n\n@_register_func(plain=True)DOCS\ndef tribble(\n    *dummies,\n    _name_repair: str | _Callable = \"minimal\",\n    _dtypes=None,\n) -&gt; Any:\n    \"\"\"Create dataframe using an easier to read row-by-row layout\n    Unlike original API that uses formula (`f.col`) to indicate the column\n    names, we use `f.col` to indicate them.\n\n    Args:\n        *dummies: Arguments specifying the structure of a dataframe\n            Variable names should be specified with `f.name`\n        _dtypes: The dtypes for each columns to convert to.\n\n    Examples:\n        &gt;&gt;&gt; tribble(\n        &gt;&gt;&gt;     f.colA, f.colB,\n        &gt;&gt;&gt;     \"a\",    1,\n        &gt;&gt;&gt;     \"b\",    2,\n        &gt;&gt;&gt;     \"c\",    3,\n        &gt;&gt;&gt; )\n\n    Returns:\n        A dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"tribble\")\n\n\n@_register_func(plain=True)DOCS\ndef tibble_row(\n    *args,\n    _name_repair: str | _Callable = \"check_unique\",\n    _dtypes=None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Constructs a data frame that is guaranteed to occupy one row.\n    Scalar values will be wrapped with `[]`\n    Args:\n        *args: and\n        **kwargs: A set of name-value pairs.\n        _name_repair: treatment of problematic column names:\n            - \"minimal\": No name repair or checks, beyond basic existence,\n            - \"unique\": Make sure names are unique and not empty,\n            - \"check_unique\": (default value), no name repair,\n                but check they are unique,\n            - \"universal\": Make the names unique and syntactic\n            - a function: apply custom name repair\n    Returns:\n        A constructed dataframe\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"tibble_row\")\n\n\n@_register_verb()DOCS\ndef as_tibble(df) -&gt; Any:\n    \"\"\"Convert a DataFrame object to Tibble object\"\"\"\n    raise _NotImplementedByCurrentBackendError(\"as_tibble\", df)\n\n\n@_register_verb()DOCS\ndef enframe(x, name=\"name\", value=\"value\") -&gt; Any:\n    \"\"\"Converts mappings or lists to one- or two-column data frames.\n\n    Args:\n        x: a list, a dictionary or a dataframe with one or two columns\n        name: and\n        value: value Names of the columns that store the names and values.\n            If `None`, a one-column dataframe is returned.\n            `value` cannot be `None`\n\n    Returns:\n        A data frame with two columns if `name` is not None (default) or\n        one-column otherwise.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"enframe\", x)\n\n\n@_register_verb()DOCS\ndef deframe(x) -&gt; Any:\n    \"\"\"Converts two-column data frames to a dictionary\n    using the first column as name and the second column as value.\n    If the input has only one column, a list.\n\n    Args:\n        x: A data frame.\n\n    Returns:\n        A dictionary or a list if only one column in the data frame.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"deframe\", x)\n\n\n@_register_verb()DOCS\ndef add_row(\n    _data,\n    *args,\n    _before=None,\n    _after=None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Add one or more rows of data to an existing data frame.\n\n    Aliases `add_case`\n\n    Args:\n        _data: Data frame to append to.\n        *args: and\n        **kwargs: Name-value pairs to add to the data frame.\n        _before: and\n        _after: row index where to add the new rows.\n            (default to add after the last row)\n\n    Returns:\n        The dataframe with the added rows\n\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"add_row\", _data)\n\n\n@_register_verb()DOCS\ndef add_column(\n    _data,\n    *args,\n    _before=None,\n    _after=None,\n    _name_repair=\"check_unique\",\n    _dtypes=None,\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Add one or more columns to an existing data frame.\n\n    Args:\n        _data: Data frame to append to\n        *args: and\n        **kwargs: Name-value pairs to add to the data frame\n        _before: and\n        _after: Column index or name where to add the new columns\n            (default to add after the last column)\n        _dtypes: The dtypes for the new columns, either a uniform dtype or a\n            dict of dtypes with keys the column names\n\n    Returns:\n        The dataframe with the added columns\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"add_column\", _data)\n\n\n@_register_verb()DOCS\ndef has_rownames(_data) -&gt; bool:\n    \"\"\"Detect if a data frame has row names\n\n    Aliases `has_index`\n\n    Args:\n        _data: The data frame to check\n\n    Returns:\n        True if the data frame has index otherwise False.\n\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"has_rownames\", _data)\n\n\n@_register_verb()DOCS\ndef remove_rownames(_data) -&gt; Any:\n    \"\"\"Remove the index/rownames of a data frame\n\n    Aliases `remove_index`, `drop_index`, `remove_rownames`\n\n    Args:\n        _data: The data frame\n\n    Returns:\n        The data frame with index removed\n\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"remove_rownames\", _data)\n\n\n@_register_verb()DOCS\ndef rownames_to_column(_data, var=\"rowname\") -&gt; Any:\n    \"\"\"Add rownames as a column\n\n    Aliases `index_to_column`\n\n    Args:\n        _data: The data frame\n        var: The name of the column\n\n    Returns:\n        The data frame with rownames added as one column. Note that the\n        original index is removed.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rownames_to_column\", _data)\n\n\n@_register_verb()DOCS\ndef rowid_to_column(_data, var=\"rowid\") -&gt; Any:\n    \"\"\"Add rownames as a column\n\n    Args:\n        _data: The data frame\n        var: The name of the column\n\n    Returns:\n        The data frame with row ids added as one column.\n\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"rowid_to_column\", _data)\n\n\n@_register_verb()DOCS\ndef column_to_rownames(_data, var=\"rowname\") -&gt; Any:\n    \"\"\"Set rownames/index with one column, and remove it\n\n    Aliases `column_to_index`\n\n    Args:\n        _data: The data frame\n        var: The column to conver to the rownames\n\n    Returns:\n        The data frame with the column converted to rownames\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"column_to_rownames\", _data)\n\n\n# aliases\nadd_case = add_row\nhas_index = has_rownames\nremove_index = drop_index = remove_rownames\nindex_to_column = rownames_to_column\ncolumn_to_index = column_to_rownames\n</code></pre>"},{"location":"api/source/datar.apis.tidyr/","title":"datar.apis.tidyr","text":""},{"location":"api/source/datar.apis.tidyr/","title":"SOURCE CODE datar.apis.tidyr DOCS","text":"<pre><code>from __future__ import annotations as _\nfrom typing import Any, Callable as _Callable, Mapping as _Mapping\n\nfrom pipda import (\n    register_verb as _register_verb,\n    register_func as _register_func,\n)\n\nfrom ..core.utils import (\n    NotImplementedByCurrentBackendError as _NotImplementedByCurrentBackendError,\n)\nfrom .base import expand_grid  # noqa: F401\n\n\n@_register_func(pipeable=True, dispatchable=True)DOCS\ndef full_seq(x, period, tol=1e-6) -&gt; Any:\n    \"\"\"Create the full sequence of values in a vector\n\n    Args:\n        x: A numeric vector.\n        period: Gap between each observation. The existing data will be\n            checked to ensure that it is actually of this periodicity.\n        tol: Numerical tolerance for checking periodicity.\n\n    Returns:\n        The full sequence\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"full_seq\", x)\n\n\n@_register_verb()DOCS\ndef chop(\n    data,\n    cols=None,\n) -&gt; Any:\n    \"\"\"Makes data frame shorter by converting rows within each group\n    into list-columns.\n\n    Args:\n        data: A data frame\n        cols: Columns to chop\n\n    Returns:\n        Data frame with selected columns chopped\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"chop\", data)\n\n\n@_register_verb()DOCS\ndef unchop(\n    data,\n    cols=None,\n    keep_empty: bool = False,\n    dtypes=None,\n) -&gt; Any:\n    \"\"\"Makes df longer by expanding list-columns so that each element\n    of the list-column gets its own row in the output.\n\n    See https://tidyr.tidyverse.org/reference/chop.html\n\n    Recycling size-1 elements might be different from `tidyr`\n        &gt;&gt;&gt; df = tibble(x=[1, [2,3]], y=[[2,3], 1])\n        &gt;&gt;&gt; df &gt;&gt; unchop([f.x, f.y])\n        &gt;&gt;&gt; # tibble(x=[1,2,3], y=[2,3,1])\n        &gt;&gt;&gt; # instead of following in tidyr\n        &gt;&gt;&gt; # tibble(x=[1,1,2,3], y=[2,3,1,1])\n\n    Args:\n        data: A data frame.\n        cols: Columns to unchop.\n        keep_empty: By default, you get one row of output for each element\n            of the list your unchopping/unnesting.\n            This means that if there's a size-0 element\n            (like NULL or an empty data frame), that entire row will be\n            dropped from the output.\n            If you want to preserve all rows, use `keep_empty` = `True` to\n            replace size-0 elements with a single row of missing values.\n        dtypes: Providing the dtypes for the output columns.\n            Could be a single dtype, which will be applied to all columns, or\n            a dictionary of dtypes with keys for the columns and values the\n            dtypes.\n            For nested data frames, we need to specify `col$a` as key. If `col`\n            is used as key, all columns of the nested data frames will be casted\n            into that dtype.\n\n    Returns:\n        A data frame with selected columns unchopped.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"unchop\", data)\n\n\n@_register_verb()DOCS\ndef nest(\n    _data,\n    _names_sep: str = None,\n    **cols: str | int,\n) -&gt; Any:\n    \"\"\"Nesting creates a list-column of data frames\n\n    Args:\n        _data: A data frame\n        **cols: Columns to nest\n        _names_sep: If `None`, the default, the names will be left as is.\n            Inner names will come from the former outer names\n            If a string, the inner and outer names will be used together.\n            The names of the new outer columns will be formed by pasting\n            together the outer and the inner column names, separated by\n            `_names_sep`.\n\n    Returns:\n        Nested data frame.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"nest\", _data)\n\n\n@_register_verb()DOCS\ndef unnest(\n    data,\n    *cols: str | int,\n    keep_empty: bool = False,\n    dtypes=None,\n    names_sep: str = None,\n    names_repair: str | _Callable = \"check_unique\",\n) -&gt; Any:\n    \"\"\"Flattens list-column of data frames back out into regular columns.\n\n    Args:\n        data: A data frame to flatten.\n        *cols: Columns to unnest.\n        keep_empty: By default, you get one row of output for each element\n            of the list your unchopping/unnesting.\n            This means that if there's a size-0 element\n            (like NULL or an empty data frame), that entire row will be\n            dropped from the output.\n            If you want to preserve all rows, use `keep_empty` = `True` to\n            replace size-0 elements with a single row of missing values.\n        dtypes: Providing the dtypes for the output columns.\n            Could be a single dtype, which will be applied to all columns, or\n            a dictionary of dtypes with keys for the columns and values the\n            dtypes.\n        names_sep: If `None`, the default, the names will be left as is.\n            Inner names will come from the former outer names\n            If a string, the inner and outer names will be used together.\n            The names of the new outer columns will be formed by pasting\n            together the outer and the inner column names, separated by\n            `names_sep`.\n        names_repair: treatment of problematic column names:\n            - \"minimal\": No name repair or checks, beyond basic existence,\n            - \"unique\": Make sure names are unique and not empty,\n            - \"check_unique\": (default value), no name repair,\n                but check they are unique,\n            - \"universal\": Make the names unique and syntactic\n            - a function: apply custom name repair\n\n    Returns:\n        Data frame with selected columns unnested.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"unnest\", data)\n\n\n@_register_verb()DOCS\ndef pack(\n    _data,\n    _names_sep: str = None,\n    **cols: str | int,\n) -&gt; Any:\n    \"\"\"Makes df narrow by collapsing a set of columns into a single df-column.\n\n    Args:\n        _data: A data frame\n        **cols: Columns to pack\n        _names_sep: If `None`, the default, the names will be left as is.\n            Inner names will come from the former outer names\n            If a string, the inner and outer names will be used together.\n            The names of the new outer columns will be formed by pasting\n            together the outer and the inner column names, separated by\n            `_names_sep`.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"pack\", _data)\n\n\n@_register_verb()DOCS\ndef unpack(\n    data,\n    cols,\n    names_sep: str = None,\n    names_repair: str | _Callable = \"check_unique\",\n) -&gt; Any:\n    \"\"\"Makes df wider by expanding df-columns back out into individual columns.\n\n    For empty columns, the column is kept asis, instead of removing it.\n\n    Args:\n        data: A data frame\n        cols: Columns to unpack\n        names_sep: If `None`, the default, the names will be left as is.\n            Inner names will come from the former outer names\n            If a string, the inner and outer names will be used together.\n            The names of the new outer columns will be formed by pasting\n            together the outer and the inner column names, separated by\n            `_names_sep`.\n        name_repair: treatment of problematic column names:\n            - \"minimal\": No name repair or checks, beyond basic existence,\n            - \"unique\": Make sure names are unique and not empty,\n            - \"check_unique\": (default value), no name repair,\n                but check they are unique,\n            - \"universal\": Make the names unique and syntactic\n            - a function: apply custom name repair\n\n    Returns:\n        Data frame with given columns unpacked.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"unpack\", data)\n\n\n@_register_verb()DOCS\ndef expand(\n    data,\n    *args,\n    _name_repair: str | _Callable = \"check_unique\",\n    **kwargs,\n) -&gt; Any:\n    \"\"\"Generates all combination of variables found in a dataset.\n\n    Args:\n        data: A data frame\n        *args: and,\n        **kwargs: columns to expand. Columns can be atomic lists.\n            - To find all unique combinations of x, y and z, including\n              those not present in the data, supply each variable as a\n              separate argument: `expand(df, x, y, z)`.\n            - To find only the combinations that occur in the data, use\n              nesting: `expand(df, nesting(x, y, z))`.\n            - You can combine the two forms. For example,\n              `expand(df, nesting(school_id, student_id), date)` would\n              produce a row for each present school-student combination\n              for all possible dates.\n        _name_repair: treatment of problematic column names:\n            - \"minimal\": No name repair or checks, beyond basic existence,\n            - \"unique\": Make sure names are unique and not empty,\n            - \"check_unique\": (default value), no name repair,\n                but check they are unique,\n            - \"universal\": Make the names unique and syntactic\n            - a function: apply custom name repair\n\n    Returns:\n        A data frame with all combination of variables.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"expand\", data)\n\n\n@_register_func(dispatchable=True)DOCS\ndef nesting(\n    *args,\n    _name_repair: str | _Callable = \"check_unique\",\n    **kwargs,\n) -&gt; Any:\n    \"\"\"A helper that only finds combinations already present in the data.\n\n    Args:\n        *args: and,\n        **kwargs: columns to expand. Columns can be atomic lists.\n            - To find all unique combinations of x, y and z, including\n              those not present in the data, supply each variable as a\n              separate argument: `expand(df, x, y, z)`.\n            - To find only the combinations that occur in the data, use\n              nesting: `expand(df, nesting(x, y, z))`.\n            - You can combine the two forms. For example,\n              `expand(df, nesting(school_id, student_id), date)` would\n              produce a row for each present school-student combination\n              for all possible dates.\n        _name_repair: treatment of problematic column names:\n            - \"minimal\": No name repair or checks, beyond basic existence,\n            - \"unique\": Make sure names are unique and not empty,\n            - \"check_unique\": (default value), no name repair,\n                but check they are unique,\n            - \"universal\": Make the names unique and syntactic\n            - a function: apply custom name repair\n\n    Returns:\n        A data frame with all combinations in data.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"nesting\")\n\n\n@_register_func(dispatchable=True)DOCS\ndef crossing(\n    *args,\n    _name_repair: str | _Callable = \"check_unique\",\n    **kwargs,\n) -&gt; Any:\n    \"\"\"A wrapper around `expand_grid()` that de-duplicates and sorts its inputs\n\n    When values are not specified by literal `list`, they will be sorted.\n\n    Args:\n        *args: and,\n        **kwargs: columns to expand. Columns can be atomic lists.\n            - To find all unique combinations of x, y and z, including\n              those not present in the data, supply each variable as a\n              separate argument: `expand(df, x, y, z)`.\n            - To find only the combinations that occur in the data, use\n              nesting: `expand(df, nesting(x, y, z))`.\n            - You can combine the two forms. For example,\n              `expand(df, nesting(school_id, student_id), date)` would\n              produce a row for each present school-student combination\n              for all possible dates.\n        _name_repair: treatment of problematic column names:\n            - \"minimal\": No name repair or checks, beyond basic existence,\n            - \"unique\": Make sure names are unique and not empty,\n            - \"check_unique\": (default value), no name repair,\n                but check they are unique,\n            - \"universal\": Make the names unique and syntactic\n            - a function: apply custom name repair\n\n    Returns:\n        A data frame with values deduplicated and sorted.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"crossing\")\n\n\n@_register_verb()DOCS\ndef complete(\n    data,\n    *args,\n    fill=None,\n    explict: bool = True,\n) -&gt; Any:\n    \"\"\"Turns implicit missing values into explicit missing values.\n\n    Args:\n        data: A data frame\n        *args: columns to expand. Columns can be atomic lists.\n            - To find all unique combinations of x, y and z, including\n              those not present in the data, supply each variable as a\n              separate argument: `expand(df, x, y, z)`.\n            - To find only the combinations that occur in the data, use\n              nesting: `expand(df, nesting(x, y, z))`.\n            - You can combine the two forms. For example,\n              `expand(df, nesting(school_id, student_id), date)` would\n              produce a row for each present school-student combination\n              for all possible dates.\n        fill: A named list that for each variable supplies a single value\n            to use instead of NA for missing combinations.\n        explict: Should both implicit (newly created) and explicit\n            (pre-existing) missing values be filled by fill? By default,\n            this is TRUE, but if set to FALSE this will limit the fill to only\n            implicit missing values.\n\n    Returns:\n        Data frame with missing values completed\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"complete\", data)\n\n\n@_register_verb()DOCS\ndef drop_na(\n    _data,\n    *columns: str,\n    _how: str = \"any\",\n) -&gt; Any:\n    \"\"\"Drop rows containing missing values\n\n    See https://tidyr.tidyverse.org/reference/drop_na.html\n\n    Args:\n        data: A data frame.\n        *columns: Columns to inspect for missing values.\n        _how: How to select the rows to drop\n            - all: All columns of `columns` to be `NA`s\n            - any: Any columns of `columns` to be `NA`s\n            (tidyr doesn't support this argument)\n\n    Returns:\n        Dataframe with rows with NAs dropped and indexes dropped\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"drop_na\", _data)\n\n\n@_register_verb()DOCS\ndef extract(\n    data,\n    col: str | int,\n    into,\n    regex: str = r\"(\\w+)\",\n    remove: bool = True,\n    convert=False,\n) -&gt; Any:\n    \"\"\"Given a regular expression with capturing groups, extract() turns each\n    group into a new column. If the groups don't match, or the input is NA,\n    the output will be NA.\n\n    See https://tidyr.tidyverse.org/reference/extract.html\n\n    Args:\n        data: The dataframe\n        col: Column name or position.\n        into: Names of new variables to create as character vector.\n            Use None to omit the variable in the output.\n        regex: a regular expression used to extract the desired values.\n            There should be one group (defined by ()) for each element of into.\n        remove: If TRUE, remove input column from output data frame.\n        convert: The universal type for the extracted columns or a dict for\n            individual ones\n\n    Returns:\n        Dataframe with extracted columns.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"extract\", data)\n\n\n@_register_verb()DOCS\ndef fill(\n    _data,\n    *columns: str | int,\n    _direction: str = \"down\",\n) -&gt; Any:\n    \"\"\"Fills missing values in selected columns using the next or\n    previous entry.\n\n    See https://tidyr.tidyverse.org/reference/fill.html\n\n    Args:\n        _data: A dataframe\n        *columns: Columns to fill\n        _direction: Direction in which to fill missing values.\n            Currently either \"down\" (the default), \"up\",\n            \"downup\" (i.e. first down and then up) or\n            \"updown\" (first up and then down).\n\n    Returns:\n        The dataframe with NAs being replaced.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"fill\", _data)\n\n\n@_register_verb()DOCS\ndef pivot_longer(\n    _data,\n    cols,\n    names_to=\"name\",\n    names_prefix: str = None,\n    names_sep: str = None,\n    names_pattern: str = None,\n    names_dtypes=None,\n    names_transform: _Callable | _Mapping[str, _Callable] = None,\n    names_repair=\"check_unique\",\n    values_to: str = \"value\",\n    values_drop_na: bool = False,\n    values_dtypes=None,\n    values_transform: _Callable | _Mapping[str, _Callable] = None,\n) -&gt; Any:\n    \"\"\" \"lengthens\" data, increasing the number of rows and\n    decreasing the number of columns.\n\n    The row order is a bit different from `tidyr` and `pandas.DataFrame.melt`.\n        &gt;&gt;&gt; df = tibble(x=c[1:2], y=c[3:4])\n        &gt;&gt;&gt; pivot_longer(df, f[f.x:f.y])\n        &gt;&gt;&gt; #    name   value\n        &gt;&gt;&gt; # 0  x      1\n        &gt;&gt;&gt; # 1  x      2\n        &gt;&gt;&gt; # 2  y      3\n        &gt;&gt;&gt; # 3  y      4\n    But with `tidyr::pivot_longer`, the output will be:\n        &gt;&gt;&gt; # # A tibble: 4 x 2\n        &gt;&gt;&gt; # name  value\n        &gt;&gt;&gt; # &lt;chr&gt; &lt;int&gt;\n        &gt;&gt;&gt; # 1 x   1\n        &gt;&gt;&gt; # 2 y   3\n        &gt;&gt;&gt; # 3 x   2\n        &gt;&gt;&gt; # 4 y   4\n\n    Args:\n        _data: A data frame to pivot.\n        cols: Columns to pivot into longer format.\n        names_to: A string specifying the name of the column to create from\n            the data stored in the column names of data.\n            Can be a character vector, creating multiple columns, if names_sep\n            or names_pattern is provided. In this case, there are two special\n            values you can take advantage of:\n            - `None`/`NA`/`NULL` will discard that component of the name.\n            - `.value`/`_value` indicates that component of the name defines\n                the name of the column containing the cell values,\n                overriding values_to.\n            - Different as `tidyr`: With `.value`/`_value`, if there are other\n              parts of the names to distinguish the groups, they must be\n              captured. For example, use `r'(\\\\w)_(\\\\d)'` to match `'a_1'` and\n              `['.value', NA]` to discard the suffix, instead of use\n              `r'(\\\\w)_\\\\d'` to match.\n        names_prefix: A regular expression used to remove matching text from\n            the start of each variable name.\n        names_sep: and\n        names_pattern: If names_to contains multiple values,\n            these arguments control how the column name is broken up.\n            names_sep takes the same specification as separate(), and\n            can either be a numeric vector (specifying positions to break on),\n            or a single string (specifying a regular expression to split on).\n        names_pattern: takes the same specification as extract(),\n            a regular expression containing matching groups (()).\n        names_dtypes: and\n        values_dtypes: A list of column name-prototype pairs.\n            A prototype (or dtypes for short) is a zero-length vector\n            (like integer() or numeric()) that defines the type, class, and\n            attributes of a vector. Use these arguments if you want to confirm\n            that the created columns are the types that you expect.\n            Note that if you want to change (instead of confirm) the types\n            of specific columns, you should use names_transform or\n            values_transform instead.\n        names_transform: and\n        values_transform: A list of column name-function pairs.\n            Use these arguments if you need to change the types of\n            specific columns. For example,\n            names_transform = dict(week = as.integer) would convert a\n            character variable called week to an integer.\n            If not specified, the type of the columns generated from names_to\n            will be character, and the type of the variables generated from\n            values_to will be the common type of the input columns used to\n            generate them.\n        names_repair: Not supported yet.\n        values_to: A string specifying the name of the column to create from\n            the data stored in cell values. If names_to is a character\n            containing the special `.value`/`_value` sentinel, this value\n            will be ignored, and the name of the value column will be derived\n            from part of the existing column names.\n        values_drop_na: If TRUE, will drop rows that contain only NAs in\n            the value_to column. This effectively converts explicit missing\n            values to implicit missing values, and should generally be used\n            only when missing values in data were created by its structure.\n        names_repair: treatment of problematic column names:\n            - \"minimal\": No name repair or checks, beyond basic existence,\n            - \"unique\": Make sure names are unique and not empty,\n            - \"check_unique\": (default value), no name repair,\n                but check they are unique,\n            - \"universal\": Make the names unique and syntactic\n            - a function: apply custom name repair\n\n    Returns:\n        The pivoted dataframe.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"pivot_longer\", _data)\n\n\n@_register_verb()DOCS\ndef pivot_wider(\n    _data,\n    id_cols=None,\n    names_from=\"name\",\n    names_prefix: str = \"\",\n    names_sep: str = \"_\",\n    names_glue: str = None,\n    names_sort: bool = False,\n    # names_repair: str = \"check_unique\", # todo\n    values_from=\"value\",\n    values_fill=None,\n    values_fn: _Callable | _Mapping[str, _Callable] = None,\n) -&gt; Any:\n    \"\"\" \"widens\" data, increasing the number of columns and decreasing\n    the number of rows.\n\n    Args:\n        _data: A data frame to pivot.\n        id_cols: A set of columns that uniquely identifies each observation.\n            Defaults to all columns in data except for the columns specified\n            in names_from and values_from.\n        names_from: and\n        values_from: A pair of arguments describing which column\n            (or columns) to get the name of the output column (names_from),\n            and which column (or columns) to get the cell values from\n            (values_from).\n        names_prefix: String added to the start of every variable name.\n        names_sep: If names_from or values_from contains multiple variables,\n            this will be used to join their values together into a single\n            string to use as a column name.\n        names_glue: Instead of names_sep and names_prefix, you can supply\n            a glue specification that uses the names_from columns\n            (and special _value) to create custom column names.\n        names_sort: Should the column names be sorted? If FALSE, the default,\n            column names are ordered by first appearance.\n        names_repair: todo\n        values_fill: Optionally, a (scalar) value that specifies what\n            each value should be filled in with when missing.\n        values_fn: Optionally, a function applied to the value in each cell\n            in the output. You will typically use this when the combination\n            of `id_cols` and value column does not uniquely identify\n            an observation.\n            This can be a dict you want to apply different aggregations to\n            different value columns.\n            If not specified, will be `numpy.mean`\n\n    Returns:\n        The pivoted dataframe.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"pivot_wider\", _data)\n\n\n@_register_verb()DOCS\ndef separate(\n    data,\n    col: int | str,\n    into,\n    sep: int | str = r\"[^0-9A-Za-z]+\",\n    remove: bool = True,\n    convert=False,\n    extra: str = \"warn\",\n    fill: str = \"warn\",\n) -&gt; Any:\n    \"\"\"Given either a regular expression or a vector of character positions,\n    turns a single character column into multiple columns.\n\n    Args:\n        data: The dataframe\n        col: Column name or position.\n        into: Names of new variables to create as character vector.\n            Use `None`/`NA`/`NULL` to omit the variable in the output.\n        sep: Separator between columns.\n            If str, `sep` is interpreted as a regular expression.\n            The default value is a regular expression that matches\n            any sequence of non-alphanumeric values.\n            If int, `sep` is interpreted as character positions to split at.\n        remove: If TRUE, remove input column from output data frame.\n        convert: The universal type for the extracted columns or a dict for\n            individual ones\n            Note that when given `TRUE`, `DataFrame.convert_dtypes()` is called,\n            but it will not convert `str` to other types\n            (For example, `'1'` to `1`). You have to specify the dtype yourself.\n        extra: If sep is a character vector, this controls what happens when\n            there are too many pieces. There are three valid options:\n            - \"warn\" (the default): emit a warning and drop extra values.\n            - \"drop\": drop any extra values without a warning.\n            - \"merge\": only splits at most length(into) times\n        fill: If sep is a character vector, this controls what happens when\n            there are not enough pieces. There are three valid options:\n            - \"warn\" (the default): emit a warning and fill from the right\n            - \"right\": fill with missing values on the right\n            - \"left\": fill with missing values on the left\n\n    Returns:\n        Dataframe with separated columns.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"separate\", data)\n\n\n@_register_verb()DOCS\ndef separate_rows(\n    data,\n    *columns: str,\n    sep: str = r\"[^0-9A-Za-z]+\",\n    convert=False,\n) -&gt; Any:\n    \"\"\"Separates the values and places each one in its own row.\n\n    Args:\n        data: The dataframe\n        *columns: The columns to separate on\n        sep: Separator between columns.\n        convert: The universal type for the extracted columns or a dict for\n            individual ones\n\n    Returns:\n        Dataframe with rows separated and repeated.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"separate_rows\", data)\n\n\n@_register_verb()DOCS\ndef uncount(\n    data,\n    weights,\n    _remove: bool = True,\n    _id: str = None,\n) -&gt; Any:\n    \"\"\"Duplicating rows according to a weighting variable\n\n    Args:\n        data: A data frame\n        weights: A vector of weights. Evaluated in the context of data\n        _remove: If TRUE, and weights is the name of a column in data,\n            then this column is removed.\n        _id: Supply a string to create a new variable which gives a\n            unique identifier for each created row (0-based).\n\n    Returns:\n        dataframe with rows repeated.\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"uncount\", data)\n\n\n@_register_verb()DOCS\ndef unite(\n    data,\n    col: str,\n    *columns: str | int,\n    sep: str = \"_\",\n    remove: bool = True,\n    na_rm: bool = True,\n) -&gt; Any:\n    \"\"\"Unite multiple columns into one by pasting strings together\n\n    Args:\n        data: A data frame.\n        col: The name of the new column, as a string or symbol.\n        *columns: Columns to unite\n        sep: Separator to use between values.\n        remove: If True, remove input columns from output data frame.\n        na_rm: If True, missing values will be remove prior to uniting\n            each value.\n\n    Returns:\n        The dataframe with selected columns united\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"unite\", data)\n\n\n@_register_verb()DOCS\ndef replace_na(\n    data,\n    data_or_replace=None,\n    replace=None,\n) -&gt; Any:\n    \"\"\"Replace NA with a value\n\n    This function can be also used not as a verb. As a function called as\n    an argument in a verb, data is passed implicitly. Then one could\n    pass data_or_replace as the data to replace.\n\n    Args:\n        data: The data piped in\n        data_or_replace: When called as argument of a verb, this is the\n            data to replace. Otherwise this is the replacement.\n        replace: The value to replace with\n            Can only be a scalar or dict for data frame.\n            So replace NA with a list is not supported yet.\n\n    Returns:\n        Corresponding data with NAs replaced\n    \"\"\"\n    raise _NotImplementedByCurrentBackendError(\"replace_na\", data)\n</code></pre>"},{"location":"api/source/datar.base/","title":"datar.base","text":""},{"location":"api/source/datar.base/","title":"SOURCE CODE datar.base DOCS","text":"<pre><code>from .core.load_plugins import plugin as _plugin\nfrom .apis.base import *\n\nlocals().update(_plugin.hooks.base_api())\n__all__ = [key for key in locals() if not key.startswith(\"_\")]\n_conflict_names = {\"min\", \"max\", \"sum\", \"abs\", \"round\", \"all\", \"any\", \"re\"}\n\nif get_option(\"allow_conflict_names\"):  # noqa: F405\n    __all__.extend(_conflict_names)\n    for name in _conflict_names:\n        locals()[name] = locals()[name + \"_\"]\n\n\ndef __getattr__(name):DOCS\n    \"\"\"Even when allow_conflict_names is False, datar.base.sum should be fine\n    \"\"\"\n    if name in _conflict_names:\n        import sys\n        import ast\n        from executing import Source\n        node = Source.executing(sys._getframe(1)).node\n        if isinstance(node, (ast.Call, ast.Attribute)):\n            # import datar.base as d\n            # d.sum(...)\n            return globals()[name + \"_\"]\n\n    raise AttributeError\n</code></pre>"},{"location":"api/source/datar.core/","title":"datar.core","text":""},{"location":"api/source/datar.core/","title":"SOURCE CODE datar.core DOCS","text":""},{"location":"api/source/datar.core.names/","title":"datar.core.names","text":""},{"location":"api/source/datar.core.names/","title":"SOURCE CODE datar.core.names DOCS","text":"<pre><code>\"\"\"Name repairing\"\"\"\nimport inspect\nimport re\nimport keyword\nimport math\nfrom numbers import Number\nfrom typing import Any, Callable, List, Union, Iterable, Tuple\n\nfrom .utils import logger\n\n\nclass NameNonUniqueError(ValueError):DOCS\n    \"\"\"Error for non-unique names\"\"\"\n\n\ndef _isnan(x: Any) -&gt; bool:\n    \"\"\"Check if x is nan\"\"\"\n    return isinstance(x, Number) and math.isnan(x)\n\n\ndef _is_scalar(x: Any) -&gt; bool:\n    \"\"\"Check if x is scalar\"\"\"\n    if isinstance(x, str):  # pragma: no cover\n        return True\n    try:\n        iter(x)\n    except TypeError:\n        return True\n    return False\n\n\ndef _log_changed_names(changed_names: List[Tuple[str, str]]) -&gt; None:\n    \"\"\"Log the changed names\"\"\"\n    if not changed_names:\n        return\n\n    logger.warning(\"New names:\")\n    for orig_name, new_name in changed_names:\n        logger.warning(\"* %r -&gt; %r\", orig_name, new_name)\n\n\ndef _repair_names_minimal(names: Iterable[str]) -&gt; List[str]:\n    \"\"\"Minimal repairing\"\"\"\n    return [\"\" if name is None or _isnan(name) else str(name) for name in names]\n\n\ndef _repair_names_unique(\n    names: Iterable[str],\n    quiet: bool = False,\n    sanitizer: Callable = None,\n) -&gt; List[str]:\n    \"\"\"Make sure names are unique\"\"\"\n    min_names = _repair_names_minimal(names)\n    neat_names = [\n        re.sub(r\"(?:(?&lt;!_)_{1,2}\\d+|(?&lt;!_)__)+$\", \"\", name)\n        for name in min_names\n    ]\n    if callable(sanitizer):\n        neat_names = [sanitizer(name) for name in neat_names]\n\n    new_names = []\n    changed_names = []\n    for i, name in enumerate(names):\n        neat_name = neat_names[i]\n        if neat_names.count(neat_name) &gt; 1 or neat_name == \"\":\n            neat_name = f\"{neat_name}__{i}\"\n        if neat_name != name:\n            changed_names.append((name, neat_name))\n        new_names.append(neat_name)\n    if not quiet:\n        _log_changed_names(changed_names)\n    return new_names\n\n\ndef _repair_names_universal(\n    names: Iterable[str],\n    quiet: bool = False,\n) -&gt; List[str]:\n    \"\"\"Make sure names are safely to be used as variable or attribute\"\"\"\n    min_names = _repair_names_minimal(names)\n    neat_names = [re.sub(r\"[^\\w]\", \"_\", name) for name in min_names]\n    new_names = _repair_names_unique(\n        neat_names,\n        quiet=True,\n        sanitizer=lambda name: (\n            f\"_{name}\"\n            if keyword.iskeyword(name) or (name and name[0].isdigit())\n            else name\n        ),\n    )\n    if not quiet:\n        changed_names = [\n            (orig_name, new_name)\n            for orig_name, new_name in zip(names, new_names)\n            if orig_name != new_name\n        ]\n        _log_changed_names(changed_names)\n    return new_names\n\n\ndef _repair_names_check_unique(names: Iterable[str]) -&gt; Iterable[str]:\n    \"\"\"Just check the uniqueness\"\"\"\n    for name in names:\n        if names.count(name) &gt; 1:\n            raise NameNonUniqueError(f\"Names must be unique: {name}\")\n        if name == \"\" or _isnan(name):\n            raise NameNonUniqueError(f\"Names can't be empty: {name}\")\n        if re.search(r\"(?:(?&lt;!_)_{2}\\d+|(?&lt;!_)__)+$\", str(name)):\n            raise NameNonUniqueError(\n                f\"Names can't be of the form `__` or `_j`: {name}\"\n            )\n    return names\n\n\nBUILTIN_REPAIR_METHODS = dict(\n    minimal=_repair_names_minimal,\n    unique=_repair_names_unique,\n    universal=_repair_names_universal,\n    check_unique=_repair_names_check_unique,\n)\n\n\ndef repair_names(DOCS\n    names: Iterable[str],\n    repair: Union[str, Callable],\n) -&gt; List[str]:\n    \"\"\"Repair names based on the method\n\n    Args:\n        names: The names to be repaired\n        repair: The method to repair\n            - `minimal`: Minimal names are never None or NA.\n                When an element doesn't have a name, its minimal name\n                is an empty string.\n            - `unique`: Unique names are unique. A suffix is appended to\n                duplicate names to make them unique.\n            - `universal`: Universal names are unique and syntactic,\n                meaning that you can safely use the names as variables without\n                causing a syntax error (like `f.&lt;name&gt;`).\n            - A function, accepts either a list of names or a single name.\n                Function accepts a list of names must annotate the first\n                argument with `typing.Iterable` or `typing.Sequence`.\n\n    Examples:\n        &gt;&gt;&gt; repair_names([None]*3, repair=\"minimal\")\n        &gt;&gt;&gt; # [\"\", \"\", \"\"]\n        &gt;&gt;&gt; repair_names([\"x\", NA], repair=\"minimal\")\n        &gt;&gt;&gt; # [\"x\", \"\"]\n        &gt;&gt;&gt; repair_names([\"\", \"x\", \"\", \"y\", \"x\", \"_2\", \"__\"], repair=\"unique\")\n        &gt;&gt;&gt; # [\"__1\", \"x__2\", \"__3\", \"y\", \"x__5\", \"__6\", \"__7\"]\n        &gt;&gt;&gt; repair_names([\"\", \"x\", NA, \"x\"], repair=\"universal\")\n        &gt;&gt;&gt; # [\"__1\", \"x__2\", \"__3\", \"x__4\"]\n        &gt;&gt;&gt; repair_names([\"(y)\"  \"_z\"  \".2fa\"  \"False\"], repair=\"universal\")\n        &gt;&gt;&gt; # [\"_y_\", \"_z\", \"_2fa\", \"_False\"]\n\n    Returns:\n        The repaired names\n\n    Raises:\n        ValueError: when repair is not a string or callable\n        NameNonUniqueError: when check_unique fails\n    \"\"\"\n    if isinstance(repair, str):\n        repair = BUILTIN_REPAIR_METHODS[repair]  # type: ignore\n    elif (\n        not _is_scalar(repair)\n        and all(isinstance(elem, str) for elem in repair)\n    ):\n        return repair  # type: ignore\n    elif not callable(repair):\n        raise ValueError(\"Expect a function for name repairing.\")\n\n    parameters = inspect.signature(repair).parameters  # type: ignore\n    annotation = list(parameters.values())[0].annotation\n    if annotation is inspect._empty or annotation._name not in (\n        \"Iterable\",\n        \"Sequence\",\n    ):  # scalar input\n        return [repair(name) for name in names]\n\n    return repair(names)\n</code></pre>"},{"location":"api/source/datar.core.operator/","title":"datar.core.operator","text":""},{"location":"api/source/datar.core.operator/","title":"SOURCE CODE datar.core.operator DOCS","text":"<pre><code>\"\"\"Operators for datar\"\"\"\nfrom typing import Callable\nfrom contextlib import contextmanager\n\nfrom pipda import register_operator, Operator\n\n\n@register_operatorDOCS\nclass DatarOperator(Operator):\n    \"\"\"Operator class for datar\"\"\"\n\n    backend = None\n\n    @classmethodDOCS\n    @contextmanager\n    def with_backend(cls, backend: str):\n        \"\"\"Use a backend for the operator\"\"\"\n        old_backend = cls.backend\n        cls.backend = backend\n        yield\n        cls.backend = old_backend\n\n    def __getattr__(self, name: str) -&gt; Callable:\n        from .plugin import plugin\n        return lambda x, y=None: plugin.hooks.operate(\n            name,\n            x,\n            y,\n            __plugin=self.__class__.backend,\n        )\n</code></pre>"},{"location":"api/source/datar.core.options/","title":"datar.core.options","text":""},{"location":"api/source/datar.core.options/","title":"SOURCE CODE datar.core.options DOCS","text":"<pre><code>\"\"\"Provide options\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Any, Generator, Mapping\nfrom contextlib import contextmanager\n\nfrom diot import Diot\nfrom simpleconf import Config\n\nfrom .defaults import OPTION_FILE_CWD, OPTION_FILE_HOME\n\n_key_transform = lambda key: key.replace(\"_\", \".\")\n_dict_transform_back = lambda dic: {\n    key.replace(\".\", \"_\"): val for key, val in dic.items()\n}\n\nOPTIONS = Diot(\n    Config.load(\n        {\n            # Do we allow to use conflict names directly?\n            \"allow_conflict_names\": False,\n            # Disable some installed backends\n            \"backends\": [],\n        },\n        OPTION_FILE_HOME,\n        OPTION_FILE_CWD,\n        ignore_nonexist=True,\n    ),\n    diot_transform=_key_transform,\n)\n\n\ndef options(DOCS\n    *args: str | Mapping[str, Any],\n    _return: bool = None,\n    **kwargs: Any,\n) -&gt; Mapping[str, Any]:\n    \"\"\"Allow the user to set and examine a variety of global options\n\n    Args:\n        *args: Names of options to return\n        **kwargs: name-value pair to create/set an option\n        _return: Whether return the options.\n            If `None`, turned to `True` when option names provided in `args`.\n\n    Returns:\n        The options before updating if `_return` is `True`.\n    \"\"\"\n    if not args and not kwargs and (_return is None or _return is True):\n        # Make sure the options won't be changed\n        return OPTIONS.copy()\n\n    names = [arg.replace(\".\", \"_\") for arg in args if isinstance(arg, str)]\n    pairs = {}\n    for arg in args:\n        if isinstance(arg, dict):\n            pairs.update(_dict_transform_back(arg))\n    pairs.update(_dict_transform_back(kwargs))\n\n    out = None\n    if _return is None:\n        _return = names\n\n    if _return:\n        out = Diot(\n            {\n                name: value\n                for name, value in OPTIONS.items()\n                if name in names or name in pairs\n            },\n            diot_transform=_key_transform,\n        )\n\n    for key, val in pairs.items():\n        oldval = OPTIONS[key]\n        if oldval == val:\n            continue\n        OPTIONS[key] = val\n\n    return out\n\n\n@contextmanagerDOCS\ndef options_context(**kwargs: Any) -&gt; Generator:\n    \"\"\"A context manager to execute code with temporary options\n\n    Note that this is not thread-safe.\n    \"\"\"\n    opts = options()  # type: Mapping[str, Any]\n    options(**kwargs)\n    yield\n    options(opts)\n\n\ndef get_option(x: str, default: Any = None) -&gt; Any:DOCS\n    \"\"\"Get the current value set for option `x`,\n    or `default` (which defaults to `NULL`) if the option is unset.\n\n    Args:\n        x: The name of the option\n        default: The default value if `x` is unset\n    \"\"\"\n    return OPTIONS.get(x, default)\n\n\ndef add_option(x: str, default: Any = None) -&gt; None:DOCS\n    \"\"\"Add an option\n\n    Args:\n        x: The name of the option\n        default: The default value if `x` is unset\n    \"\"\"\n    OPTIONS.setdefault(x, default)\n</code></pre>"},{"location":"api/source/datar.core.plugin/","title":"datar.core.plugin","text":""},{"location":"api/source/datar.core.plugin/","title":"SOURCE CODE datar.core.plugin DOCS","text":"<pre><code>\"\"\"Plugin system to support different backends\"\"\"\nfrom typing import Any, List, Mapping, Tuple, Callable\n\nfrom simplug import Simplug, SimplugResult, makecall\n\nplugin = Simplug(\"datar\")\n\n\ndef _collect(calls: List[Tuple[Callable, Tuple, Mapping]]) -&gt; Mapping[str, Any]:\n    \"\"\"Collect the results from plugins\"\"\"\n    collected = {}\n    for call in calls:\n        out = makecall(call)\n        if out is not None:\n            collected.update(out)\n    return collected\n\n\n@plugin.specDOCS\ndef setup():\n    \"\"\"Initialize the backend\"\"\"\n\n\n@plugin.spec(result=_collect)DOCS\ndef get_versions():\n    \"\"\"Return the versions of the dependencies of the plugin.\"\"\"\n\n\n@plugin.spec(result=SimplugResult.TRY_SINGLE)DOCS\ndef load_dataset(name: str, metadata: Mapping):\n    \"\"\"Implementations for load_dataset()\"\"\"\n\n\n@plugin.spec(result=_collect)DOCS\ndef base_api():\n    \"\"\"What is implemented the base APIs.\"\"\"\n\n\n@plugin.spec(result=_collect)DOCS\ndef dplyr_api():\n    \"\"\"What is implemented the dplyr APIs.\"\"\"\n\n\n@plugin.spec(result=_collect)DOCS\ndef tibble_api():\n    \"\"\"What is implemented the tibble APIs.\"\"\"\n\n\n@plugin.spec(result=_collect)DOCS\ndef forcats_api():\n    \"\"\"What is implemented the forcats APIs.\"\"\"\n\n\n@plugin.spec(result=_collect)DOCS\ndef tidyr_api():\n    \"\"\"What is implemented the tidyr APIs.\"\"\"\n\n\n@plugin.spec(result=_collect)DOCS\ndef misc_api():\n    \"\"\"What is implemented the misc APIs.\"\"\"\n\n\n@plugin.spec(result=SimplugResult.SINGLE)DOCS\ndef c_getitem(item):\n    \"\"\"Get item for c\"\"\"\n\n\n@plugin.spec(result=SimplugResult.SINGLE)DOCS\ndef operate(op: str, x: Any, y: Any = None):\n    \"\"\"Operate on x and y\"\"\"\n</code></pre>"},{"location":"api/source/datar.core.utils/","title":"datar.core.utils","text":""},{"location":"api/source/datar.core.utils/","title":"SOURCE CODE datar.core.utils DOCS","text":"<pre><code>\"\"\"Utilities for datar\"\"\"\nimport sys\nimport logging\nfrom typing import Any, Callable\nfrom contextlib import contextmanager\n\nfrom .plugin import plugin\n\n# logger\nlogger = logging.getLogger(\"datar\")\nlogger.setLevel(logging.INFO)\nstream_handler = logging.StreamHandler(sys.stderr)\nstream_handler.setFormatter(\n    logging.Formatter(\n        \"[%(asctime)s][%(name)s][%(levelname)7s] %(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n    )\n)\nlogger.addHandler(stream_handler)\n\n\nclass NotImplementedByCurrentBackendError(NotImplementedError):DOCS\n    \"\"\"Raised when a function is not implemented by the current backend\"\"\"\n\n    def __init__(self, func: str, data: Any = None) -&gt; None:\n        data_msg = \"\"\n        if data is not None:\n            data_msg = f\"data type: {type(data).__name__}, \"\n        msg = (\n            f\"'{func}' \"\n            f\"({data_msg}backends: \"\n            f\"{', '.join(plugin.get_enabled_plugin_names())})\"\n        )\n        super().__init__(msg)\n\n\nclass CollectionFunction:DOCS\n    \"\"\"Enables c[1:3] to be interpreted as 1:3\"\"\"\n\n    def __init__(self, c_func: Callable) -&gt; None:\n        self.c = c_func\n        self.backend = None\n\n    def __call__(self, *args, **kwargs):\n        kwargs[\"__ast_fallback\"] = \"normal\"\n        return self.c(*args, **kwargs)\n\n    @contextmanagerDOCS\n    def with_backend(self, backend: str):\n        \"\"\"Set the backend for c[]\"\"\"\n        _backend = self.backend\n        self.backend = backend\n        yield\n        self.backend = _backend\n\n    def __getitem__(self, item):DOCS\n        \"\"\"Allow c[1:3] to be interpreted as 1:3\"\"\"\n        return plugin.hooks.c_getitem(item, __plugin=self.backend)\n\n\ndef arg_match(arg, argname, values, errmsg=None):DOCS\n    \"\"\"Make sure arg is in one of the values.\n\n    Mimics `rlang::arg_match`.\n    \"\"\"\n    if not errmsg:\n        values = list(values)\n        errmsg = f\"`{argname}` must be one of {values}.\"\n    if arg not in values:\n        raise ValueError(errmsg)\n    return arg\n</code></pre>"},{"location":"api/source/datar.data/","title":"datar.data","text":""},{"location":"api/source/datar.data/","title":"SOURCE CODE datar.data DOCS","text":"<pre><code>\"\"\"Collects datasets from R-datasets, dplyr and tidyr packages\"\"\"\nimport functools\nfrom typing import Any, List\n\nfrom ..core.load_plugins import plugin\nfrom .metadata import Metadata, metadata\n\n\n# Should never do `from datar.data import *`\n__all__ = []  # type: List[str]\n\n\ndef descr_datasets(*names: str):DOCS\n    \"\"\"Get the information of the given datasets\n\n    Args:\n        *names: Names of the datasets to get the information of.\n    \"\"\"\n    return {\n        key: val\n        for key, val in metadata.items()\n        if key in names or not names\n    }\n\n\ndef add_dataset(name: str, meta: Metadata):DOCS\n    \"\"\"Add a dataset to the registry\n\n    Args:\n        name: The name of the dataset\n        metadata: The metadata of the dataset\n    \"\"\"\n    metadata[name] = meta\n\n\n@functools.lru_cache()DOCS\ndef load_dataset(name: str, __backend: str = None) -&gt; Any:\n    \"\"\"Load the specific dataset\"\"\"\n    loaded = plugin.hooks.load_dataset(name, metadata, __plugin=__backend)\n    if loaded is None:\n        from ..core.utils import NotImplementedByCurrentBackendError\n        raise NotImplementedByCurrentBackendError(f\"loading dataset '{name}'\")\n\n    return loaded\n\n\ndef __getattr__(name: str):\n    # mkapi accesses quite a lot of attributes starting with _\n    if not name.isidentifier() or name.startswith(\"__\"):  # pragma: no cover\n        raise AttributeError(name)\n\n    return load_dataset(name.lower())\n</code></pre>"},{"location":"api/source/datar.data.metadata/","title":"datar.data.metadata","text":""},{"location":"api/source/datar.data.metadata/","title":"SOURCE CODE datar.data.metadata DOCS","text":"<pre><code>from collections import namedtuple\nfrom pathlib import Path\n\nHERE = Path(__file__).parent\n\nMetadata = namedtuple('Metadata', ['descr', 'ref', 'index', 'source'])\n\nmetadata = dict(\n    airlines=Metadata(\n        descr=\"Translation between two letter carrier codes and names\",\n        ref=\"https://github.com/tidyverse/nycflights13\",\n        index=False,\n        source=HERE / \"airlines.csv.gz\",\n    ),\n    airports=Metadata(\n        descr=\"airport names and locations\",\n        ref=\"https://github.com/tidyverse/nycflights13\",\n        index=False,\n        source=HERE / \"airports.csv.gz\",\n    ),\n    airquality=Metadata(\n        descr=\"Daily air quality measurements in New York, May to September 1973.\",\n        ref=\"https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/airquality\",\n        index=False,\n        source=HERE / \"airquality.csv.gz\",\n    ),\n    anscombe=Metadata(\n        descr=\"Four x-y datasets which have the same traditional statistical properties\",\n        ref=\"https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/anscombe\",\n        index=False,\n        source=HERE / \"anscombe.csv.gz\",\n    ),\n    band_instruments=Metadata(\n        descr=\"Band members of the Beatles and Rolling Stones\",\n        ref=\"https://dplyr.tidyverse.org/reference/band_members.html\",\n        index=False,\n        source=HERE / \"band_instruments.csv.gz\",\n    ),\n    band_instruments2=Metadata(\n        descr=\"Band members of the Beatles and Rolling Stones\",\n        ref=\"https://dplyr.tidyverse.org/reference/band_members.html\",\n        index=False,\n        source=HERE / \"band_instruments2.csv.gz\",\n    ),\n    band_members=Metadata(\n        descr=\"Band members of the Beatles and Rolling Stones\",\n        ref=\"https://dplyr.tidyverse.org/reference/band_members.html\",\n        index=False,\n        source=HERE / \"band_members.csv.gz\",\n    ),\n    billboard=Metadata(\n        descr=\"Song rankings for Billboard top 100 in the year 2000\",\n        ref=\"https://tidyr.tidyverse.org/reference/billboard.html\",\n        index=False,\n        source=HERE / \"billboard.csv.gz\",\n    ),\n    chickweight=Metadata(\n        descr=\"Weight versus age of chicks on different diets\",\n        ref=\"https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/ChickWeight\",\n        index=False,\n        source=HERE / \"chickweight.csv.gz\",\n    ),\n    cms_patient_care=Metadata(\n        descr=\"Data from the Centers for Medicare &amp; Medicaid Services\",\n        ref=\"https://tidyr.tidyverse.org/reference/cms_patient_experience.html\",\n        index=False,\n        source=HERE / \"cms_patient_care.csv.gz\",\n    ),\n    cms_patient_experience=Metadata(\n        descr=\"Data from the Centers for Medicare &amp; Medicaid Services\",\n        ref=\"https://tidyr.tidyverse.org/reference/cms_patient_experience.html\",\n        index=False,\n        source=HERE / \"cms_patient_experience.csv.gz\",\n    ),\n    construction=Metadata(\n        descr=\"Completed construction in the US in 2018\",\n        ref=\"https://tidyr.tidyverse.org/reference/construction.html\",\n        index=False,\n        source=HERE / \"construction.csv.gz\",\n    ),\n    diamonds=Metadata(\n        descr=\"A dataset containing the prices and other attributes of almost 54,000 diamonds\",\n        ref=\"https://ggplot2.tidyverse.org/reference/diamonds.html\",\n        index=False,\n        source=HERE / \"diamonds.csv.gz\",\n    ),\n    economics=Metadata(\n        descr=\"US economic time series\",\n        ref=\"https://ggplot2.tidyverse.org/reference/economics.html\",\n        index=False,\n        source=HERE / \"economics.csv.gz\",\n    ),\n    economics_long=Metadata(\n        descr=\"US economic time series\",\n        ref=\"https://ggplot2.tidyverse.org/reference/economics.html\",\n        index=False,\n        source=HERE / \"economics_long.csv.gz\",\n    ),\n    faithful=Metadata(\n        descr=\"Waiting time between eruptions and the duration of the eruption for the Old Faithful geyser in Yellowstone National Park, Wyoming, USA\",\n        ref=\"https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/faithful\",\n        index=False,\n        source=HERE / \"faithful.csv.gz\",\n    ),\n    faithfuld=Metadata(\n        descr=\"2d density estimate of Old Faithful data\",\n        ref=\"https://ggplot2.tidyverse.org/reference/faithfuld.html\",\n        index=False,\n        source=HERE / \"faithfuld.csv.gz\",\n    ),\n    fish_encounters=Metadata(\n        descr=\"Information about fish swimming down a river\",\n        ref=\"https://tidyr.tidyverse.org/reference/fish_encounters.html\",\n        index=False,\n        source=HERE / \"fish_encounters.csv.gz\",\n    ),\n    flights=Metadata(\n        descr=\"all flights that departed from NYC in 2013\",\n        ref=\"https://github.com/tidyverse/nycflights13\",\n        index=False,\n        source=HERE / \"flights.csv.gz\",\n    ),\n    gss_cat=Metadata(\n        descr=\"A sample of categorical variables from the General Social survey\",\n        ref=\"https://forcats.tidyverse.org/reference/gss_cat.html\",\n        index=False,\n        source=HERE / \"gss_cat.csv.gz\",\n    ),\n    household=Metadata(\n        descr=\"This dataset is based on an example in `vignette(\\\"datatable-reshape\\\", package = \\\"data.table\\\")`\",\n        ref=\"https://tidyr.tidyverse.org/reference/household.html\",\n        index=False,\n        source=HERE / \"household.csv.gz\",\n    ),\n    iris=Metadata(\n        descr=\"Edgar Anderson's Iris Data\",\n        ref=\"https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/iris\",\n        index=False,\n        source=HERE / \"iris.csv.gz\",\n    ),\n    luv_colours=Metadata(\n        descr=\"colors() in Luv space\",\n        ref=\"https://ggplot2.tidyverse.org/reference/luv_colours.html\",\n        index=False,\n        source=HERE / \"luv_colours.csv.gz\",\n    ),\n    midwest=Metadata(\n        descr=\"Midwest demographics\",\n        ref=\"https://ggplot2.tidyverse.org/reference/midwest.html\",\n        index=False,\n        source=HERE / \"midwest.csv.gz\",\n    ),\n    mpg=Metadata(\n        descr=\"Fuel economy data from 1999 to 2008 for 38 popular models of cars\",\n        ref=\"https://ggplot2.tidyverse.org/reference/mpg.html\",\n        index=False,\n        source=HERE / \"mpg.csv.gz\",\n    ),\n    msleep=Metadata(\n        descr=\"An updated and expanded version of the mammals sleep dataset\",\n        ref=\"https://ggplot2.tidyverse.org/reference/msleep.html\",\n        index=False,\n        source=HERE / \"msleep.csv.gz\",\n    ),\n    mtcars=Metadata(\n        descr=\"Motor Trend Car Road Tests\",\n        ref=\"https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/mtcars\",\n        index=True,\n        source=HERE / \"mtcars.csv.gz\",\n    ),\n    planes=Metadata(\n        descr=\"construction information about each plane\",\n        ref=\"https://github.com/tidyverse/nycflights13\",\n        index=False,\n        source=HERE / \"planes.csv.gz\",\n    ),\n    population=Metadata(\n        descr=\"A subset of data from the World Health Organization Global Tuberculosis Report, and accompanying global populations.\",\n        ref=\"https://tidyr.tidyverse.org/reference/who.html\",\n        index=False,\n        source=HERE / \"population.csv.gz\",\n    ),\n    presidential=Metadata(\n        descr=\"Terms of 11 presidents from Eisenhower to Obama\",\n        ref=\"https://ggplot2.tidyverse.org/reference/presidential.html\",\n        index=False,\n        source=HERE / \"presidential.csv.gz\",\n    ),\n    relig_income=Metadata(\n        descr=\"Pew religion and income survey\",\n        ref=\"https://tidyr.tidyverse.org/reference/relig_income.html\",\n        index=False,\n        source=HERE / \"relig_income.csv.gz\",\n    ),\n    seals=Metadata(\n        descr=\"Vector field of seal movements\",\n        ref=\"https://ggplot2.tidyverse.org/reference/seals.html\",\n        index=False,\n        source=HERE / \"seals.csv.gz\",\n    ),\n    smith=Metadata(\n        descr=\"A small demo dataset describing John and Mary Smith.\",\n        ref=\"https://tidyr.tidyverse.org/reference/smiths.html\",\n        index=False,\n        source=HERE / \"smith.csv.gz\",\n    ),\n    starwars=Metadata(\n        descr=\"tarwars characters (columns films, vehicles and starships are not included)\",\n        ref=\"https://dplyr.tidyverse.org/reference/starwars.html\",\n        index=False,\n        source=HERE / \"starwars.csv.gz\",\n    ),\n    state_abb=Metadata(\n        descr=\"character vector of 2-letter abbreviations for the state names.\",\n        ref=\"https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/state\",\n        index=False,\n        source=HERE / \"state_abb.csv.gz\",\n    ),\n    state_division=Metadata(\n        descr=\"factor giving state divisions (New England, Middle Atlantic, South Atlantic, East South Central, West South Central, East North Central, West North Central, Mountain, and Pacific).\",\n        ref=\"https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/state\",\n        index=False,\n        source=HERE / \"state_division.csv.gz\",\n    ),\n    state_region=Metadata(\n        descr=\"factor giving the region (Northeast, South, North Central, West) that each state belongs to.\",\n        ref=\"https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/state\",\n        index=False,\n        source=HERE / \"state_region.csv.gz\",\n    ),\n    storms=Metadata(\n        descr=\"This data is a subset of the NOAA Atlantic hurricane database best track data\",\n        ref=\"https://dplyr.tidyverse.org/reference/storms.html\",\n        index=True,\n        source=HERE / \"storms.csv.gz\",\n    ),\n    table1=Metadata(\n        descr=\"Example tabular representations\",\n        ref=\"https://tidyr.tidyverse.org/reference/table1.html\",\n        index=False,\n        source=HERE / \"table1.csv.gz\",\n    ),\n    table2=Metadata(\n        descr=\"Example tabular representations\",\n        ref=\"https://tidyr.tidyverse.org/reference/table1.html\",\n        index=False,\n        source=HERE / \"table2.csv.gz\",\n    ),\n    table3=Metadata(\n        descr=\"Example tabular representations\",\n        ref=\"https://tidyr.tidyverse.org/reference/table1.html\",\n        index=False,\n        source=HERE / \"table3.csv.gz\",\n    ),\n    table4a=Metadata(\n        descr=\"Example tabular representations\",\n        ref=\"https://tidyr.tidyverse.org/reference/table1.html\",\n        index=False,\n        source=HERE / \"table4a.csv.gz\",\n    ),\n    table4b=Metadata(\n        descr=\"Example tabular representations\",\n        ref=\"https://tidyr.tidyverse.org/reference/table1.html\",\n        index=False,\n        source=HERE / \"table4b.csv.gz\",\n    ),\n    table5=Metadata(\n        descr=\"Example tabular representations\",\n        ref=\"https://tidyr.tidyverse.org/reference/table1.html\",\n        index=False,\n        source=HERE / \"table5.csv.gz\",\n    ),\n    toothgrowth=Metadata(\n        descr=\"The Effect of Vitamin C on Tooth Growth in Guinea Pigs\",\n        ref=\"https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/ToothGrowth\",\n        index=False,\n        source=HERE / \"toothgrowth.csv.gz\",\n    ),\n    txhousing=Metadata(\n        descr=\"Housing sales in TX\",\n        ref=\"https://ggplot2.tidyverse.org/reference/txhousing.html\",\n        index=False,\n        source=HERE / \"txhousing.csv.gz\",\n    ),\n    us_rent_income=Metadata(\n        descr=\"US rent and income data\",\n        ref=\"https://tidyr.tidyverse.org/reference/us_rent_income.html\",\n        index=False,\n        source=HERE / \"us_rent_income.csv.gz\",\n    ),\n    warpbreaks=Metadata(\n        descr=\"The Number of Breaks in Yarn during Weaving\",\n        ref=\"https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/warpbreaks\",\n        index=False,\n        source=HERE / \"warpbreaks.csv.gz\",\n    ),\n    weather=Metadata(\n        descr=\"hourly meterological data for each airport\",\n        ref=\"https://github.com/tidyverse/nycflights13\",\n        index=False,\n        source=HERE / \"weather.csv.gz\",\n    ),\n    who=Metadata(\n        descr=\"A subset of data from the World Health Organization Global Tuberculosis Report, and accompanying global populations.\",\n        ref=\"https://tidyr.tidyverse.org/reference/who.html\",\n        index=False,\n        source=HERE / \"who.csv.gz\",\n    ),\n    who2=Metadata(\n        descr=\"A subset of data from the World Health Organization Global Tuberculosis Report, and accompanying global populations.\",\n        ref=\"https://tidyr.tidyverse.org/reference/who.html\",\n        index=False,\n        source=HERE / \"who2.csv.gz\",\n    ),\n    world_bank_pop=Metadata(\n        descr=\"Population data from the world bank\",\n        ref=\"https://tidyr.tidyverse.org/reference/world_bank_pop.html\",\n        index=False,\n        source=HERE / \"world_bank_pop.csv.gz\",\n    ),\n)\n</code></pre>"},{"location":"api/source/datar.datasets/","title":"datar.datasets","text":""},{"location":"api/source/datar.datasets/","title":"SOURCE CODE datar.datasets DOCS","text":"<pre><code># pragma: no cover\nimport warnings\n\n\nclass DatasetsDeprecatedWarning(DeprecationWarning):DOCS\n    ...\n\n\nwarnings.simplefilter(\"always\", DatasetsDeprecatedWarning)\n\nwarnings.warn(\n    \"Import data from `datar.datasets` is deprecated and \"\n    \"will be removed in the future. try `datar.data` instead.\",\n    DatasetsDeprecatedWarning,\n)\n\n\ndef __getattr__(name: str):\n    from . import data\n    return getattr(data, name)\n</code></pre>"},{"location":"api/source/datar.dplyr/","title":"datar.dplyr","text":""},{"location":"api/source/datar.dplyr/","title":"SOURCE CODE datar.dplyr DOCS","text":"<pre><code>from .core.load_plugins import plugin as _plugin\nfrom .core.options import get_option as _get_option\nfrom .apis.dplyr import *\n\nlocals().update(_plugin.hooks.dplyr_api())\n__all__ = [key for key in locals() if not key.startswith(\"_\")]\n_conflict_names = {\"filter\", \"slice\"}\n\nif _get_option(\"allow_conflict_names\"):\n    __all__.extend(_conflict_names)\n    for name in _conflict_names:\n        locals()[name] = locals()[name + \"_\"]\n\n\ndef __getattr__(name):DOCS\n    \"\"\"Even when allow_conflict_names is False, datar.base.sum should be fine\n    \"\"\"\n    if name in _conflict_names:\n        import sys\n        import ast\n        from executing import Source\n        node = Source.executing(sys._getframe(1)).node\n        if isinstance(node, (ast.Call, ast.Attribute)):\n            # import datar.dplyr as d\n            # d.sum(...)\n            return globals()[name + \"_\"]\n\n    raise AttributeError\n</code></pre>"},{"location":"api/source/datar/","title":"datar","text":""},{"location":"api/source/datar/","title":"SOURCE CODE datar DOCS","text":"<pre><code>from typing import Mapping as _Mapping\n\nfrom .core import operator as _\nfrom .core.defaults import f\nfrom .core.options import options, get_option, options_context\n\n__version__ = \"0.15.7\"\n\n\ndef get_versions(prnt: bool = True) -&gt; _Mapping[str, str]:DOCS\n    \"\"\"Return/Print the versions of the dependencies.\n\n    Args:\n        prnt: If True, print the versions, otherwise return them.\n\n    Returns:\n        A dict of the versions of the dependencies if `prnt` is False.\n    \"\"\"\n    import sys\n    import executing\n    import pipda\n    import simplug\n    from .core.load_plugins import plugin\n\n    versions = {\n        \"python\": sys.version,\n        \"datar\": __version__,\n        \"simplug\": simplug.__version__,\n        \"executing\": executing.__version__,\n        \"pipda\": pipda.__version__,\n    }\n\n    versions_plg = plugin.hooks.get_versions()\n    versions.update(versions_plg)\n\n    if not prnt:\n        return versions\n\n    keylen = max(map(len, versions))\n    for key in versions:\n        ver = versions[key]\n        verlines = ver.splitlines()\n        print(f\"{key.ljust(keylen)}: {verlines.pop(0)}\")\n        for verline in verlines:  # pragma: no cover\n            print(f\"{' ' * keylen}  {verline}\")\n\n    return None\n</code></pre>"},{"location":"notebooks/across/","title":"across","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\n\nfrom datar.data import iris\nfrom datar.all import *\n\nnb_header(across, if_any, if_all, c_across)\n</pre> %run nb_helpers.py  from datar.data import iris from datar.all import *  nb_header(across, if_any, if_all, c_across) Try this notebook on binder. <p>Apply the same transformation to multiple columns</p> <pre><code>The original API:\nhttps://dplyr.tidyverse.org/reference/across.html\n\nExamples:\n    #\n    &gt;&gt;&gt; iris &gt;&gt; mutate(across(c(f.Sepal_Length, f.Sepal_Width), round))\n        Sepal_Length  Sepal_Width  Petal_Length  Petal_Width    Species\n           &lt;float64&gt;    &lt;float64&gt;     &lt;float64&gt;    &lt;float64&gt;   &lt;object&gt;\n    0            5.0          4.0           1.4          0.2     setosa\n    1            5.0          3.0           1.4          0.2     setosa\n    ..           ...          ...           ...          ...        ...\n\n    &gt;&gt;&gt; iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(\n    &gt;&gt;&gt;     across(starts_with(\"Sepal\"), mean)\n    &gt;&gt;&gt; )\n          Species  Sepal_Length  Sepal_Width\n         &lt;object&gt;     &lt;float64&gt;    &lt;float64&gt;\n    0      setosa         5.006        3.428\n    1  versicolor         5.936        2.770\n    2   virginica         6.588        2.974\n\nArgs:\n    _data: The dataframe.\n    *args: If given, the first 2 elements should be columns and functions\n        apply to each of the selected columns. The rest of them will be\n        the arguments for the functions.\n    _names: A glue specification that describes how to name\n        the output columns. This can use `{_col}` to stand for the\n        selected column name, and `{_fn}` to stand for the name of\n        the function being applied.\n        The default (None) is equivalent to `{_col}` for the\n        single function case and `{_col}_{_fn}` for the case where\n        a list is used for _fns. In such a case, `{_fn}` is 0-based.\n        To use 1-based index, use `{_fn1}`\n    _fn_context: Defines the context to evaluate the arguments for functions\n        if they are plain functions.\n        Note that registered functions will use its own context\n    **kwargs: Keyword arguments for the functions\n\nReturns:\n    A dataframe with one column for each column and each function.</code></pre> In\u00a0[2]: Copied! <pre># round not changing dtypes (Series.round)\niris &gt;&gt; mutate(across(c(f.Sepal_Length, f.Sepal_Width), round))\n</pre> # round not changing dtypes (Series.round) iris &gt;&gt; mutate(across(c(f.Sepal_Length, f.Sepal_Width), round)) Out[2]: Sepal_Length Sepal_Width Petal_Length Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.0 4.0 1.4 0.2 setosa 1 5.0 3.0 1.4 0.2 setosa 2 5.0 3.0 1.3 0.2 setosa 3 5.0 3.0 1.5 0.2 setosa ... ... ... ... ... ... 4 5.0 4.0 1.4 0.2 setosa 145 7.0 3.0 5.2 2.3 virginica 146 6.0 2.0 5.0 1.9 virginica 147 6.0 3.0 5.2 2.0 virginica 148 6.0 3.0 5.4 2.3 virginica 149 6.0 3.0 5.1 1.8 virginica <p>150 rows \u00d7 5 columns</p> In\u00a0[3]: Copied! <pre>iris &gt;&gt; mutate(across(c(0, 1), round))\n</pre> iris &gt;&gt; mutate(across(c(0, 1), round)) Out[3]: Sepal_Length Sepal_Width Petal_Length Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.0 4.0 1.4 0.2 setosa 1 5.0 3.0 1.4 0.2 setosa 2 5.0 3.0 1.3 0.2 setosa 3 5.0 3.0 1.5 0.2 setosa ... ... ... ... ... ... 4 5.0 4.0 1.4 0.2 setosa 145 7.0 3.0 5.2 2.3 virginica 146 6.0 2.0 5.0 1.9 virginica 147 6.0 3.0 5.2 2.0 virginica 148 6.0 3.0 5.4 2.3 virginica 149 6.0 3.0 5.1 1.8 virginica <p>150 rows \u00d7 5 columns</p> In\u00a0[4]: Copied! <pre># use slice with column names\niris &gt;&gt; mutate(across(c[:f.Sepal_Width], round)) \n</pre> # use slice with column names iris &gt;&gt; mutate(across(c[:f.Sepal_Width], round))  Out[4]: Sepal_Length Sepal_Width Petal_Length Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.0 3.5 1.4 0.2 setosa 1 5.0 3.0 1.4 0.2 setosa 2 5.0 3.2 1.3 0.2 setosa 3 5.0 3.1 1.5 0.2 setosa ... ... ... ... ... ... 4 5.0 3.6 1.4 0.2 setosa 145 7.0 3.0 5.2 2.3 virginica 146 6.0 2.5 5.0 1.9 virginica 147 6.0 3.0 5.2 2.0 virginica 148 6.0 3.4 5.4 2.3 virginica 149 6.0 3.0 5.1 1.8 virginica <p>150 rows \u00d7 5 columns</p> In\u00a0[5]: Copied! <pre># to include stop of slice\niris &gt;&gt; mutate(across(c[:f.Sepal_Width:1], round)) \n</pre> # to include stop of slice iris &gt;&gt; mutate(across(c[:f.Sepal_Width:1], round))  Out[5]: Sepal_Length Sepal_Width Petal_Length Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.0 4.0 1.4 0.2 setosa 1 5.0 3.0 1.4 0.2 setosa 2 5.0 3.0 1.3 0.2 setosa 3 5.0 3.0 1.5 0.2 setosa ... ... ... ... ... ... 4 5.0 4.0 1.4 0.2 setosa 145 7.0 3.0 5.2 2.3 virginica 146 6.0 2.0 5.0 1.9 virginica 147 6.0 3.0 5.2 2.0 virginica 148 6.0 3.0 5.4 2.3 virginica 149 6.0 3.0 5.1 1.8 virginica <p>150 rows \u00d7 5 columns</p> In\u00a0[6]: Copied! <pre>iris &gt;&gt; mutate(across(where(is_double) &amp; ~c(f.Petal_Length, f.Petal_Width), round))\n</pre> iris &gt;&gt; mutate(across(where(is_double) &amp; ~c(f.Petal_Length, f.Petal_Width), round)) Out[6]: Sepal_Length Sepal_Width Petal_Length Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.0 4.0 1.4 0.2 setosa 1 5.0 3.0 1.4 0.2 setosa 2 5.0 3.0 1.3 0.2 setosa 3 5.0 3.0 1.5 0.2 setosa ... ... ... ... ... ... 4 5.0 4.0 1.4 0.2 setosa 145 7.0 3.0 5.2 2.3 virginica 146 6.0 2.0 5.0 1.9 virginica 147 6.0 3.0 5.2 2.0 virginica 148 6.0 3.0 5.4 2.3 virginica 149 6.0 3.0 5.1 1.8 virginica <p>150 rows \u00d7 5 columns</p> In\u00a0[7]: Copied! <pre>iris = iris &gt;&gt; mutate(Species=as_factor(f.Species))\niris\n</pre> iris = iris &gt;&gt; mutate(Species=as_factor(f.Species)) iris Out[7]: Sepal_Length Sepal_Width Petal_Length Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;category&gt; 0 5.1 3.5 1.4 0.2 setosa 1 4.9 3.0 1.4 0.2 setosa 2 4.7 3.2 1.3 0.2 setosa 3 4.6 3.1 1.5 0.2 setosa ... ... ... ... ... ... 4 5.0 3.6 1.4 0.2 setosa 145 6.7 3.0 5.2 2.3 virginica 146 6.3 2.5 5.0 1.9 virginica 147 6.5 3.0 5.2 2.0 virginica 148 6.2 3.4 5.4 2.3 virginica 149 5.9 3.0 5.1 1.8 virginica <p>150 rows \u00d7 5 columns</p> In\u00a0[8]: Copied! <pre>iris = iris &gt;&gt; mutate(across(where(is_factor), as_character))\niris\n</pre> iris = iris &gt;&gt; mutate(across(where(is_factor), as_character)) iris Out[8]: Sepal_Length Sepal_Width Petal_Length Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.1 3.5 1.4 0.2 setosa 1 4.9 3.0 1.4 0.2 setosa 2 4.7 3.2 1.3 0.2 setosa 3 4.6 3.1 1.5 0.2 setosa ... ... ... ... ... ... 4 5.0 3.6 1.4 0.2 setosa 145 6.7 3.0 5.2 2.3 virginica 146 6.3 2.5 5.0 1.9 virginica 147 6.5 3.0 5.2 2.0 virginica 148 6.2 3.4 5.4 2.3 virginica 149 5.9 3.0 5.1 1.8 virginica <p>150 rows \u00d7 5 columns</p> In\u00a0[10]: Copied! <pre>iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(\n    across(starts_with(\"Sepal\"), mean)\n)\n</pre> iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(     across(starts_with(\"Sepal\"), mean) ) Out[10]: Species Sepal_Length Sepal_Width &lt;object&gt; &lt;float64&gt; &lt;float64&gt; 0 setosa 5.006 3.428 1 versicolor 5.936 2.770 2 virginica 6.588 2.974 In\u00a0[11]: Copied! <pre>iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(\n    across(starts_with(\"Sepal\"), dict(mean=mean, sd=sd))\n)\n</pre> iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(     across(starts_with(\"Sepal\"), dict(mean=mean, sd=sd)) ) Out[11]: Species Sepal_Length_mean Sepal_Length_sd Sepal_Width_mean Sepal_Width_sd &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 setosa 5.006 0.352490 3.428 0.379064 1 versicolor 5.936 0.516171 2.770 0.313798 2 virginica 6.588 0.635880 2.974 0.322497 In\u00a0[12]: Copied! <pre>iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(\n    across(starts_with(\"Sepal\"), mean, _names = \"mean_{_col}\")\n)\n</pre> iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(     across(starts_with(\"Sepal\"), mean, _names = \"mean_{_col}\") ) Out[12]: Species mean_Sepal_Length mean_Sepal_Width &lt;object&gt; &lt;float64&gt; &lt;float64&gt; 0 setosa 5.006 3.428 1 versicolor 5.936 2.770 2 virginica 6.588 2.974 In\u00a0[13]: Copied! <pre>iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(\n    across(starts_with(\"Sepal\"), dict(mean=mean, sd=sd), _names = \"{_col}.{_fn}\")\n)\n</pre> iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(     across(starts_with(\"Sepal\"), dict(mean=mean, sd=sd), _names = \"{_col}.{_fn}\") ) Out[13]: Species Sepal_Length.mean Sepal_Length.sd Sepal_Width.mean Sepal_Width.sd &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 setosa 5.006 0.352490 3.428 0.379064 1 versicolor 5.936 0.516171 2.770 0.313798 2 virginica 6.588 0.635880 2.974 0.322497 In\u00a0[14]: Copied! <pre>iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(\n    across(starts_with(\"Sepal\"), [mean, sd], _names = \"{_col}.fn{_fn}\")\n)\n</pre> iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(     across(starts_with(\"Sepal\"), [mean, sd], _names = \"{_col}.fn{_fn}\") ) Out[14]: Species Sepal_Length.fn0 Sepal_Length.fn1 Sepal_Width.fn0 Sepal_Width.fn1 &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 setosa 5.006 0.352490 3.428 0.379064 1 versicolor 5.936 0.516171 2.770 0.313798 2 virginica 6.588 0.635880 2.974 0.322497 In\u00a0[15]: Copied! <pre>iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(\n    across(\n        starts_with(\"Sepal\"), \n        [mean, sd], \n        _names=\"{_col}.fn{_fn}\", \n    )\n)\n# or use _fn0\n\n# iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(\n#     across(\n#         starts_with(\"Sepal\"), \n#         [mean, sd], \n#         _names=\"{_col}.fn{_fn1}\", # _fn1 for 1-based\n#     )\n# )\n</pre> iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(     across(         starts_with(\"Sepal\"),          [mean, sd],          _names=\"{_col}.fn{_fn}\",      ) ) # or use _fn0  # iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise( #     across( #         starts_with(\"Sepal\"),  #         [mean, sd],  #         _names=\"{_col}.fn{_fn1}\", # _fn1 for 1-based #     ) # )  Out[15]: Species Sepal_Length.fn0 Sepal_Length.fn1 Sepal_Width.fn0 Sepal_Width.fn1 &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 setosa 5.006 0.352490 3.428 0.379064 1 versicolor 5.936 0.516171 2.770 0.313798 2 virginica 6.588 0.635880 2.974 0.322497 In\u00a0[16]: Copied! <pre>iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(\n    across(starts_with(\"Sepal\"), [mean, sd], _names = \"{_col}.fn{_fn1}\")\n)\n</pre> iris &gt;&gt; group_by(f.Species) &gt;&gt; summarise(     across(starts_with(\"Sepal\"), [mean, sd], _names = \"{_col}.fn{_fn1}\") ) Out[16]: Species Sepal_Length.fn1 Sepal_Length.fn2 Sepal_Width.fn1 Sepal_Width.fn2 &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 setosa 5.006 0.352490 3.428 0.379064 1 versicolor 5.936 0.516171 2.770 0.313798 2 virginica 6.588 0.635880 2.974 0.322497 In\u00a0[17]: Copied! <pre>iris &gt;&gt; filter(if_any(ends_with(\"Width\"), lambda x: x &gt; 4))\n</pre> iris &gt;&gt; filter(if_any(ends_with(\"Width\"), lambda x: x &gt; 4)) Out[17]: Sepal_Length Sepal_Width Petal_Length Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 15 5.7 4.4 1.5 0.4 setosa 32 5.2 4.1 1.5 0.1 setosa 33 5.5 4.2 1.4 0.2 setosa In\u00a0[18]: Copied! <pre>iris &gt;&gt; filter(if_all(ends_with(\"Width\"), lambda x: x &gt; 2))\n</pre> iris &gt;&gt; filter(if_all(ends_with(\"Width\"), lambda x: x &gt; 2)) Out[18]: Sepal_Length Sepal_Width Petal_Length Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 100 6.3 3.3 6.0 2.5 virginica 102 7.1 3.0 5.9 2.1 virginica 104 6.5 3.0 5.8 2.2 virginica 105 7.6 3.0 6.6 2.1 virginica 109 7.2 3.6 6.1 2.5 virginica 112 6.8 3.0 5.5 2.1 virginica 114 5.8 2.8 5.1 2.4 virginica 115 6.4 3.2 5.3 2.3 virginica 117 7.7 3.8 6.7 2.2 virginica 118 7.7 2.6 6.9 2.3 virginica 120 6.9 3.2 5.7 2.3 virginica 124 6.7 3.3 5.7 2.1 virginica 128 6.4 2.8 5.6 2.1 virginica 132 6.4 2.8 5.6 2.2 virginica 135 7.7 3.0 6.1 2.3 virginica 136 6.3 3.4 5.6 2.4 virginica 139 6.9 3.1 5.4 2.1 virginica 140 6.7 3.1 5.6 2.4 virginica 141 6.9 3.1 5.1 2.3 virginica 143 6.8 3.2 5.9 2.3 virginica 144 6.7 3.3 5.7 2.5 virginica 145 6.7 3.0 5.2 2.3 virginica 148 6.2 3.4 5.4 2.3 virginica In\u00a0[19]: Copied! <pre>df = tibble(\n    id=[1, 2, 3, 4],\n    w=runif(4), \n    x=runif(4), \n    y=runif(4), \n    z=runif(4)\n)\ndf &gt;&gt; rowwise() &gt;&gt; mutate(\n    sum = sum(c_across(c[f.w:f.z])),\n    sd = sd(c_across(c[f.w:f.z]))\n)\n</pre> df = tibble(     id=[1, 2, 3, 4],     w=runif(4),      x=runif(4),      y=runif(4),      z=runif(4) ) df &gt;&gt; rowwise() &gt;&gt; mutate(     sum = sum(c_across(c[f.w:f.z])),     sd = sd(c_across(c[f.w:f.z])) ) Out[19]: id w x y z sum sd &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 1 0.909293 0.880456 0.174213 0.382593 1.963962 0.416324 1 2 0.102912 0.952811 0.632536 0.845920 1.688258 0.429225 2 3 0.425592 0.320275 0.803515 0.831533 1.549382 0.254112 3 4 0.218472 0.849190 0.637853 0.887980 1.705514 0.321026 <p>TibbleRowwise:  (n=4) </p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/across/#across","title":"\u2605 across\u00b6","text":""},{"location":"notebooks/across/#if_any","title":"\u2605 if_any\u00b6","text":""},{"location":"notebooks/across/#apply-the-same-predicate-function-to-a-selection-of-columns-and-combine","title":"Apply the same predicate function to a selection of columns and combine\u00b6","text":"<p>the results True if any element is True.</p> <p>See Also: <code>across()</code></p>"},{"location":"notebooks/across/#if_all","title":"\u2605 if_all\u00b6","text":""},{"location":"notebooks/across/#apply-the-same-predicate-function-to-a-selection-of-columns-and-combine","title":"Apply the same predicate function to a selection of columns and combine\u00b6","text":"<p>the results True if all elements are True.</p> <p>See Also: <code>across()</code></p>"},{"location":"notebooks/across/#c_across","title":"\u2605 c_across\u00b6","text":""},{"location":"notebooks/across/#apply-the-same-transformation-to-multiple-columns-rowwisely","title":"Apply the same transformation to multiple columns rowwisely\u00b6","text":""},{"location":"notebooks/across/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: The dataframe <code>_cols</code>: The columns</p>"},{"location":"notebooks/across/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A rowwise tibble</p>"},{"location":"notebooks/add_column/","title":"add_column","text":"In\u00a0[1]: Copied! <pre># https://tibble.tidyverse.org/reference/add_column.html\n\nfrom datar import f\nfrom datar.tibble import *\nfrom datar.base import seq\nfrom datar.core.names import NameNonUniqueError\n\n%run nb_helpers.py\nnb_header(add_column)\n</pre> # https://tibble.tidyverse.org/reference/add_column.html  from datar import f from datar.tibble import * from datar.base import seq from datar.core.names import NameNonUniqueError  %run nb_helpers.py nb_header(add_column) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x=seq(1,3), y=seq(3,1))\ndf &gt;&gt; add_column(z=seq(-1,1), w=0)\n</pre> df = tibble(x=seq(1,3), y=seq(3,1)) df &gt;&gt; add_column(z=seq(-1,1), w=0) Out[2]: x y z w &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 1 3 -1 0 1 2 2 0 0 2 3 1 1 0 In\u00a0[3]: Copied! <pre>df &gt;&gt; add_column(z=seq(-1,1), _before=f.y)\n</pre> df &gt;&gt; add_column(z=seq(-1,1), _before=f.y) Out[3]: x z y &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 1 -1 3 1 2 0 2 2 3 1 1 In\u00a0[4]: Copied! <pre># You can't overwrite existing columns\ntry:\n    df &gt;&gt; add_column(x = seq(4,6))\nexcept NameNonUniqueError as err:\n    print(err)\n</pre> # You can't overwrite existing columns try:     df &gt;&gt; add_column(x = seq(4,6)) except NameNonUniqueError as err:     print(err) <pre>Names must be unique: x\n</pre> In\u00a0[5]: Copied! <pre># You can't create new observations\nwith try_catch():\n    df &gt;&gt; add_column(z = seq(1,5))\n</pre> # You can't create new observations with try_catch():     df &gt;&gt; add_column(z = seq(1,5)) <pre>[ValueError] Value has incompatible index.\n</pre>"},{"location":"notebooks/add_column/#add_column","title":"\u2605 add_column\u00b6","text":""},{"location":"notebooks/add_column/#add-one-or-more-columns-to-an-existing-data-frame","title":"Add one or more columns to an existing data frame.\u00b6","text":""},{"location":"notebooks/add_column/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: Data frame to append to <code>*args</code>: and <code>**kwargs</code>: Name-value pairs to add to the data frame <code>_before</code>: and <code>_after</code>: Column index or name where to add the new columns \u2003\u2003\u2003\u2003(default to add after the last column)</p> <p> <code>_dtypes</code>: The dtypes for the new columns, either a uniform dtype or a \u2003\u2003\u2003\u2003dict of dtypes with keys the column names</p>"},{"location":"notebooks/add_column/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The dataframe with the added columns</p>"},{"location":"notebooks/add_row/","title":"add_row","text":"In\u00a0[1]: Copied! <pre># https://tibble.tidyverse.org/reference/add_row.html\n\nfrom datar.tibble import *\nfrom datar.base import seq\n\n%run nb_helpers.py\nnb_header(add_row)\n</pre> # https://tibble.tidyverse.org/reference/add_row.html  from datar.tibble import * from datar.base import seq  %run nb_helpers.py nb_header(add_row) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x=seq(1,3), y=seq(3,1))\n\ndf &gt;&gt; add_row(x=4, y=0)\n</pre> df = tibble(x=seq(1,3), y=seq(3,1))  df &gt;&gt; add_row(x=4, y=0) Out[2]: x y &lt;int64&gt; &lt;int64&gt; 0 1 3 1 2 2 2 3 1 3 4 0 In\u00a0[3]: Copied! <pre>df &gt;&gt; add_row(x=4, y=0, _before=2) # 0-based\n</pre> df &gt;&gt; add_row(x=4, y=0, _before=2) # 0-based Out[3]: x y &lt;int64&gt; &lt;int64&gt; 0 1 3 1 2 2 2 4 0 3 3 1 In\u00a0[4]: Copied! <pre>df &gt;&gt; add_row(x=[4,5], y=[0,-1])\n</pre> df &gt;&gt; add_row(x=[4,5], y=[0,-1]) Out[4]: x y &lt;int64&gt; &lt;int64&gt; 0 1 3 1 2 2 2 3 1 3 4 0 4 5 -1 In\u00a0[5]: Copied! <pre>df &gt;&gt; add_row(tibble_row(x = 4, y = 0))\n</pre> df &gt;&gt; add_row(tibble_row(x = 4, y = 0)) Out[5]: x y &lt;int64&gt; &lt;int64&gt; 0 1 3 1 2 2 2 3 1 3 4 0 In\u00a0[6]: Copied! <pre># Absent variables get missing values\ndf &gt;&gt; add_row(x = 4)\n</pre> # Absent variables get missing values df &gt;&gt; add_row(x = 4) Out[6]: x y &lt;int64&gt; &lt;float64&gt; 0 1 3.0 1 2 2.0 2 3 1.0 3 4 NaN In\u00a0[7]: Copied! <pre># You can't create new variables\nwith try_catch():\n    df &gt;&gt; add_row(z = 10)\n</pre> # You can't create new variables with try_catch():     df &gt;&gt; add_row(z = 10) <pre>[ValueError] New rows can't add columns: ['z']\n</pre>"},{"location":"notebooks/add_row/#add_row","title":"\u2605 add_row\u00b6","text":""},{"location":"notebooks/add_row/#add-one-or-more-rows-of-data-to-an-existing-data-frame","title":"Add one or more rows of data to an existing data frame.\u00b6","text":"<p>Aliases <code>add_case</code></p>"},{"location":"notebooks/add_row/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: Data frame to append to. <code>*args</code>: and <code>**kwargs</code>: Name-value pairs to add to the data frame. <code>_before</code>: and <code>_after</code>: row index where to add the new rows. \u2003\u2003\u2003\u2003(default to add after the last row)</p>"},{"location":"notebooks/add_row/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The dataframe with the added rows</p>"},{"location":"notebooks/arrange/","title":"arrange","text":"In\u00a0[3]: Copied! <pre>%run nb_helpers.py\nfrom datar.data import mtcars, iris\nfrom datar.all import *\n\nnb_header(arrange)\n</pre> %run nb_helpers.py from datar.data import mtcars, iris from datar.all import *  nb_header(arrange) Try this notebook on binder. In\u00a0[4]: Copied! <pre>arrange(mtcars, f.cyl, f.disp)\n</pre> arrange(mtcars, f.cyl, f.disp) Out[4]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 In\u00a0[5]: Copied! <pre>mtcars &gt;&gt; arrange(desc(f.disp))\n</pre> mtcars &gt;&gt; arrange(desc(f.disp)) Out[5]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 In\u00a0[6]: Copied! <pre>by_cyl = mtcars &gt;&gt; group_by(f.cyl)\nby_cyl &gt;&gt; arrange(desc(f.wt)) \n</pre> by_cyl = mtcars &gt;&gt; group_by(f.cyl) by_cyl &gt;&gt; arrange(desc(f.wt))  Out[6]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 1 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 2 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 3 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 4 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 5 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 6 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 7 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 8 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 9 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 10 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 11 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 12 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 13 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 14 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 15 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 16 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 17 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 18 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 19 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 20 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 21 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 22 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 23 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 24 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 25 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 26 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 27 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 28 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 29 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 30 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 31 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 <p>TibbleGrouped: cyl (n=3) </p> In\u00a0[7]: Copied! <pre>by_cyl &gt;&gt; arrange(desc(f.wt), _by_group=True) \n</pre> by_cyl &gt;&gt; arrange(desc(f.wt), _by_group=True)  Out[7]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 1 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 2 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 3 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 4 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 5 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 6 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 7 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 8 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 9 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 10 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 11 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 12 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 13 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 14 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 15 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 16 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 17 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 18 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 19 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 20 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 21 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 22 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 23 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 24 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 25 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 26 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 27 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 28 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 29 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 30 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 31 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 <p>TibbleGrouped: cyl (n=3) </p> In\u00a0[8]: Copied! <pre># use subscription for f-expression\ndef tidy_eval_arrange(_data, var):\n  return _data &gt;&gt; arrange(f[var])\n  \ntidy_eval_arrange(mtcars, 'mpg')\n</pre> # use subscription for f-expression def tidy_eval_arrange(_data, var):   return _data &gt;&gt; arrange(f[var])    tidy_eval_arrange(mtcars, 'mpg') Out[8]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 In\u00a0[9]: Copied! <pre>iris &gt;&gt; arrange(across(starts_with(\"Sepal\")))\n</pre> iris &gt;&gt; arrange(across(starts_with(\"Sepal\"))) Out[9]: Sepal_Length Sepal_Width Petal_Length Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 13 4.3 3.0 1.1 0.1 setosa 8 4.4 2.9 1.4 0.2 setosa 38 4.4 3.0 1.3 0.2 setosa 42 4.4 3.2 1.3 0.2 setosa ... ... ... ... ... ... 41 4.5 2.3 1.3 0.3 setosa 118 7.7 2.6 6.9 2.3 virginica 122 7.7 2.8 6.7 2.0 virginica 135 7.7 3.0 6.1 2.3 virginica 117 7.7 3.8 6.7 2.2 virginica 131 7.9 3.8 6.4 2.0 virginica <p>150 rows \u00d7 5 columns</p> In\u00a0[10]: Copied! <pre>iris &gt;&gt; arrange(across(starts_with(\"Sepal\"), desc))\n</pre> iris &gt;&gt; arrange(across(starts_with(\"Sepal\"), desc)) Out[10]: Sepal_Length Sepal_Width Petal_Length Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 131 7.9 3.8 6.4 2.0 virginica 117 7.7 3.8 6.7 2.2 virginica 135 7.7 3.0 6.1 2.3 virginica 122 7.7 2.8 6.7 2.0 virginica ... ... ... ... ... ... 118 7.7 2.6 6.9 2.3 virginica 41 4.5 2.3 1.3 0.3 setosa 42 4.4 3.2 1.3 0.2 setosa 38 4.4 3.0 1.3 0.2 setosa 8 4.4 2.9 1.4 0.2 setosa 13 4.3 3.0 1.1 0.1 setosa <p>150 rows \u00d7 5 columns</p>"},{"location":"notebooks/arrange/#arrange","title":"\u2605 arrange\u00b6","text":""},{"location":"notebooks/arrange/#orders-the-rows-of-a-data-frame-by-the-values-of-selected-columns","title":"orders the rows of a data frame by the values of selected columns.\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/arrange.html</p>"},{"location":"notebooks/arrange/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>*series</code>: Variables, or functions of variables. \u2003\u2003\u2003\u2003Use desc() to sort a variable in descending order.</p> <p> <code>_by_group</code>: If TRUE, will sort first by grouping variable. \u2003\u2003\u2003\u2003Applies to grouped data frames only.</p> <p> <code>**kwargs</code>: Name-value pairs that apply with mutate</p>"},{"location":"notebooks/arrange/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003An object of the same type as _data. \u2003\u2003The output has the following properties: \u2003\u2003\u2003\u2003All rows appear in the output, but (usually) in a different place. \u2003\u2003\u2003\u2003Columns are not modified. \u2003\u2003\u2003\u2003Groups are not modified. \u2003\u2003\u2003\u2003Data frame attributes are preserved.</p>"},{"location":"notebooks/base-arithmetic/","title":"base-arithmetic","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\n\nfrom datar.all import *\n\ndebug_kwargs = {'prefix': '\\n', 'sep': f'\\n{\"-\" * 20}\\n'}\nnb_header(\n    sum, prod, mean, median, min, max, var, pmin, pmax,\n    round, sqrt, abs, sign, trunc, ceiling, floor, signif,\n    log, exp, log2, log10, log1p, cov, scale, col_sums,\n    row_sums, col_means, row_means, col_sds, row_sds,\n    col_medians, row_medians, quantile, sd, weighted_mean\n)\n</pre> %run nb_helpers.py  from datar.all import *  debug_kwargs = {'prefix': '\\n', 'sep': f'\\n{\"-\" * 20}\\n'} nb_header(     sum, prod, mean, median, min, max, var, pmin, pmax,     round, sqrt, abs, sign, trunc, ceiling, floor, signif,     log, exp, log2, log10, log1p, cov, scale, col_sums,     row_sums, col_means, row_means, col_sds, row_sds,     col_medians, row_medians, quantile, sd, weighted_mean ) Try this notebook on binder. In\u00a0[2]: Copied! <pre>debug(\n    sum([1,2,4,6]),\n    prod([1,2,4,6]),\n    mean([1,2,4,6]),\n    median([1,2,4,6]),\n    min([1,2,4,6]),\n    max([1,2,4,6]),\n    var([1,2,4,6]),\n    pmin([1,4], [2,3]),\n    pmax([1,4], [2,3]),\n    **debug_kwargs\n)\n</pre>  debug(     sum([1,2,4,6]),     prod([1,2,4,6]),     mean([1,2,4,6]),     median([1,2,4,6]),     min([1,2,4,6]),     max([1,2,4,6]),     var([1,2,4,6]),     pmin([1,4], [2,3]),     pmax([1,4], [2,3]),     **debug_kwargs ) <pre>\nsum([1,2,4,6])\n--------------------\n13\n\nprod([1,2,4,6])\n--------------------\n48\n\nmean([1,2,4,6])\n--------------------\n3.25\n\nmedian([1,2,4,6])\n--------------------\n3.0\n\nmin([1,2,4,6])\n--------------------\n1\n\nmax([1,2,4,6])\n--------------------\n6\n\nvar([1,2,4,6])\n--------------------\n4.916666666666667\n\npmin([1,4], [2,3])\n--------------------\narray([1, 3])\n\npmax([1,4], [2,3])\n--------------------\narray([2, 4])\n</pre> In\u00a0[3]: Copied! <pre>debug(\n    round([1.4, 1.5]),\n    sqrt([1.1, 2.1]),\n    abs([1, -1]),\n    sign([10, -10]),\n    trunc([1.1, 2.1]),\n    ceiling([1.1, 2.1]),\n    floor([1.1, 2.1]),\n    signif(3.14567e-10, 3),\n    **debug_kwargs\n)\n</pre> debug(     round([1.4, 1.5]),     sqrt([1.1, 2.1]),     abs([1, -1]),     sign([10, -10]),     trunc([1.1, 2.1]),     ceiling([1.1, 2.1]),     floor([1.1, 2.1]),     signif(3.14567e-10, 3),     **debug_kwargs ) <pre>\nround([1.4, 1.5])\n--------------------\narray([1., 2.])\n\nsqrt([1.1, 2.1])\n--------------------\narray([1.04880885, 1.44913767])\n\nabs([1, -1])\n--------------------\narray([1, 1])\n\nsign([10, -10])\n--------------------\narray([ 1, -1])\n\ntrunc([1.1, 2.1])\n--------------------\narray([1., 2.])\n\nceiling([1.1, 2.1])\n--------------------\narray([2., 3.])\n\nfloor([1.1, 2.1])\n--------------------\narray([1., 2.])\n\nsignif(3.14567e-10, 3)\n--------------------\narray(3.15e-10)\n</pre> In\u00a0[4]: Copied! <pre>debug(\n    log(exp(2)),\n    exp(2),\n    log2(4),\n    log10(100),\n    log1p(exp(1)-1),\n    cov([1, 2, 3], [3, 2, 1]),\n    scale([1, 2, 3]),\n    **debug_kwargs\n)\n</pre> debug(     log(exp(2)),     exp(2),     log2(4),     log10(100),     log1p(exp(1)-1),     cov([1, 2, 3], [3, 2, 1]),     scale([1, 2, 3]),     **debug_kwargs ) <pre>\nlog(exp(2))\n--------------------\n2.0\n\nexp(2)\n--------------------\n7.38905609893065\n\nlog2(4)\n--------------------\n2.0\n\nlog10(100)\n--------------------\n2.0\n\nlog1p(exp(1)-1)\n--------------------\n1.0\n\ncov([1, 2, 3], [3, 2, 1])\n--------------------\n-1.0\n\nscale([1, 2, 3])\n--------------------\narray([-1.,  0.,  1.])\n</pre> In\u00a0[5]: Copied! <pre># column and row stats\n\ndf = tribble(f.v1, f.v2, f.v3, *rnorm(15))\ndebug(\n    df,\n    col_sums(df),\n    row_sums(df),\n    col_means(df),\n    row_means(df),\n    col_sds(df),\n    row_sds(df),\n    col_medians(df),\n    row_medians(df),\n    **debug_kwargs,\n)\n</pre> # column and row stats  df = tribble(f.v1, f.v2, f.v3, *rnorm(15)) debug(     df,     col_sums(df),     row_sums(df),     col_means(df),     row_means(df),     col_sds(df),     row_sds(df),     col_medians(df),     row_medians(df),     **debug_kwargs, )  <pre>\ndf\n--------------------\n         v1        v2        v3\n  &lt;float64&gt; &lt;float64&gt; &lt;float64&gt;\n0  0.067273  0.015561 -0.633373\n1 -0.911285  1.526871  0.540873\n2  1.140124 -0.596385  1.933209\n3 -0.147867 -0.945199  0.994281\n4 -2.492679 -1.536482 -0.473660\n\ncol_sums(df)\n--------------------\nv1   -2.344435\nv2   -1.535634\nv3    2.361329\ndtype: float64\n\nrow_sums(df)\n--------------------\n0   -0.550539\n1    1.156458\n2    2.476947\n3   -0.098786\n4   -4.502821\ndtype: float64\n\ncol_means(df)\n--------------------\nv1   -0.468887\nv2   -0.307127\nv3    0.472266\ndtype: float64\n\nrow_means(df)\n--------------------\n0   -0.183513\n1    0.385486\n2    0.825649\n3   -0.032929\n4   -1.500940\ndtype: float64\n\ncol_sds(df)\n--------------------\nv1    1.348229\nv2    1.169380\nv3    1.064046\ndtype: float64\n\nrow_sds(df)\n--------------------\n0    0.390447\n1    1.226483\n2    1.293786\n3    0.974835\n4    1.009978\ndtype: float64\n\ncol_medians(df)\n--------------------\nv1   -0.147867\nv2   -0.596385\nv3    0.540873\ndtype: float64\n\nrow_medians(df)\n--------------------\n0    0.015561\n1    0.540873\n2    1.140124\n3   -0.147867\n4   -1.536482\ndtype: float64\n</pre> In\u00a0[6]: Copied! <pre>debug(\n    quantile([1, 2, 3, 4, 5]),\n    quantile([1, 2, 3, 4, 5], [0, 1]),\n    sd([1, 2, 3, 4, 5]),\n    weighted_mean([1, 2, 3, 4, 5]),\n    weighted_mean([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]),\n    **debug_kwargs,\n)\n</pre> debug(     quantile([1, 2, 3, 4, 5]),     quantile([1, 2, 3, 4, 5], [0, 1]),     sd([1, 2, 3, 4, 5]),     weighted_mean([1, 2, 3, 4, 5]),     weighted_mean([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]),     **debug_kwargs, ) <pre>\nquantile([1, 2, 3, 4, 5])\n--------------------\narray([1., 2., 3., 4., 5.])\n\nquantile([1, 2, 3, 4, 5], [0, 1])\n--------------------\narray([1, 5])\n\nsd([1, 2, 3, 4, 5])\n--------------------\n1.5811388300841898\n\nweighted_mean([1, 2, 3, 4, 5])\n--------------------\n3.0\n\nweighted_mean([1, 2, 3, 4, 5], [5, 4, 3, 2, 1])\n--------------------\n2.3333333333333335\n</pre>"},{"location":"notebooks/base-arithmetic/#sum_","title":"\u2605 sum_\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-sum-of-a-vector","title":"Compute the sum of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The sum of the vector</p>"},{"location":"notebooks/base-arithmetic/#prod","title":"\u2605 prod\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-product-of-a-vector","title":"Compute the product of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The product of the vector</p>"},{"location":"notebooks/base-arithmetic/#mean","title":"\u2605 mean\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-mean-of-a-vector","title":"Compute the mean of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The mean of the vector</p>"},{"location":"notebooks/base-arithmetic/#median","title":"\u2605 median\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-median-of-a-vector","title":"Compute the median of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The median of the vector</p>"},{"location":"notebooks/base-arithmetic/#min_","title":"\u2605 min_\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-minimum-of-a-vector","title":"Compute the minimum of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The minimum of the vector</p>"},{"location":"notebooks/base-arithmetic/#max_","title":"\u2605 max_\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-maximum-of-a-vector","title":"Compute the maximum of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The maximum of the vector</p>"},{"location":"notebooks/base-arithmetic/#var","title":"\u2605 var\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-variance-of-a-vector","title":"Compute the variance of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>y</code>: None or a vector, matrix or data frame with \u2003\u2003\u2003\u2003compatible dimensions to <code>x</code>.  The default is equivalent to <code>y = x</code></p> <p> <code>na_rm</code>: Whether to remove <code>NA</code> values <code>ddof</code>: The degrees of freedom</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The variance of the vector</p>"},{"location":"notebooks/base-arithmetic/#pmin","title":"\u2605 pmin\u00b6","text":""},{"location":"notebooks/base-arithmetic/#returns-the-regular-or-parallel-maxima-and-minima-of-the-input","title":"Returns the (regular or Parallel) maxima and minima of the input\u00b6","text":"<p>\u2003\u2003values.</p>"},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>more</code>: One or more values <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The minimum of the vector and the values</p>"},{"location":"notebooks/base-arithmetic/#pmax","title":"\u2605 pmax\u00b6","text":""},{"location":"notebooks/base-arithmetic/#returns-the-regular-or-parallel-maxima-and-minima-of-the-input","title":"Returns the (regular or Parallel) maxima and minima of the input\u00b6","text":"<p>\u2003\u2003values.</p>"},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>more</code>: One or more values <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The maximum of the vector and the values</p>"},{"location":"notebooks/base-arithmetic/#round_","title":"\u2605 round_\u00b6","text":""},{"location":"notebooks/base-arithmetic/#round-the-values-of-a-vector","title":"Round the values of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>digits</code>: The number of digits to round to</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The rounded values</p>"},{"location":"notebooks/base-arithmetic/#sqrt","title":"\u2605 sqrt\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-square-root-of-a-vector","title":"Compute the square root of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The square root of the vector</p>"},{"location":"notebooks/base-arithmetic/#abs_","title":"\u2605 abs_\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-absolute-value-of-a-vector","title":"Compute the absolute value of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The absolute values of the vector</p>"},{"location":"notebooks/base-arithmetic/#sign","title":"\u2605 sign\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-sign-of-a-vector","title":"Compute the sign of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The signs of the vector</p>"},{"location":"notebooks/base-arithmetic/#trunc","title":"\u2605 trunc\u00b6","text":""},{"location":"notebooks/base-arithmetic/#truncate-the-values-of-a-vector","title":"Truncate the values of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The truncated values</p>"},{"location":"notebooks/base-arithmetic/#ceiling","title":"\u2605 ceiling\u00b6","text":""},{"location":"notebooks/base-arithmetic/#round-up-to-the-nearest-integer","title":"Round up to the nearest integer\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: The value to be rounded up</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The rounded up value</p>"},{"location":"notebooks/base-arithmetic/#floor","title":"\u2605 floor\u00b6","text":""},{"location":"notebooks/base-arithmetic/#round-down-to-the-nearest-integer","title":"Round down to the nearest integer\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: The value to be rounded down</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The rounded down value</p>"},{"location":"notebooks/base-arithmetic/#signif","title":"\u2605 signif\u00b6","text":""},{"location":"notebooks/base-arithmetic/#round-the-values-of-a-vector-to-a-given-number-of-significant-digits","title":"Round the values of a vector to a given number of significant digits\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>digits</code>: The number of significant digits to round to</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The rounded values</p>"},{"location":"notebooks/base-arithmetic/#log","title":"\u2605 log\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-logarithm-of-a-vector","title":"Compute the logarithm of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>base</code>: The base of the logarithm</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The logarithm values</p>"},{"location":"notebooks/base-arithmetic/#exp","title":"\u2605 exp\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-exponential-of-a-vector","title":"Compute the exponential of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The exponential values</p>"},{"location":"notebooks/base-arithmetic/#log2","title":"\u2605 log2\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-base-2-logarithm-of-a-vector","title":"Compute the base-2 logarithm of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The logarithm values</p>"},{"location":"notebooks/base-arithmetic/#log10","title":"\u2605 log10\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-base-10-logarithm-of-a-vector","title":"Compute the base 10 logarithm of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The logarithm values</p>"},{"location":"notebooks/base-arithmetic/#log1p","title":"\u2605 log1p\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-logarithm-of-one-plus-a-vector","title":"Compute the logarithm of one plus a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The logarithm values</p>"},{"location":"notebooks/base-arithmetic/#cov","title":"\u2605 cov\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-pairwise-covariance-between-two-variables","title":"Compute pairwise covariance between two variables\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: a numeric vector, matrix or data frame. <code>y</code>: None or a vector, matrix or data frame with \u2003\u2003\u2003\u2003compatible dimensions to <code>x</code>.  The default is equivalent to <code>y = x</code></p> <p> <code>na_rm</code>: If <code>True</code>, remove missing values before computing \u2003\u2003\u2003\u2003the covariance.</p> <p> <code>ddof</code>: The denominator degrees of freedom.</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The covariance matrix</p>"},{"location":"notebooks/base-arithmetic/#scale","title":"\u2605 scale\u00b6","text":""},{"location":"notebooks/base-arithmetic/#center-andor-scale-the-data","title":"Center and/or scale the data\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>center</code>: Whether to center the data <code>scale_</code>: Whether to scale the data</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The scaled data</p>"},{"location":"notebooks/base-arithmetic/#col_sums","title":"\u2605 col_sums\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-column-sums-of-a-matrix","title":"Compute the column sums of a matrix\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric matrix <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The column sums of the matrix</p>"},{"location":"notebooks/base-arithmetic/#row_sums","title":"\u2605 row_sums\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-row-sums-of-a-matrix","title":"Compute the row sums of a matrix\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric matrix <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The row sums of the matrix</p>"},{"location":"notebooks/base-arithmetic/#col_means","title":"\u2605 col_means\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-column-means-of-a-matrix","title":"Compute the column means of a matrix\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric matrix <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The column means of the matrix</p>"},{"location":"notebooks/base-arithmetic/#row_means","title":"\u2605 row_means\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-row-means-of-a-matrix","title":"Compute the row means of a matrix\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric matrix <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The row means of the matrix</p>"},{"location":"notebooks/base-arithmetic/#col_sds","title":"\u2605 col_sds\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-column-standard-deviations-of-a-matrix","title":"Compute the column standard deviations of a matrix\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric matrix <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The column standard deviations of the matrix</p>"},{"location":"notebooks/base-arithmetic/#row_sds","title":"\u2605 row_sds\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-row-standard-deviations-of-a-matrix","title":"Compute the row standard deviations of a matrix\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric matrix <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The row standard deviations of the matrix</p>"},{"location":"notebooks/base-arithmetic/#col_medians","title":"\u2605 col_medians\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-column-medians-of-a-matrix","title":"Compute the column medians of a matrix\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric matrix <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The column medians of the matrix</p>"},{"location":"notebooks/base-arithmetic/#row_medians","title":"\u2605 row_medians\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-row-medians-of-a-matrix","title":"Compute the row medians of a matrix\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric matrix <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The row medians of the matrix</p>"},{"location":"notebooks/base-arithmetic/#quantile","title":"\u2605 quantile\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-quantiles-of-a-vector","title":"Compute the quantiles of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>probs</code>: The probabilities to use</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The quantiles of the vector</p>"},{"location":"notebooks/base-arithmetic/#sd","title":"\u2605 sd\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-standard-deviation-of-a-vector","title":"Compute the standard deviation of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The standard deviation of the vector</p>"},{"location":"notebooks/base-arithmetic/#weighted_mean","title":"\u2605 weighted_mean\u00b6","text":""},{"location":"notebooks/base-arithmetic/#compute-the-weighted-mean-of-a-vector","title":"Compute the weighted mean of a vector\u00b6","text":""},{"location":"notebooks/base-arithmetic/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>w</code>: The weights to use <code>na_rm</code>: Whether to remove <code>NA</code> values</p>"},{"location":"notebooks/base-arithmetic/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The weighted mean of the vector</p>"},{"location":"notebooks/base-funs/","title":"base-funs","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\n\nfrom datar.all import *\n\ndebug_kwargs = {'prefix': '\\n', 'sep': f'\\n{\"-\" * 20}\\n'}\nnb_header(\n    cut, diff, identity, expand_grid, outer, \n    make_names, make_unique, rank,\n)\n</pre> %run nb_helpers.py  from datar.all import *  debug_kwargs = {'prefix': '\\n', 'sep': f'\\n{\"-\" * 20}\\n'} nb_header(     cut, diff, identity, expand_grid, outer,      make_names, make_unique, rank, ) Try this notebook on binder. In\u00a0[2]: Copied! <pre>debug(\n    cut(seq(1,10), 3), \n    diff([1, 2, 3]),\n    identity(1.23),\n    expand_grid([1,2], [3,4]),\n    outer([1,2], [3,4]),\n    make_names([1, 2, 3]),\n    make_unique([1, 1, 1]),\n    rank([3, 4, 1, -1]),\n    **debug_kwargs\n)\n</pre> debug(     cut(seq(1,10), 3),      diff([1, 2, 3]),     identity(1.23),     expand_grid([1,2], [3,4]),     outer([1,2], [3,4]),     make_names([1, 2, 3]),     make_unique([1, 1, 1]),     rank([3, 4, 1, -1]),     **debug_kwargs ) <pre>[2022-12-02 13:26:45][datar][WARNING] New names:\n[2022-12-02 13:26:45][datar][WARNING] * '_1' -&gt; '__0'\n[2022-12-02 13:26:45][datar][WARNING] * '_2' -&gt; '__1'\n[2022-12-02 13:26:45][datar][WARNING] * '_3' -&gt; '__2'\n[2022-12-02 13:26:45][datar][WARNING] New names:\n[2022-12-02 13:26:45][datar][WARNING] * '_1' -&gt; '__0'\n[2022-12-02 13:26:45][datar][WARNING] * '_1' -&gt; '__1'\n[2022-12-02 13:26:45][datar][WARNING] * '_1' -&gt; '__2'\n</pre> <pre>\ncut(seq(1,10), 3)\n--------------------\n[(0.99, 4.0], (0.99, 4.0], (0.99, 4.0], (0.99, 4.0], (4.0, 7.0], (4.0, 7.0], (4.0, 7.0], (7.0, 10.0], (7.0, 10.0], (7.0, 10.0]]\nCategories (3, interval[float64, right]): [(0.99, 4.0] &lt; (4.0, 7.0] &lt; (7.0, 10.0]]\n\ndiff([1, 2, 3])\n--------------------\narray([1, 1])\n\nidentity(1.23)\n--------------------\n1.23\n\nexpand_grid([1,2], [3,4])\n--------------------\n   _VAR_0  _VAR_1\n  &lt;int64&gt; &lt;int64&gt;\n0       1       3\n1       1       4\n2       2       3\n3       2       4\n\nouter([1,2], [3,4])\n--------------------\n        0       1\n  &lt;int64&gt; &lt;int64&gt;\n0       3       4\n1       6       8\n\nmake_names([1, 2, 3])\n--------------------\n['__0', '__1', '__2']\n\nmake_unique([1, 1, 1])\n--------------------\n['__0', '__1', '__2']\n\nrank([3, 4, 1, -1])\n--------------------\narray([3., 4., 2., 1.])\n</pre>"},{"location":"notebooks/base-funs/#cut","title":"\u2605 cut\u00b6","text":""},{"location":"notebooks/base-funs/#cut-a-numeric-vector-into-bins","title":"Cut a numeric vector into bins\u00b6","text":""},{"location":"notebooks/base-funs/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>breaks</code>: The breaks <code>labels</code>: The labels <code>include_lowest</code>: Whether to include the lowest value <code>right</code>: Whether to include the rightmost value <code>dig_lab</code>: The number of digits for labels <code>ordered_result</code>: Whether to return an ordered factor</p>"},{"location":"notebooks/base-funs/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor vector</p>"},{"location":"notebooks/base-funs/#diff","title":"\u2605 diff\u00b6","text":""},{"location":"notebooks/base-funs/#difference-of-a-numeric-vector","title":"Difference of a numeric vector\u00b6","text":""},{"location":"notebooks/base-funs/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>lag</code>: The lag to use. Could be negative. \u2003\u2003\u2003\u2003It always calculates <code>x[lag:] - x[:-lag]</code> even when <code>lag</code> is \u2003\u2003\u2003\u2003negative</p> <p> <code>differences</code>: The order of the difference</p>"},{"location":"notebooks/base-funs/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003An array of <code>x[lag:] \u2013 x[:-lag]</code>. \u2003\u2003If <code>differences &gt; 1</code>, the rule applies <code>differences</code> times on <code>x</code></p>"},{"location":"notebooks/base-funs/#identity","title":"\u2605 identity\u00b6","text":""},{"location":"notebooks/base-funs/#identity-function","title":"Identity function\u00b6","text":""},{"location":"notebooks/base-funs/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector</p>"},{"location":"notebooks/base-funs/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The same vector</p>"},{"location":"notebooks/base-funs/#expand_grid","title":"\u2605 expand_grid\u00b6","text":""},{"location":"notebooks/base-funs/#expand-a-grid","title":"Expand a grid\u00b6","text":""},{"location":"notebooks/base-funs/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>*args</code>: Additional numeric vectors <code>**kwargs</code>: Additional keyword arguments</p>"},{"location":"notebooks/base-funs/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The expanded grid</p>"},{"location":"notebooks/base-funs/#outer","title":"\u2605 outer\u00b6","text":""},{"location":"notebooks/base-funs/#outer-product-of-two-vectors","title":"Outer product of two vectors\u00b6","text":""},{"location":"notebooks/base-funs/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>y</code>: A numeric vector <code>fun</code>: The function to handle how the result of the elements from \u2003\u2003\u2003\u2003the first and second vectors should be computed. \u2003\u2003\u2003\u2003The function has to be vectorized at the second argument, and \u2003\u2003\u2003\u2003return the same shape as y.</p>"},{"location":"notebooks/base-funs/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The outer product</p>"},{"location":"notebooks/base-funs/#make_names","title":"\u2605 make_names\u00b6","text":""},{"location":"notebooks/base-funs/#make-names-for-a-vector","title":"Make names for a vector\u00b6","text":""},{"location":"notebooks/base-funs/#args","title":"Args:\u00b6","text":"<p> <code>names</code>: character vector to be coerced to syntactically valid names. \u2003\u2003\u2003\u2003This is coerced to character if necessary.</p> <p> <code>unique</code>: Whether to make the names unique</p>"},{"location":"notebooks/base-funs/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The names</p>"},{"location":"notebooks/base-funs/#make_unique","title":"\u2605 make_unique\u00b6","text":""},{"location":"notebooks/base-funs/#make-a-vector-unique","title":"Make a vector unique\u00b6","text":""},{"location":"notebooks/base-funs/#args","title":"Args:\u00b6","text":"<p> <code>names</code>: a character vector</p>"},{"location":"notebooks/base-funs/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The unique vector</p>"},{"location":"notebooks/base-funs/#rank","title":"\u2605 rank\u00b6","text":""},{"location":"notebooks/base-funs/#rank-a-numeric-vector","title":"Rank a numeric vector\u00b6","text":""},{"location":"notebooks/base-funs/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>na_last</code>: Whether to put NA at the end <code>ties_method</code>: The method to handle ties. One of \"average\", \"first\", \u2003\u2003\u2003\u2003\"last\", \"random\", \"max\", \"min\"</p>"},{"location":"notebooks/base-funs/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The ranks</p>"},{"location":"notebooks/base/","title":"base","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\nimport numpy\nfrom datar import f\nfrom datar.base import *\nfrom datar.tibble import tibble\n\ndebug_kwargs = {'prefix': '\\n', 'sep': f'\\n{\"-\" * 20}\\n'}\n</pre> %run nb_helpers.py import numpy from datar import f from datar.base import * from datar.tibble import tibble  debug_kwargs = {'prefix': '\\n', 'sep': f'\\n{\"-\" * 20}\\n'} In\u00a0[2]: Copied! <pre># constants\ndebug(\n    pi,\n    Inf,\n    letters,\n    LETTERS,\n    month_abb,\n    month_name,\n    **debug_kwargs\n)\n</pre> # constants debug(     pi,     Inf,     letters,     LETTERS,     month_abb,     month_name,     **debug_kwargs ) <pre>\npi\n--------------------\n3.141592653589793\n\nInf\n--------------------\ninf\n\nletters\n--------------------\narray(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n       'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'],\n      dtype='&lt;U1')\n\nLETTERS\n--------------------\narray(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n       'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],\n      dtype='&lt;U1')\n\nmonth_abb\n--------------------\narray(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n       'Oct', 'Nov', 'Dec'], dtype='&lt;U3')\n\nmonth_name\n--------------------\narray(['January', 'February', 'March', 'April', 'May', 'June', 'July',\n       'August', 'September', 'October', 'November', 'December'],\n      dtype='&lt;U9')\n</pre> In\u00a0[5]: Copied! <pre># verbs\ndf = tibble(x=1, y=2, z=3)\n\ndebug(\n    colnames(df),\n    colnames(df, ['a', 'b', 'c']),\n    rownames(df),\n    set_rownames(df, ['row1']),\n    dim(df),\n    nrow(df),\n    ncol(df),\n    diag(1, 3),\n    diag(diag(1, 3)),\n    t(df),\n    intersect([1,2], [2,3]),\n    setdiff([1,2], [2,3]),\n    union([1,2], [2,3]),\n    setequal([1,2], [2,1]),\n    duplicated([1,1,2,2]),\n    duplicated([1,1,2,2], from_last=True),\n    **debug_kwargs\n)\n</pre> # verbs df = tibble(x=1, y=2, z=3)  debug(     colnames(df),     colnames(df, ['a', 'b', 'c']),     rownames(df),     set_rownames(df, ['row1']),     dim(df),     nrow(df),     ncol(df),     diag(1, 3),     diag(diag(1, 3)),     t(df),     intersect([1,2], [2,3]),     setdiff([1,2], [2,3]),     union([1,2], [2,3]),     setequal([1,2], [2,1]),     duplicated([1,1,2,2]),     duplicated([1,1,2,2], from_last=True),     **debug_kwargs ) <pre>\ncolnames(df)\n--------------------\narray(['x', 'y', 'z'], dtype=object)\n\ncolnames(df, ['a', 'b', 'c'])\n--------------------\narray(['x', 'y', 'z'], dtype=object)\n\nrownames(df)\n--------------------\narray([0])\n\nset_rownames(df, ['row1'])\n--------------------\n           x       y       z\n     &lt;int64&gt; &lt;int64&gt; &lt;int64&gt;\nrow1       1       2       3\n\ndim(df)\n--------------------\n(1, 3)\n\nnrow(df)\n--------------------\n1\n\nncol(df)\n--------------------\n3\n\ndiag(1, 3)\n--------------------\n        0       1       2\n  &lt;int64&gt; &lt;int64&gt; &lt;int64&gt;\n0       1       0       0\n1       0       1       0\n2       0       0       1\n\ndiag(diag(1, 3))\n--------------------\narray([1, 1, 1])\n\nt(df)\n--------------------\n        0\n  &lt;int64&gt;\nx       1\ny       2\nz       3\n\nintersect([1,2], [2,3])\n--------------------\narray([2])\n\nsetdiff([1,2], [2,3])\n--------------------\narray([1])\n\nunion([1,2], [2,3])\n--------------------\narray([1, 2, 3])\n\nsetequal([1,2], [2,1])\n--------------------\nTrue\n\nduplicated([1,1,2,2])\n--------------------\narray([False,  True, False,  True])\n\nduplicated([1,1,2,2], from_last=True)\n--------------------\narray([ True, False,  True, False])\n</pre> In\u00a0[6]: Copied! <pre># bessel\ndebug(\n    bessel_i([1,2,3], 1),\n    bessel_j([1,2,3], 1),\n    bessel_k([1,2,3], 1),\n    bessel_y([1,2,3], 1),\n    **debug_kwargs\n)\n</pre> # bessel debug(     bessel_i([1,2,3], 1),     bessel_j([1,2,3], 1),     bessel_k([1,2,3], 1),     bessel_y([1,2,3], 1),     **debug_kwargs ) <pre>\nbessel_i([1,2,3], 1)\n--------------------\narray([0.5651591 , 1.59063685, 3.95337022])\n\nbessel_j([1,2,3], 1)\n--------------------\narray([0.44005059, 0.57672481, 0.33905896])\n\nbessel_k([1,2,3], 1)\n--------------------\narray([0.60190723, 0.13986588, 0.04015643])\n\nbessel_y([1,2,3], 1)\n--------------------\narray([-0.78121282, -0.10703243,  0.32467442])\n</pre> In\u00a0[4]: Copied! <pre># casting\ndebug(\n    as_integer([1, 2.1]),\n    as_double(['1', 2, 'nan']),\n    as_numeric(['1', 2, 'nan']),\n    **debug_kwargs\n)\n</pre> # casting debug(     as_integer([1, 2.1]),     as_double(['1', 2, 'nan']),     as_numeric(['1', 2, 'nan']),     **debug_kwargs )  <pre>\nas_integer([1, 2.1])\n--------------------\narray([1, 2])\n\nas_double(['1', 2, 'nan'])\n--------------------\narray([ 1.,  2., nan])\n\nas_numeric(['1', 2, 'nan'])\n--------------------\narray([ 1.,  2., nan])\n</pre> In\u00a0[5]: Copied! <pre># complex numbers\ncm = 1 + 2j\ndebug(\n    im(cm),\n    re(cm),\n    mod(cm),\n    conj(cm),\n    is_complex(cm),\n    as_complex(1),\n    **debug_kwargs\n)\n</pre> # complex numbers cm = 1 + 2j debug(     im(cm),     re(cm),     mod(cm),     conj(cm),     is_complex(cm),     as_complex(1),     **debug_kwargs ) <pre>\nim(cm)\n--------------------\n2.0\n\nre(cm)\n--------------------\n1.0\n\nmod(cm)\n--------------------\n2.23606797749979\n\nconj(cm)\n--------------------\n(1-2j)\n\nis_complex(cm)\n--------------------\nTrue\n\nas_complex(1)\n--------------------\n(1+0j)\n</pre> In\u00a0[6]: Copied! <pre># cum stats\na = [1,3,2,4]\n\ndebug(\n    cumsum(a),\n    cumprod(a),\n    cummin(a),\n    cummax(a),\n    **debug_kwargs\n)\n</pre> # cum stats a = [1,3,2,4]  debug(     cumsum(a),     cumprod(a),     cummin(a),     cummax(a),     **debug_kwargs ) <pre>\ncumsum(a)\n--------------------\narray([ 1,  4,  6, 10])\n\ncumprod(a)\n--------------------\narray([ 1,  3,  6, 24])\n\ncummin(a)\n--------------------\narray([1, 1, 1, 1])\n\ncummax(a)\n--------------------\narray([1, 3, 3, 4])\n</pre> In\u00a0[9]: Copied! <pre># date\ndebug(\n    as_date([\"1jan1960\", \"2jan1960\", \"31mar1960\", \"30jul1960\"], format=\"%d%b%Y\"),\n    as_date([\"02/27/92\", \"02/27/92\", \"01/14/92\", \"02/28/92\", \"02/01/92\"], format=\"%m/%d/%y\"),\n    as_date(32768, origin=\"1900-01-01\"),\n    **debug_kwargs\n)\n</pre> # date debug(     as_date([\"1jan1960\", \"2jan1960\", \"31mar1960\", \"30jul1960\"], format=\"%d%b%Y\"),     as_date([\"02/27/92\", \"02/27/92\", \"01/14/92\", \"02/28/92\", \"02/01/92\"], format=\"%m/%d/%y\"),     as_date(32768, origin=\"1900-01-01\"),     **debug_kwargs ) <pre>\nas_date([\"1jan1960\", \"2jan1960\", \"31mar1960\", \"30jul1960\"], format=\"%d%b%Y\")\n--------------------\narray([datetime.date(1960, 1, 1), datetime.date(1960, 1, 2),\n       datetime.date(1960, 3, 31), datetime.date(1960, 7, 30)],\n      dtype=object)\n\nas_date([\"02/27/92\", \"02/27/92\", \"01/14/92\", \"02/28/92\", \"02/01/92\"], format=\"%m/%d/%y\")\n--------------------\narray([datetime.date(1992, 2, 27), datetime.date(1992, 2, 27),\n       datetime.date(1992, 1, 14), datetime.date(1992, 2, 28),\n       datetime.date(1992, 2, 1)], dtype=object)\n\nas_date(32768, origin=\"1900-01-01\")\n--------------------\ndatetime.date(1989, 9, 19)\n</pre> In\u00a0[10]: Copied! <pre># factor\nfct = factor([1,2,3], levels=[1,2,3,4])\ndebug(\n    levels(fct),\n    droplevels(fct),\n    is_factor(fct),\n    as_factor([1,2,3]),\n    **debug_kwargs\n)\n</pre> # factor fct = factor([1,2,3], levels=[1,2,3,4]) debug(     levels(fct),     droplevels(fct),     is_factor(fct),     as_factor([1,2,3]),     **debug_kwargs ) <pre>\nlevels(fct)\n--------------------\narray([1, 2, 3, 4])\n\ndroplevels(fct)\n--------------------\n[1, 2, 3]\nCategories (3, int64): [1, 2, 3]\n\nis_factor(fct)\n--------------------\nTrue\n\nas_factor([1,2,3])\n--------------------\n[1, 2, 3]\nCategories (3, int64): [1, 2, 3]\n</pre> In\u00a0[11]: Copied! <pre># logical\n\ndebug(\n    TRUE,\n    FALSE,\n    is_true(TRUE),\n    not is_true([TRUE, TRUE]),\n    is_false(FALSE),\n    is_logical(TRUE),\n    is_logical([TRUE, FALSE]),\n    as_logical([0, 1]),\n    **debug_kwargs\n)\n</pre> # logical  debug(     TRUE,     FALSE,     is_true(TRUE),     not is_true([TRUE, TRUE]),     is_false(FALSE),     is_logical(TRUE),     is_logical([TRUE, FALSE]),     as_logical([0, 1]),     **debug_kwargs ) <pre>\nTRUE\n--------------------\nTrue\n\nFALSE\n--------------------\nFalse\n\nis_true(TRUE)\n--------------------\nTrue\n\nnot is_true([TRUE, TRUE])\n--------------------\nTrue\n\nis_false(FALSE)\n--------------------\nTrue\n\nis_logical(TRUE)\n--------------------\nTrue\n\nis_logical([TRUE, FALSE])\n--------------------\nTrue\n\nas_logical([0, 1])\n--------------------\narray([False,  True])\n</pre> In\u00a0[12]: Copied! <pre># na\n\ndebug(\n    NA,\n    NaN,\n    NA is NaN,\n    type(NA),\n    is_na([NA, NaN, None]),\n    any_na([1,2, NA]),\n    numpy.array([1,2,NA]),\n    numpy.array(['a', 'b', NA]),\n    numpy.array(['a', 'b', None]),\n    **debug_kwargs\n)\n</pre> # na  debug(     NA,     NaN,     NA is NaN,     type(NA),     is_na([NA, NaN, None]),     any_na([1,2, NA]),     numpy.array([1,2,NA]),     numpy.array(['a', 'b', NA]),     numpy.array(['a', 'b', None]),     **debug_kwargs ) <pre>\nNA\n--------------------\nnan\n\nNaN\n--------------------\nnan\n\nNA is NaN\n--------------------\nTrue\n\ntype(NA)\n--------------------\n&lt;class 'float'&gt;\n\nis_na([NA, NaN, None])\n--------------------\narray([ True,  True,  True])\n\nany_na([1,2, NA])\n--------------------\nTrue\n\nnumpy.array([1,2,NA])\n--------------------\narray([ 1.,  2., nan])\n\nnumpy.array(['a', 'b', NA])\n--------------------\narray(['a', 'b', 'nan'], dtype='&lt;U32')\n\nnumpy.array(['a', 'b', None])\n--------------------\narray(['a', 'b', None], dtype=object)\n</pre> In\u00a0[13]: Copied! <pre># null\n\ndebug(\n    NULL,\n    NULL is None,\n    is_null(NA),\n    is_null(NULL),\n    as_null('whatever'),\n    **debug_kwargs\n)\n</pre> # null  debug(     NULL,     NULL is None,     is_null(NA),     is_null(NULL),     as_null('whatever'),     **debug_kwargs ) <pre>\nNULL\n--------------------\nNone\n\nNULL is None\n--------------------\nTrue\n\nis_null(NA)\n--------------------\nFalse\n\nis_null(NULL)\n--------------------\nTrue\n\nas_null('whatever')\n--------------------\nNone\n</pre> In\u00a0[14]: Copied! <pre># random\nset_seed(8525)\n\nsample(seq(1,100), 10) # always: [19, 61, 85, 93, 18,  5, 22,  7, 29, 26]\n</pre> # random set_seed(8525)  sample(seq(1,100), 10) # always: [19, 61, 85, 93, 18,  5, 22,  7, 29, 26] Out[14]: <pre>array([19, 61, 85, 93, 18,  5, 22,  7, 29, 26])</pre> In\u00a0[15]: Copied! <pre># seq\ndebug(\n    str(c(c(1,2), seq(3,4))),\n    seq_len(5),\n    seq_along([4,2,1]),\n    rev(seq_len(5)),\n    rep([1,2], 2),\n    rep([1,2], each=2),\n    length([1,2]),\n    length(\"abcd\"), # string is scalar\n    lengths(10),\n    lengths([[1], [1,2]]),\n    unique([3,3,2,4,4]), # order kept\n    **debug_kwargs\n)\n</pre> # seq debug(     str(c(c(1,2), seq(3,4))),     seq_len(5),     seq_along([4,2,1]),     rev(seq_len(5)),     rep([1,2], 2),     rep([1,2], each=2),     length([1,2]),     length(\"abcd\"), # string is scalar     lengths(10),     lengths([[1], [1,2]]),     unique([3,3,2,4,4]), # order kept     **debug_kwargs ) <pre>\nstr(c(c(1,2), seq(3,4)))\n--------------------\n'[1, 2, 3, 4]'\n\nseq_len(5)\n--------------------\narray([1, 2, 3, 4, 5])\n\nseq_along([4,2,1])\n--------------------\narray([1, 2, 3])\n\nrev(seq_len(5))\n--------------------\narray([5, 4, 3, 2, 1])\n\nrep([1,2], 2)\n--------------------\narray([1, 2, 1, 2])\n\nrep([1,2], each=2)\n--------------------\narray([1, 1, 2, 2])\n\nlength([1,2])\n--------------------\n2\n\nlength(\"abcd\")\n--------------------\n1\n\nlengths(10)\n--------------------\narray([1])\n\nlengths([[1], [1,2]])\n--------------------\narray([1, 2])\n\nunique([3,3,2,4,4])\n--------------------\narray([3, 2, 4])\n</pre> In\u00a0[16]: Copied! <pre># special\n\ndebug(\n    beta([1,2,3], 1),\n    lbeta([1,2,3], 1),\n    gamma([1,2,3]),\n    lgamma([1,2,3]),\n    digamma([1,2,3]),\n    trigamma([1,2,3]),\n    psigamma([1,2,3], 1),\n    choose([4,6], 2),\n    lchoose([4,6], 2),\n    factorial([1,5]),\n    lfactorial([1,5]),\n    **debug_kwargs\n)\n</pre> # special  debug(     beta([1,2,3], 1),     lbeta([1,2,3], 1),     gamma([1,2,3]),     lgamma([1,2,3]),     digamma([1,2,3]),     trigamma([1,2,3]),     psigamma([1,2,3], 1),     choose([4,6], 2),     lchoose([4,6], 2),     factorial([1,5]),     lfactorial([1,5]),     **debug_kwargs ) <pre>\nbeta([1,2,3], 1)\n--------------------\narray([1.        , 0.5       , 0.33333333])\n\nlbeta([1,2,3], 1)\n--------------------\narray([ 0.        , -0.69314718, -1.09861229])\n\ngamma([1,2,3])\n--------------------\narray([1., 1., 2.])\n\nlgamma([1,2,3])\n--------------------\narray([0.        , 0.        , 0.69314718])\n\ndigamma([1,2,3])\n--------------------\narray([-0.57721566,  0.42278434,  0.92278434])\n\ntrigamma([1,2,3])\n--------------------\narray([1.64493407, 0.64493407, 0.39493407])\n\npsigamma([1,2,3], 1)\n--------------------\narray([1.64493407, 0.64493407, 0.39493407])\n\nchoose([4,6], 2)\n--------------------\narray([ 6., 15.])\n\nlchoose([4,6], 2)\n--------------------\narray([1.79175947, 2.7080502 ])\n\nfactorial([1,5])\n--------------------\narray([  1., 120.])\n\nlfactorial([1,5])\n--------------------\narray([0.        , 4.78749174])\n</pre> In\u00a0[18]: Copied! <pre># string\n\ndebug(\n    is_character(\"a\"),\n    is_character([\"a\", \"b\"]),\n    as_character([1,2]),\n    grep(\".\", [\"ab\", \"c.d\"]),\n    grep(\".\", [\"ab\", \"c.d\"], fixed=True),\n    grepl(\".\", [\"ab\", \"c.d\"], fixed=True),\n    sub(\".\", \"x\", [\"ab\", \"c.d.e\"]),\n    sub(\".\", \"x\", [\"ab\", \"c.d.e\"], fixed=True),\n    gsub(\".\", \"x\", [\"ab\", \"c.d.e\"]),\n    gsub(\".\", \"x\", [\"ab\", \"c.d.e\"], fixed=True),\n    nchar('\\0'),\n    nchar('\\0', type_='width'),\n    nzchar([\"a\", \"\"]),\n    paste(\"a\", \"b\"),\n    paste([\"a\", \"c\"], [\"b\", \"d\"], sep=\".\"),\n    paste0([\"a\", \"c\"], [\"b\", \"d\"], collapse=\"; \"),\n    sprintf(\"%s, %d, %.3f\", pi, pi, pi),\n    substr(\"abcde\", 1, 3),\n    substring(\"abcde\", 1),\n    strsplit([\"a.b.c\", \"e.f\"], \".\", fixed=True),\n    **debug_kwargs\n)\n</pre> # string  debug(     is_character(\"a\"),     is_character([\"a\", \"b\"]),     as_character([1,2]),     grep(\".\", [\"ab\", \"c.d\"]),     grep(\".\", [\"ab\", \"c.d\"], fixed=True),     grepl(\".\", [\"ab\", \"c.d\"], fixed=True),     sub(\".\", \"x\", [\"ab\", \"c.d.e\"]),     sub(\".\", \"x\", [\"ab\", \"c.d.e\"], fixed=True),     gsub(\".\", \"x\", [\"ab\", \"c.d.e\"]),     gsub(\".\", \"x\", [\"ab\", \"c.d.e\"], fixed=True),     nchar('\\0'),     nchar('\\0', type_='width'),     nzchar([\"a\", \"\"]),     paste(\"a\", \"b\"),     paste([\"a\", \"c\"], [\"b\", \"d\"], sep=\".\"),     paste0([\"a\", \"c\"], [\"b\", \"d\"], collapse=\"; \"),     sprintf(\"%s, %d, %.3f\", pi, pi, pi),     substr(\"abcde\", 1, 3),     substring(\"abcde\", 1),     strsplit([\"a.b.c\", \"e.f\"], \".\", fixed=True),     **debug_kwargs ) <pre>\nis_character(\"a\")\n--------------------\nTrue\n\nis_character([\"a\", \"b\"])\n--------------------\nTrue\n\nas_character([1,2])\n--------------------\narray(['1', '2'], dtype='&lt;U21')\n\ngrep(\".\", [\"ab\", \"c.d\"])\n--------------------\narray([0, 1])\n\ngrep(\".\", [\"ab\", \"c.d\"], fixed=True)\n--------------------\narray([1])\n\ngrepl(\".\", [\"ab\", \"c.d\"], fixed=True)\n--------------------\narray([False,  True])\n\nsub(\".\", \"x\", [\"ab\", \"c.d.e\"])\n--------------------\narray(['xb', 'x.d.e'], dtype='&lt;U5')\n\nsub(\".\", \"x\", [\"ab\", \"c.d.e\"], fixed=True)\n--------------------\narray(['ab', 'cxd.e'], dtype='&lt;U5')\n\ngsub(\".\", \"x\", [\"ab\", \"c.d.e\"])\n--------------------\narray(['xx', 'xxxxx'], dtype='&lt;U5')\n\ngsub(\".\", \"x\", [\"ab\", \"c.d.e\"], fixed=True)\n--------------------\narray(['ab', 'cxdxe'], dtype='&lt;U5')\n\nnchar('\\0')\n--------------------\narray(0)\n\nnchar('\\0', type_='width')\n--------------------\narray(0)\n\nnzchar([\"a\", \"\"])\n--------------------\narray([ True, False])\n\npaste(\"a\", \"b\")\n--------------------\narray('a b', dtype=object)\n\npaste([\"a\", \"c\"], [\"b\", \"d\"], sep=\".\")\n--------------------\narray(['a.b', 'c.d'], dtype=object)\n\npaste0([\"a\", \"c\"], [\"b\", \"d\"], collapse=\"; \")\n--------------------\n'ab; cd'\n\nsprintf(\"%s, %d, %.3f\", pi, pi, pi)\n--------------------\narray('3.141592653589793, 3, 3.142', dtype='&lt;U27')\n\nsubstr(\"abcde\", 1, 3)\n--------------------\narray('bc', dtype='&lt;U2')\n\nsubstring(\"abcde\", 1)\n--------------------\narray('bcde', dtype='&lt;U4')\n\nstrsplit([\"a.b.c\", \"e.f\"], \".\", fixed=True)\n--------------------\narray([list(['a', 'b', 'c']), list(['e', 'f'])], dtype=object)\n</pre> In\u00a0[19]: Copied! <pre># table\n\ntable(rep(['a', 'b'], each=4))\n</pre> # table  table(rep(['a', 'b'], each=4)) Out[19]: a b &lt;int64&gt; &lt;int64&gt; count 4 4 In\u00a0[21]: Copied! <pre># testing\ndebug(\n    is_double(numpy.array([1,2])),\n    is_integer(numpy.array([1,2])),\n    is_numeric(numpy.array([1,2])),\n    is_double(numpy.array([1,2], dtype=numpy.double)),\n    is_atomic(\"abc\"),\n    is_element(1, [1,2]),\n    **debug_kwargs\n)\n</pre> # testing debug(     is_double(numpy.array([1,2])),     is_integer(numpy.array([1,2])),     is_numeric(numpy.array([1,2])),     is_double(numpy.array([1,2], dtype=numpy.double)),     is_atomic(\"abc\"),     is_element(1, [1,2]),     **debug_kwargs ) <pre>\nis_double(numpy.array([1,2]))\n--------------------\nFalse\n\nis_integer(numpy.array([1,2]))\n--------------------\nTrue\n\nis_numeric(numpy.array([1,2]))\n--------------------\nTrue\n\nis_double(numpy.array([1,2], dtype=numpy.double))\n--------------------\nTrue\n\nis_atomic(\"abc\")\n--------------------\nTrue\n\nis_element(1, [1,2])\n--------------------\narray(True)\n</pre> In\u00a0[22]: Copied! <pre># trig/hb\ndebug(\n    cos(.5),\n    sin(.5),\n    tan(.5),\n    acos(.5),\n    asin(.5),\n    atan2(.5, 1),\n    cospi(.5),\n    sinpi(.5),\n    tanpi(.5),\n    cosh(.5),\n    sinh(.5),\n    tanh(.5),\n    acosh(1),\n    asinh(.5),\n    atanh(.5),\n    **debug_kwargs\n)\n</pre> # trig/hb debug(     cos(.5),     sin(.5),     tan(.5),     acos(.5),     asin(.5),     atan2(.5, 1),     cospi(.5),     sinpi(.5),     tanpi(.5),     cosh(.5),     sinh(.5),     tanh(.5),     acosh(1),     asinh(.5),     atanh(.5),     **debug_kwargs ) <pre>\ncos(.5)\n--------------------\n0.8775825618903728\n\nsin(.5)\n--------------------\n0.479425538604203\n\ntan(.5)\n--------------------\n0.5463024898437905\n\nacos(.5)\n--------------------\n1.0471975511965979\n\nasin(.5)\n--------------------\n0.5235987755982989\n\natan2(.5, 1)\n--------------------\n0.4636476090008061\n\ncospi(.5)\n--------------------\n6.123233995736766e-17\n\nsinpi(.5)\n--------------------\n1.0\n\ntanpi(.5)\n--------------------\n1.633123935319537e+16\n\ncosh(.5)\n--------------------\n1.1276259652063807\n\nsinh(.5)\n--------------------\n0.5210953054937474\n\ntanh(.5)\n--------------------\n0.46211715726000974\n\nacosh(1)\n--------------------\n0.0\n\nasinh(.5)\n--------------------\n0.48121182505960347\n\natanh(.5)\n--------------------\n0.5493061443340548\n</pre> In\u00a0[23]: Copied! <pre># which\n\ndebug(\n    which([True, False, True]),\n    which_max([3,2,4,1]),\n    which_min([3,2,4,1]),\n    **debug_kwargs\n)\n</pre> # which  debug(     which([True, False, True]),     which_max([3,2,4,1]),     which_min([3,2,4,1]),     **debug_kwargs ) <pre>\nwhich([True, False, True])\n--------------------\narray([0, 2])\n\nwhich_max([3,2,4,1])\n--------------------\n2\n\nwhich_min([3,2,4,1])\n--------------------\n3\n</pre>"},{"location":"notebooks/between/","title":"between","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/between.html\n%run nb_helpers.py\n\nfrom datar.data import starwars\nfrom datar.all import *\n\nnb_header(between)\n</pre> # https://dplyr.tidyverse.org/reference/between.html %run nb_helpers.py  from datar.data import starwars from datar.all import *  nb_header(between) Try this notebook on binder. In\u00a0[2]: Copied! <pre>between(range(1, 13), 7, 9)\n</pre> between(range(1, 13), 7, 9) Out[2]: <pre>0     False\n1     False\n2     False\n3     False\n4     False\n5     False\n6      True\n7      True\n8      True\n9     False\n10    False\n11    False\ndtype: bool</pre> In\u00a0[3]: Copied! <pre>x = rnorm(100)\nx[between(x, -1, 1)]\n</pre> x = rnorm(100) x[between(x, -1, 1)] Out[3]: <pre>array([ 0.83452786,  0.10189189,  0.74650094,  0.47880049,  0.55936638,\n       -0.70022441,  0.43960076, -0.06383017,  0.28146185, -0.5502206 ,\n        0.21524796,  0.50479523,  0.60164882,  0.51928143, -0.01063673,\n        0.84926787,  0.2968923 , -0.91378905,  0.75111234, -0.00124731,\n        0.90624557, -0.80836519, -0.64955713,  0.06907295,  0.55666354,\n       -0.60156603, -0.18858712, -0.34637117,  0.75442128,  0.6532232 ,\n       -0.10773449,  0.39341492, -0.33727655,  0.16413264, -0.82122347,\n        0.85301267,  0.68354877, -0.39180811,  0.54156329, -0.87504542,\n       -0.59525048, -0.94089336, -0.22030511,  0.13365225, -0.35710286,\n        0.48904832, -0.58548603,  0.11360724, -0.14562895, -0.04248941,\n       -0.4088952 ,  0.20738685,  0.16683007, -0.78370598, -0.57202633,\n       -0.04414652,  0.10903364, -0.20484245,  0.03577897, -0.66212973,\n        0.15423302, -0.16953601,  0.9420302 , -0.91207817,  0.62976181])</pre> In\u00a0[4]: Copied! <pre>starwars &gt;&gt; filter(between(f.height, 100, 150))\n</pre> starwars &gt;&gt; filter(between(f.height, 100, 150)) Out[4]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 4 Leia Organa 150.0 49.0 brown light brown 19.0 female feminine Alderaan Human 26 Mon Mothma 150.0 NaN auburn fair blue 48.0 female feminine Chandrila Human 37 Watto 137.0 NaN black blue, grey yellow NaN male masculine Toydaria Toydarian 38 Sebulba 112.0 40.0 none grey, red orange NaN male masculine Malastare Dug 45 Gasgano 122.0 NaN none white, blue black NaN male masculine Troiken Xexto In\u00a0[5]: Copied! <pre>starwars &gt;&gt; filter(100 &lt;= f.height &lt;= 150) # not as expected\n</pre> starwars &gt;&gt; filter(100 &lt;= f.height &lt;= 150) # not as expected Out[5]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 2 R2-D2 96.0 32.0 NaN white, blue red 33.0 none masculine Naboo Droid 4 Leia Organa 150.0 49.0 brown light brown 19.0 female feminine Alderaan Human 7 R5-D4 97.0 32.0 NaN white, red red NaN none masculine Tatooine Droid 18 Yoda 66.0 17.0 white green brown 896.0 male masculine NaN Yoda's species 26 Mon Mothma 150.0 NaN auburn fair blue 48.0 female feminine Chandrila Human 28 Wicket Systri Warrick 88.0 20.0 brown brown brown 8.0 male masculine Endor Ewok 37 Watto 137.0 NaN black blue, grey yellow NaN male masculine Toydaria Toydarian 38 Sebulba 112.0 40.0 none grey, red orange NaN male masculine Malastare Dug 44 Dud Bolt 94.0 45.0 none blue, grey yellow NaN male masculine Vulpter Vulptereen 45 Gasgano 122.0 NaN none white, blue black NaN male masculine Troiken Xexto 71 Ratts Tyerell 79.0 15.0 none grey, blue unknown NaN male masculine Aleen Minor Aleena 72 R4-P17 96.0 NaN none silver, red red, blue NaN none feminine NaN Droid"},{"location":"notebooks/between/#between","title":"\u2605 between\u00b6","text":""},{"location":"notebooks/between/#check-if-a-value-is-between-two-other-values","title":"Check if a value is between two other values\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/between.html</p>"},{"location":"notebooks/between/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A value <code>left</code>: The left bound <code>right</code>: The right bound <code>inclusive</code>: Either <code>both</code>, <code>neither</code>, <code>left</code> or <code>right</code>. \u2003\u2003\u2003\u2003Include boundaries. Whether to set each bound as closed or open.</p>"},{"location":"notebooks/between/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A bool value if <code>x</code> is scalar, otherwise an array of boolean values \u2003\u2003Note that it will be always False when NA appears in x, left or right.</p>"},{"location":"notebooks/bind/","title":"bind","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/bind.html\n%run nb_helpers.py\n\nfrom datar.data import starwars\nfrom datar.all import *\n\nnb_header(bind_rows, bind_cols, book='bind')\n</pre> # https://dplyr.tidyverse.org/reference/bind.html %run nb_helpers.py  from datar.data import starwars from datar.all import *  nb_header(bind_rows, bind_cols, book='bind') Try this notebook on binder. In\u00a0[2]: Copied! <pre>one = starwars &gt;&gt; slice(c[:4])\ntwo = starwars &gt;&gt; slice(c[9:12])\n\none &gt;&gt; bind_rows(two)\n</pre> one = starwars &gt;&gt; slice(c[:4]) two = starwars &gt;&gt; slice(c[9:12])  one &gt;&gt; bind_rows(two) Out[2]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Luke Skywalker 172.0 77.0 blond fair blue 19.0 male masculine Tatooine Human 1 C-3PO 167.0 75.0 NaN gold yellow 112.0 none masculine Tatooine Droid 2 R2-D2 96.0 32.0 NaN white, blue red 33.0 none masculine Naboo Droid 3 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human 4 Obi-Wan Kenobi 182.0 77.0 auburn, white fair blue-gray 57.0 male masculine Stewjon Human 5 Anakin Skywalker 188.0 84.0 blond fair blue 41.9 male masculine Tatooine Human 6 Wilhuff Tarkin 180.0 NaN auburn, grey fair blue 64.0 male masculine Eriadu Human In\u00a0[3]: Copied! <pre>bind_rows([one, two])\n</pre> bind_rows([one, two]) Out[3]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Luke Skywalker 172.0 77.0 blond fair blue 19.0 male masculine Tatooine Human 1 C-3PO 167.0 75.0 NaN gold yellow 112.0 none masculine Tatooine Droid 2 R2-D2 96.0 32.0 NaN white, blue red 33.0 none masculine Naboo Droid 3 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human 4 Obi-Wan Kenobi 182.0 77.0 auburn, white fair blue-gray 57.0 male masculine Stewjon Human 5 Anakin Skywalker 188.0 84.0 blond fair blue 41.9 male masculine Tatooine Human 6 Wilhuff Tarkin 180.0 NaN auburn, grey fair blue 64.0 male masculine Eriadu Human In\u00a0[4]: Copied! <pre>bind_rows([one, two], [two, one])\n</pre> bind_rows([one, two], [two, one]) Out[4]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Luke Skywalker 172.0 77.0 blond fair blue 19.0 male masculine Tatooine Human 1 C-3PO 167.0 75.0 NaN gold yellow 112.0 none masculine Tatooine Droid 2 R2-D2 96.0 32.0 NaN white, blue red 33.0 none masculine Naboo Droid 3 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human 4 Obi-Wan Kenobi 182.0 77.0 auburn, white fair blue-gray 57.0 male masculine Stewjon Human 5 Anakin Skywalker 188.0 84.0 blond fair blue 41.9 male masculine Tatooine Human 6 Wilhuff Tarkin 180.0 NaN auburn, grey fair blue 64.0 male masculine Eriadu Human 7 Obi-Wan Kenobi 182.0 77.0 auburn, white fair blue-gray 57.0 male masculine Stewjon Human 8 Anakin Skywalker 188.0 84.0 blond fair blue 41.9 male masculine Tatooine Human 9 Wilhuff Tarkin 180.0 NaN auburn, grey fair blue 64.0 male masculine Eriadu Human 10 Luke Skywalker 172.0 77.0 blond fair blue 19.0 male masculine Tatooine Human 11 C-3PO 167.0 75.0 NaN gold yellow 112.0 none masculine Tatooine Droid 12 R2-D2 96.0 32.0 NaN white, blue red 33.0 none masculine Naboo Droid 13 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human In\u00a0[5]: Copied! <pre>tibble(a=1, b=2) &gt;&gt; bind_rows(tibble(a=3, b=4))\n</pre> tibble(a=1, b=2) &gt;&gt; bind_rows(tibble(a=3, b=4)) Out[5]: a b &lt;int64&gt; &lt;int64&gt; 0 1 2 1 3 4 In\u00a0[6]: Copied! <pre>tibble(a=1, b=2) &gt;&gt; bind_rows(\n    tibble(a=[3, 4], b=[5, 6]),\n    tibble(a=7, b=8)\n)\n</pre> tibble(a=1, b=2) &gt;&gt; bind_rows(     tibble(a=[3, 4], b=[5, 6]),     tibble(a=7, b=8) ) Out[6]: a b &lt;int64&gt; &lt;int64&gt; 0 1 2 1 3 5 2 4 6 3 7 8 In\u00a0[7]: Copied! <pre>bind_rows([one, two], _id = \"id\")\n</pre> bind_rows([one, two], _id = \"id\") Out[7]: id name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 0 Luke Skywalker 172.0 77.0 blond fair blue 19.0 male masculine Tatooine Human 1 0 C-3PO 167.0 75.0 NaN gold yellow 112.0 none masculine Tatooine Droid 2 0 R2-D2 96.0 32.0 NaN white, blue red 33.0 none masculine Naboo Droid 3 0 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human 4 1 Obi-Wan Kenobi 182.0 77.0 auburn, white fair blue-gray 57.0 male masculine Stewjon Human 5 1 Anakin Skywalker 188.0 84.0 blond fair blue 41.9 male masculine Tatooine Human 6 1 Wilhuff Tarkin 180.0 NaN auburn, grey fair blue 64.0 male masculine Eriadu Human In\u00a0[9]: Copied! <pre># If we need a name for one\nbind_rows(a=one, b=two, _id = \"id\")\n</pre> # If we need a name for one bind_rows(a=one, b=two, _id = \"id\") Out[9]: id name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 a Luke Skywalker 172.0 77.0 blond fair blue 19.0 male masculine Tatooine Human 1 a C-3PO 167.0 75.0 NaN gold yellow 112.0 none masculine Tatooine Droid 2 a R2-D2 96.0 32.0 NaN white, blue red 33.0 none masculine Naboo Droid 3 a Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human 4 b Obi-Wan Kenobi 182.0 77.0 auburn, white fair blue-gray 57.0 male masculine Stewjon Human 5 b Anakin Skywalker 188.0 84.0 blond fair blue 41.9 male masculine Tatooine Human 6 b Wilhuff Tarkin 180.0 NaN auburn, grey fair blue 64.0 male masculine Eriadu Human In\u00a0[10]: Copied! <pre>bind_rows(**{\"group 1\": one, \"group 2\": two}, _id = \"groups\")\n</pre> bind_rows(**{\"group 1\": one, \"group 2\": two}, _id = \"groups\") Out[10]: groups name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 group 1 Luke Skywalker 172.0 77.0 blond fair blue 19.0 male masculine Tatooine Human 1 group 1 C-3PO 167.0 75.0 NaN gold yellow 112.0 none masculine Tatooine Droid 2 group 1 R2-D2 96.0 32.0 NaN white, blue red 33.0 none masculine Naboo Droid 3 group 1 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human 4 group 2 Obi-Wan Kenobi 182.0 77.0 auburn, white fair blue-gray 57.0 male masculine Stewjon Human 5 group 2 Anakin Skywalker 188.0 84.0 blond fair blue 41.9 male masculine Tatooine Human 6 group 2 Wilhuff Tarkin 180.0 NaN auburn, grey fair blue 64.0 male masculine Eriadu Human In\u00a0[11]: Copied! <pre>tibble(x=range(3)) &gt;&gt; bind_rows(\n    tibble(y=range(4))\n)\n</pre> tibble(x=range(3)) &gt;&gt; bind_rows(     tibble(y=range(4)) ) Out[11]: x y &lt;float64&gt; &lt;float64&gt; 0 0.0 NaN 1 1.0 NaN 2 2.0 NaN 3 NaN 0.0 4 NaN 1.0 5 NaN 2.0 6 NaN 3.0 In\u00a0[12]: Copied! <pre># NAs filled for missed rows\ntibble(x=range(3)) &gt;&gt; bind_cols(\n    tibble(y=range(2))\n)\n</pre> # NAs filled for missed rows tibble(x=range(3)) &gt;&gt; bind_cols(     tibble(y=range(2)) ) Out[12]: x y &lt;int64&gt; &lt;float64&gt; 0 0 0.0 1 1 1.0 2 2 NaN In\u00a0[13]: Copied! <pre>tibble(x = range(3)) &gt;&gt; bind_cols(tibble())\n</pre> tibble(x = range(3)) &gt;&gt; bind_cols(tibble()) Out[13]: x &lt;int64&gt; 0 0 1 1 2 2 In\u00a0[14]: Copied! <pre>one &gt;&gt; bind_cols(two)\n</pre> one &gt;&gt; bind_cols(two) <pre>[2022-12-02 13:42:54][datar][WARNING] New names:\n[2022-12-02 13:42:54][datar][WARNING] * 'name' -&gt; 'name__0'\n[2022-12-02 13:42:54][datar][WARNING] * 'height' -&gt; 'height__1'\n[2022-12-02 13:42:54][datar][WARNING] * 'mass' -&gt; 'mass__2'\n[2022-12-02 13:42:54][datar][WARNING] * 'hair_color' -&gt; 'hair_color__3'\n[2022-12-02 13:42:54][datar][WARNING] * 'skin_color' -&gt; 'skin_color__4'\n[2022-12-02 13:42:54][datar][WARNING] * 'eye_color' -&gt; 'eye_color__5'\n[2022-12-02 13:42:54][datar][WARNING] * 'birth_year' -&gt; 'birth_year__6'\n[2022-12-02 13:42:54][datar][WARNING] * 'sex' -&gt; 'sex__7'\n[2022-12-02 13:42:54][datar][WARNING] * 'gender' -&gt; 'gender__8'\n[2022-12-02 13:42:54][datar][WARNING] * 'homeworld' -&gt; 'homeworld__9'\n[2022-12-02 13:42:54][datar][WARNING] * 'species' -&gt; 'species__10'\n[2022-12-02 13:42:54][datar][WARNING] * 'name' -&gt; 'name__11'\n[2022-12-02 13:42:54][datar][WARNING] * 'height' -&gt; 'height__12'\n[2022-12-02 13:42:54][datar][WARNING] * 'mass' -&gt; 'mass__13'\n[2022-12-02 13:42:54][datar][WARNING] * 'hair_color' -&gt; 'hair_color__14'\n[2022-12-02 13:42:54][datar][WARNING] * 'skin_color' -&gt; 'skin_color__15'\n[2022-12-02 13:42:54][datar][WARNING] * 'eye_color' -&gt; 'eye_color__16'\n[2022-12-02 13:42:54][datar][WARNING] * 'birth_year' -&gt; 'birth_year__17'\n[2022-12-02 13:42:54][datar][WARNING] * 'sex' -&gt; 'sex__18'\n[2022-12-02 13:42:54][datar][WARNING] * 'gender' -&gt; 'gender__19'\n[2022-12-02 13:42:54][datar][WARNING] * 'homeworld' -&gt; 'homeworld__20'\n[2022-12-02 13:42:54][datar][WARNING] * 'species' -&gt; 'species__21'\n</pre> Out[14]: name__0 height__1 mass__2 hair_color__3 skin_color__4 eye_color__5 birth_year__6 sex__7 gender__8 homeworld__9 ... height__12 mass__13 hair_color__14 skin_color__15 eye_color__16 birth_year__17 sex__18 gender__19 homeworld__20 species__21 &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; ... &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Luke Skywalker 172.0 77.0 blond fair blue 19.0 male masculine Tatooine ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 1 C-3PO 167.0 75.0 NaN gold yellow 112.0 none masculine Tatooine ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 2 R2-D2 96.0 32.0 NaN white, blue red 33.0 none masculine Naboo ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 3 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 9 NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN ... 182.0 77.0 auburn, white fair blue-gray 57.0 male masculine Stewjon Human 10 NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN ... 188.0 84.0 blond fair blue 41.9 male masculine Tatooine Human 11 NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN ... 180.0 NaN auburn, grey fair blue 64.0 male masculine Eriadu Human <p>7 rows \u00d7 22 columns</p>"},{"location":"notebooks/bind/#bind_rows","title":"\u2605 bind_rows\u00b6","text":""},{"location":"notebooks/bind/#bind-rows-of-give-dataframes","title":"Bind rows of give dataframes\u00b6","text":"<p>Original APIs https://dplyr.tidyverse.org/reference/bind.html</p>"},{"location":"notebooks/bind/#args","title":"Args:\u00b6","text":"<p> <code>*data</code>: Dataframes to combine <code>_id</code>: The name of the id columns <code>_copy</code>: If <code>False</code>, do not copy data unnecessarily. \u2003\u2003\u2003\u2003Original API does not support this. This argument will be \u2003\u2003\u2003\u2003passed by to <code>pandas.concat()</code> as <code>copy</code> argument.</p> <p> <code>**kwargs</code>: A mapping of dataframe, keys will be used as _id col.</p>"},{"location":"notebooks/bind/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The combined dataframe</p>"},{"location":"notebooks/bind/#bind_cols","title":"\u2605 bind_cols\u00b6","text":""},{"location":"notebooks/bind/#bind-columns-of-give-dataframes","title":"Bind columns of give dataframes\u00b6","text":"<p>Note that unlike <code>dplyr</code>, mismatched dimensions are allowed and missing rows will be filled with <code>NA</code>s</p>"},{"location":"notebooks/bind/#args","title":"Args:\u00b6","text":"<p> <code>*data</code>: Dataframes to bind <code>_name_repair</code>: treatment of problematic column names: \u2003\u2003\u2003\u2003- \"minimal\": No name repair or checks, beyond basic existence,</p> <p>\u2003\u2003\u2003\u2003- \"unique\": Make sure names are unique and not empty,</p> <p>\u2003\u2003\u2003\u2003- \"check_unique\": (default value), no name repair, \u2003\u2003\u2003\u2003\u2003\u2003but check they are unique,</p> <p>\u2003\u2003\u2003\u2003- \"universal\": Make the names unique and syntactic</p> <p>\u2003\u2003\u2003\u2003- a function: apply custom name repair</p> <p> <code>_copy</code>: If <code>False</code>, do not copy data unnecessarily. \u2003\u2003\u2003\u2003Original API does not support this. This argument will be \u2003\u2003\u2003\u2003passed by to <code>pandas.concat()</code> as <code>copy</code> argument.</p>"},{"location":"notebooks/bind/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The combined dataframe</p>"},{"location":"notebooks/case_when/","title":"case_when","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/case_when.html\n%run nb_helpers.py\n\nfrom datar.data import starwars \nfrom datar.all import *\n\nnb_header(case_when)\n</pre> # https://dplyr.tidyverse.org/reference/case_when.html %run nb_helpers.py  from datar.data import starwars  from datar.all import *  nb_header(case_when) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x=range(1,51))\ndf &gt;&gt; mutate(y=case_when(\n    f.x % 35 == 0, \"fizz buzz\",\n    f.x % 5 == 0,  \"fizz\",\n    f.x % 7 == 0,  \"buzz\",\n    True,          as_character(f.x)\n)) &gt;&gt; pull(f.y, to=\"array\")\n</pre> df = tibble(x=range(1,51)) df &gt;&gt; mutate(y=case_when(     f.x % 35 == 0, \"fizz buzz\",     f.x % 5 == 0,  \"fizz\",     f.x % 7 == 0,  \"buzz\",     True,          as_character(f.x) )) &gt;&gt; pull(f.y, to=\"array\") Out[2]: <pre>array(['1', '2', '3', '4', 'fizz', '6', 'buzz', '8', '9', 'fizz', '11',\n       '12', '13', 'buzz', 'fizz', '16', '17', '18', '19', 'fizz', 'buzz',\n       '22', '23', '24', 'fizz', '26', '27', 'buzz', '29', 'fizz', '31',\n       '32', '33', '34', 'fizz buzz', '36', '37', '38', '39', 'fizz',\n       '41', 'buzz', '43', '44', 'fizz', '46', '47', '48', 'buzz', 'fizz'],\n      dtype=object)</pre> In\u00a0[3]: Copied! <pre>df &gt;&gt; mutate(y=case_when(\n    True,          as_character(f.x),\n    f.x % 5 == 0,  \"fizz\",\n    f.x % 7 == 0,  \"buzz\",\n    f.x % 35 == 0, \"fizz buzz\"\n)) &gt;&gt; pull(f.y, to=\"array\")\n</pre> df &gt;&gt; mutate(y=case_when(     True,          as_character(f.x),     f.x % 5 == 0,  \"fizz\",     f.x % 7 == 0,  \"buzz\",     f.x % 35 == 0, \"fizz buzz\" )) &gt;&gt; pull(f.y, to=\"array\") Out[3]: <pre>array(['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12',\n       '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23',\n       '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34',\n       '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45',\n       '46', '47', '48', '49', '50'], dtype=object)</pre> In\u00a0[4]: Copied! <pre>df &gt;&gt; mutate(y=case_when(\n    f.x % 5 == 0,  \"fizz\",\n    f.x % 7 == 0,  \"buzz\",\n    f.x % 35 == 0, \"fizz buzz\"\n)) &gt;&gt; pull(f.y, to=\"array\")\n</pre> df &gt;&gt; mutate(y=case_when(     f.x % 5 == 0,  \"fizz\",     f.x % 7 == 0,  \"buzz\",     f.x % 35 == 0, \"fizz buzz\" )) &gt;&gt; pull(f.y, to=\"array\") Out[4]: <pre>array([nan, nan, nan, nan, 'fizz', nan, 'buzz', nan, nan, 'fizz', nan,\n       nan, nan, 'buzz', 'fizz', nan, nan, nan, nan, 'fizz', 'buzz', nan,\n       nan, nan, 'fizz', nan, nan, 'buzz', nan, 'fizz', nan, nan, nan,\n       nan, 'fizz', nan, nan, nan, nan, 'fizz', nan, 'buzz', nan, nan,\n       'fizz', nan, nan, nan, 'buzz', 'fizz'], dtype=object)</pre> In\u00a0[5]: Copied! <pre>df.iloc[[1,2,3], 0] = NA\n\ndf &gt;&gt; mutate(y=case_when(\n    f.x % 35 == 0, \"fizz buzz\",\n    f.x % 5 == 0,  \"fizz\",\n    f.x % 7 == 0,  \"buzz\",\n    is_na(f.x),    \"nope\",\n    True,          as_character(f.x)\n)) &gt;&gt; pull(f.y, to=\"array\")\n</pre> df.iloc[[1,2,3], 0] = NA  df &gt;&gt; mutate(y=case_when(     f.x % 35 == 0, \"fizz buzz\",     f.x % 5 == 0,  \"fizz\",     f.x % 7 == 0,  \"buzz\",     is_na(f.x),    \"nope\",     True,          as_character(f.x) )) &gt;&gt; pull(f.y, to=\"array\") Out[5]: <pre>array(['1.0', 'nope', 'nope', 'nope', 'fizz', '6.0', 'buzz', '8.0', '9.0',\n       'fizz', '11.0', '12.0', '13.0', 'buzz', 'fizz', '16.0', '17.0',\n       '18.0', '19.0', 'fizz', 'buzz', '22.0', '23.0', '24.0', 'fizz',\n       '26.0', '27.0', 'buzz', '29.0', 'fizz', '31.0', '32.0', '33.0',\n       '34.0', 'fizz buzz', '36.0', '37.0', '38.0', '39.0', 'fizz',\n       '41.0', 'buzz', '43.0', '44.0', 'fizz', '46.0', '47.0', '48.0',\n       'buzz', 'fizz'], dtype=object)</pre> In\u00a0[6]: Copied! <pre>df &gt;&gt; mutate(y=case_when(\n    f.x % 35 == 0, NA,\n    f.x % 5 == 0,  \"fizz\",\n    f.x % 7 == 0,  \"buzz\",\n    True,          as_character(f.x)\n)) &gt;&gt; pull(f.y, to=\"array\")\n</pre> df &gt;&gt; mutate(y=case_when(     f.x % 35 == 0, NA,     f.x % 5 == 0,  \"fizz\",     f.x % 7 == 0,  \"buzz\",     True,          as_character(f.x) )) &gt;&gt; pull(f.y, to=\"array\") Out[6]: <pre>array(['1.0', 'nan', 'nan', 'nan', 'fizz', '6.0', 'buzz', '8.0', '9.0',\n       'fizz', '11.0', '12.0', '13.0', 'buzz', 'fizz', '16.0', '17.0',\n       '18.0', '19.0', 'fizz', 'buzz', '22.0', '23.0', '24.0', 'fizz',\n       '26.0', '27.0', 'buzz', '29.0', 'fizz', '31.0', '32.0', '33.0',\n       '34.0', nan, '36.0', '37.0', '38.0', '39.0', 'fizz', '41.0',\n       'buzz', '43.0', '44.0', 'fizz', '46.0', '47.0', '48.0', 'buzz',\n       'fizz'], dtype=object)</pre> In\u00a0[7]: Copied! <pre>df &gt;&gt; mutate(y=case_when(\n    f.x % 35 == 0, 35,\n    f.x % 5 == 0,  5,\n    f.x % 7 == 0,  7,\n    True,          NA)\n) &gt;&gt; pull(f.y, to=\"array\")\n</pre> df &gt;&gt; mutate(y=case_when(     f.x % 35 == 0, 35,     f.x % 5 == 0,  5,     f.x % 7 == 0,  7,     True,          NA) ) &gt;&gt; pull(f.y, to=\"array\") Out[7]: <pre>array([nan, nan, nan, nan,  5., nan,  7., nan, nan,  5., nan, nan, nan,\n        7.,  5., nan, nan, nan, nan,  5.,  7., nan, nan, nan,  5., nan,\n       nan,  7., nan,  5., nan, nan, nan, nan, 35., nan, nan, nan, nan,\n        5., nan,  7., nan, nan,  5., nan, nan, nan,  7.,  5.])</pre> In\u00a0[8]: Copied! <pre>df = tibble(x=seq(-2, 2.1, by=.5))\ndf &gt;&gt; mutate(y=case_when(\n    f.x &gt;= 0, sqrt(f.x),\n    True,     f.x\n)) &gt;&gt; pull(f.y, to=\"array\")\n</pre> df = tibble(x=seq(-2, 2.1, by=.5)) df &gt;&gt; mutate(y=case_when(     f.x &gt;= 0, sqrt(f.x),     True,     f.x )) &gt;&gt; pull(f.y, to=\"array\") <pre>RuntimeWarning: invalid value encountered in sqrt\n</pre> Out[8]: <pre>array([-2.        , -1.5       , -1.        , -0.5       ,  0.        ,\n        0.70710678,  1.        ,  1.22474487,  1.41421356])</pre> In\u00a0[9]: Copied! <pre>starwars &gt;&gt; \\\n  select(f[f.name:f.hair_color], f.gender, f.species) &gt;&gt; \\\n  mutate(\n    type = case_when(\n      (f.height &gt; 200) | (f.mass &gt; 200), \"large\",\n      f.species == \"Droid\"          , \"robot\",\n      True                          , \"other\"\n    )\n  )\n</pre> starwars &gt;&gt; \\   select(f[f.name:f.hair_color], f.gender, f.species) &gt;&gt; \\   mutate(     type = case_when(       (f.height &gt; 200) | (f.mass &gt; 200), \"large\",       f.species == \"Droid\"          , \"robot\",       True                          , \"other\"     )   ) Out[9]: name height mass gender species type &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Luke Skywalker 172.0 77.0 masculine Human other 1 C-3PO 167.0 75.0 masculine Droid robot 2 R2-D2 96.0 32.0 masculine Droid robot 3 Darth Vader 202.0 136.0 masculine Human large ... ... ... ... ... ... ... 4 Leia Organa 150.0 49.0 feminine Human other 82 Rey NaN NaN feminine Human other 83 Poe Dameron NaN NaN masculine Human other 84 BB8 NaN NaN masculine Droid robot 85 Captain Phasma NaN NaN NaN NaN other 86 Padm\u00e9 Amidala 165.0 45.0 feminine Human other <p>87 rows \u00d7 6 columns</p> In\u00a0[10]: Copied! <pre>starwars &gt;&gt; \\\n  mutate(type=case_when(\n    (f.height &gt; 200) | (f.mass &gt; 200), \"large\",\n    f.species == \"Droid\",           \"robot\",\n    True,                           \"other\"\n  )) &gt;&gt; \\\n  pull(f.type, to=\"array\")\n</pre> starwars &gt;&gt; \\   mutate(type=case_when(     (f.height &gt; 200) | (f.mass &gt; 200), \"large\",     f.species == \"Droid\",           \"robot\",     True,                           \"other\"   )) &gt;&gt; \\   pull(f.type, to=\"array\") Out[10]: <pre>array(['other', 'robot', 'robot', 'large', 'other', 'other', 'other',\n       'robot', 'other', 'other', 'other', 'other', 'large', 'other',\n       'other', 'large', 'other', 'other', 'other', 'other', 'other',\n       'robot', 'other', 'other', 'other', 'other', 'other', 'other',\n       'other', 'other', 'other', 'other', 'other', 'other', 'large',\n       'large', 'other', 'other', 'other', 'other', 'other', 'other',\n       'other', 'other', 'other', 'other', 'other', 'other', 'other',\n       'other', 'other', 'other', 'other', 'large', 'other', 'other',\n       'other', 'other', 'other', 'other', 'other', 'other', 'other',\n       'other', 'other', 'other', 'other', 'other', 'large', 'large',\n       'other', 'other', 'robot', 'other', 'other', 'other', 'large',\n       'large', 'other', 'other', 'large', 'other', 'other', 'other',\n       'robot', 'other', 'other'], dtype=object)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/case_when/#case_when","title":"\u2605 case_when\u00b6","text":""},{"location":"notebooks/case_when/#vectorise-multiple-if_else-statements","title":"Vectorise multiple <code>if_else()</code> statements.\u00b6","text":""},{"location":"notebooks/case_when/#args","title":"Args:\u00b6","text":"<p> <code>cond</code>: A boolean vector <code>value</code>: A vector with values to replace <code>*more_cases</code>: A list of tuples (cond, value)</p>"},{"location":"notebooks/case_when/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A vector with values replaced.</p>"},{"location":"notebooks/chop/","title":"chop","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\nfrom datar.all import *\n\nnb_header(chop, unchop)\n</pre> %run nb_helpers.py from datar.all import *  nb_header(chop, unchop) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x = c(1, 1, 1, 2, 2, 3), y = c[1:6:1], z = c[6:1:-1])\ndf &gt;&gt; nest(data = c(f.y, f.z))\n</pre> df = tibble(x = c(1, 1, 1, 2, 2, 3), y = c[1:6:1], z = c[6:1:-1]) df &gt;&gt; nest(data = c(f.y, f.z))  Out[2]: x data &lt;int64&gt; &lt;object&gt; 0 1 &lt;DF 3x2&gt; 1 2 &lt;DF 2x2&gt; 2 3 &lt;DF 1x2&gt; In\u00a0[3]: Copied! <pre>df &gt;&gt; chop(c(f.y, f.z))\n</pre> df &gt;&gt; chop(c(f.y, f.z)) Out[3]: x y z &lt;int64&gt; &lt;object&gt; &lt;object&gt; 0 1 [1, 2, 3] [6, 5, 4] 1 2 [4, 5] [3, 2] 2 3 [6] [1] In\u00a0[4]: Copied! <pre># Unchop\ndf = tibble(x = c[1:5], y = [[], [1], [1,2], [1,2,3]])\ndf &gt;&gt; unchop(f.y)\n</pre> # Unchop df = tibble(x = c[1:5], y = [[], [1], [1,2], [1,2,3]]) df &gt;&gt; unchop(f.y) Out[4]: x y &lt;int64&gt; &lt;object&gt; 0 2 1.0 1 3 1.0 2 3 2.0 3 4 1.0 4 4 2.0 5 4 3.0 In\u00a0[5]: Copied! <pre>df &gt;&gt; unchop(f.y, keep_empty=True, dtypes=int)\n</pre> df &gt;&gt; unchop(f.y, keep_empty=True, dtypes=int) Out[5]: x y &lt;int64&gt; &lt;int64&gt; 0 2 1 1 3 1 2 3 2 3 4 1 4 4 2 5 4 3 In\u00a0[6]: Copied! <pre>df = tibble(x = c[1:2], y = [\"a\", [1,2,3]])\ndf &gt;&gt; unchop(f.y)\n</pre> df = tibble(x = c[1:2], y = [\"a\", [1,2,3]]) df &gt;&gt; unchop(f.y) Out[6]: x y &lt;int64&gt; &lt;object&gt; 0 1 a 1 1 1 2 1 2 3 1 3 In\u00a0[7]: Copied! <pre>with try_catch():\n    df &gt;&gt; unchop(f.y, dtypes=int)\n</pre> with try_catch():     df &gt;&gt; unchop(f.y, dtypes=int) <pre>[ValueError] invalid literal for int() with base 10: 'a'\n</pre> In\u00a0[8]: Copied! <pre>df = tibble(x = c[1:4], y = [NULL, tibble(x = 1), tibble(y = c[1:3])])\ndf &gt;&gt; unchop(f.y)\n</pre> df = tibble(x = c[1:4], y = [NULL, tibble(x = 1), tibble(y = c[1:3])]) df &gt;&gt; unchop(f.y) Out[8]: x y$x y$y &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; 0 2 1.0 NaN 1 3 NaN 1.0 2 3 NaN 2.0 In\u00a0[9]: Copied! <pre>df &gt;&gt; unchop(f.y, keep_empty=True)\n</pre> df &gt;&gt; unchop(f.y, keep_empty=True) Out[9]: x y$x y$y &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; 0 1 NaN NaN 1 2 1.0 NaN 2 3 NaN 1.0 3 3 NaN 2.0"},{"location":"notebooks/chop/#chop","title":"\u2605 chop\u00b6","text":""},{"location":"notebooks/chop/#makes-data-frame-shorter-by-converting-rows-within-each-group","title":"Makes data frame shorter by converting rows within each group\u00b6","text":"<p>into list-columns.</p>"},{"location":"notebooks/chop/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: A data frame <code>cols</code>: Columns to chop</p>"},{"location":"notebooks/chop/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003Data frame with selected columns chopped</p>"},{"location":"notebooks/chop/#unchop","title":"\u2605 unchop\u00b6","text":""},{"location":"notebooks/chop/#makes-df-longer-by-expanding-list-columns-so-that-each-element","title":"Makes df longer by expanding list-columns so that each element\u00b6","text":"<p>of the list-column gets its own row in the output.</p> <p>See https://tidyr.tidyverse.org/reference/chop.html</p> <p>Recycling size-1 elements might be different from <code>tidyr</code> \u2003\u2003&gt;&gt;&gt; df = tibble(x=[1, [2,3]], y=[[2,3], 1]) \u2003\u2003&gt;&gt;&gt; df &gt;&gt; unchop([f.x, f.y]) \u2003\u2003&gt;&gt;&gt; # tibble(x=[1,2,3], y=[2,3,1]) \u2003\u2003&gt;&gt;&gt; # instead of following in tidyr \u2003\u2003&gt;&gt;&gt; # tibble(x=[1,1,2,3], y=[2,3,1,1])</p>"},{"location":"notebooks/chop/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: A data frame. <code>cols</code>: Columns to unchop. <code>keep_empty</code>: By default, you get one row of output for each element \u2003\u2003\u2003\u2003of the list your unchopping/unnesting. \u2003\u2003\u2003\u2003This means that if there's a size-0 element \u2003\u2003\u2003\u2003(like NULL or an empty data frame), that entire row will be \u2003\u2003\u2003\u2003dropped from the output. \u2003\u2003\u2003\u2003If you want to preserve all rows, use <code>keep_empty</code> = <code>True</code> to \u2003\u2003\u2003\u2003replace size-0 elements with a single row of missing values.</p> <p> <code>dtypes</code>: Providing the dtypes for the output columns. \u2003\u2003\u2003\u2003Could be a single dtype, which will be applied to all columns, or \u2003\u2003\u2003\u2003a dictionary of dtypes with keys for the columns and values the \u2003\u2003\u2003\u2003dtypes. \u2003\u2003\u2003\u2003For nested data frames, we need to specify <code>col$a</code> as key. If <code>col</code> \u2003\u2003\u2003\u2003is used as key, all columns of the nested data frames will be casted \u2003\u2003\u2003\u2003into that dtype.</p>"},{"location":"notebooks/chop/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with selected columns unchopped.</p>"},{"location":"notebooks/coalesce/","title":"coalesce","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/coalesce.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(coalesce)\n</pre> # https://dplyr.tidyverse.org/reference/coalesce.html %run nb_helpers.py  from datar.all import *  nb_header(coalesce) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x=[5,4,3,NA,2,NA,1,NA])\ndf &gt;&gt; mutate(y=coalesce(f.x, 0)) &gt;&gt; pull(f.y)\n</pre> df = tibble(x=[5,4,3,NA,2,NA,1,NA]) df &gt;&gt; mutate(y=coalesce(f.x, 0)) &gt;&gt; pull(f.y) Out[2]: <pre>0    5.0\n1    4.0\n2    3.0\n3    0.0\n4    2.0\n5    0.0\n6    1.0\n7    0.0\nName: y, dtype: float64</pre> In\u00a0[3]: Copied! <pre>df = tibble(\n    y=[1,2,NA,NA,5],\n    z=[NA,NA,3,4,5]\n)\ndf &gt;&gt; mutate(m=coalesce(f.y, f.z)) &gt;&gt; pull(f.m)\n</pre> df = tibble(     y=[1,2,NA,NA,5],     z=[NA,NA,3,4,5] ) df &gt;&gt; mutate(m=coalesce(f.y, f.z)) &gt;&gt; pull(f.m) Out[3]: <pre>0    1.0\n1    2.0\n2    3.0\n3    4.0\n4    5.0\nName: m, dtype: float64</pre>"},{"location":"notebooks/coalesce/#coalesce","title":"\u2605 coalesce\u00b6","text":""},{"location":"notebooks/coalesce/#replace-missing-values-with-the-first-non-missing-value","title":"Replace missing values with the first non-missing value\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/coalesce.html</p>"},{"location":"notebooks/coalesce/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A vector <code>*replace</code>: Values to replace missing values with.</p>"},{"location":"notebooks/coalesce/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003An array of values</p>"},{"location":"notebooks/complete/","title":"complete","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\nfrom datar.all import *\n\nnb_header(complete)\n</pre> %run nb_helpers.py from datar.all import *  nb_header(complete) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(\n  group = c(c[1:2:1], 1),\n  item_id = c(c[1:2:1], 2),\n  item_name = c(\"a\", \"b\", \"b\"),\n  value1 = c[1:3:1],\n  value2 = c[4:6:1]\n)\ndf &gt;&gt; complete(f.group, nesting(f.item_id, f.item_name))\n</pre> df = tibble(   group = c(c[1:2:1], 1),   item_id = c(c[1:2:1], 2),   item_name = c(\"a\", \"b\", \"b\"),   value1 = c[1:3:1],   value2 = c[4:6:1] ) df &gt;&gt; complete(f.group, nesting(f.item_id, f.item_name)) Out[2]: group item_id item_name value1 value2 &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;float64&gt; 0 1 1 a 1.0 4.0 1 1 2 b 3.0 6.0 2 2 1 a NaN NaN 3 2 2 b 2.0 5.0 In\u00a0[3]: Copied! <pre>df &gt;&gt; complete(f.group, nesting(f.item_id, f.item_name), fill=dict(value1=0))\n</pre> df &gt;&gt; complete(f.group, nesting(f.item_id, f.item_name), fill=dict(value1=0)) Out[3]: group item_id item_name value1 value2 &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;float64&gt; 0 1 1 a 1.0 4.0 1 1 2 b 3.0 6.0 2 2 1 a 0.0 NaN 3 2 2 b 2.0 5.0"},{"location":"notebooks/complete/#complete","title":"\u2605 complete\u00b6","text":""},{"location":"notebooks/complete/#turns-implicit-missing-values-into-explicit-missing-values","title":"Turns implicit missing values into explicit missing values.\u00b6","text":""},{"location":"notebooks/complete/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: A data frame <code>*args</code>: columns to expand. Columns can be atomic lists. \u2003\u2003\u2003\u2003- To find all unique combinations of x, y and z, including \u2003\u2003\u2003\u2003\u2003\u2003those not present in the data, supply each variable as a \u2003\u2003\u2003\u2003\u2003\u2003separate argument: <code>expand(df, x, y, z)</code>.</p> <p>\u2003\u2003\u2003\u2003- To find only the combinations that occur in the data, use \u2003\u2003\u2003\u2003\u2003\u2003<code>nesting</code>: <code>expand(df, nesting(x, y, z))</code>.</p> <p>\u2003\u2003\u2003\u2003- You can combine the two forms. For example, \u2003\u2003\u2003\u2003\u2003\u2003<code>expand(df, nesting(school_id, student_id), date)</code> would \u2003\u2003\u2003\u2003\u2003\u2003produce a row for each present school-student combination \u2003\u2003\u2003\u2003\u2003\u2003for all possible dates.</p> <p> <code>fill</code>: A named list that for each variable supplies a single value \u2003\u2003\u2003\u2003to use instead of NA for missing combinations.</p> <p> <code>explict</code>: Should both implicit (newly created) and explicit \u2003\u2003\u2003\u2003(pre-existing) missing values be filled by fill? By default, \u2003\u2003\u2003\u2003this is TRUE, but if set to FALSE this will limit the fill to only \u2003\u2003\u2003\u2003implicit missing values.</p>"},{"location":"notebooks/complete/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003Data frame with missing values completed</p>"},{"location":"notebooks/context/","title":"context","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/context.html\n%run nb_helpers.py\nfrom datar.all import *\n\nnb_header(cur_group_id, cur_group_rows, cur_data, cur_data_all, cur_column, book='context')\n</pre> # https://dplyr.tidyverse.org/reference/context.html %run nb_helpers.py from datar.all import *  nb_header(cur_group_id, cur_group_rows, cur_data, cur_data_all, cur_column, book='context') Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(\n  g=['a'] + ['b'] * 2 + ['c'] * 3,\n  x=runif(6),\n  y=runif(6)\n)\ngf = df &gt;&gt; group_by(f.g)\n\ngf &gt;&gt; summarise(n = n())\n</pre> df = tibble(   g=['a'] + ['b'] * 2 + ['c'] * 3,   x=runif(6),   y=runif(6) ) gf = df &gt;&gt; group_by(f.g)  gf &gt;&gt; summarise(n = n()) Out[2]: g n &lt;object&gt; &lt;int64&gt; 0 a 1 1 b 2 2 c 3 In\u00a0[3]: Copied! <pre>gf\n</pre> gf Out[3]: g x y &lt;object&gt; &lt;float64&gt; &lt;float64&gt; 0 a 0.879733 0.242456 1 b 0.789550 0.165711 2 b 0.073877 0.198040 3 c 0.677826 0.186310 4 c 0.324069 0.212226 5 c 0.589881 0.990174 <p>TibbleGrouped: g (n=3) </p> In\u00a0[4]: Copied! <pre>gf &gt;&gt; mutate(id=cur_group_id()) \n</pre> gf &gt;&gt; mutate(id=cur_group_id())  Out[4]: g x y id &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; 0 a 0.879733 0.242456 0 1 b 0.789550 0.165711 1 2 b 0.073877 0.198040 1 3 c 0.677826 0.186310 2 4 c 0.324069 0.212226 2 5 c 0.589881 0.990174 2 <p>TibbleGrouped: g (n=3) </p> In\u00a0[5]: Copied! <pre>gf &gt;&gt; summarise(row=cur_group_rows()) \n</pre> gf &gt;&gt; summarise(row=cur_group_rows())  Out[5]: g row &lt;object&gt; &lt;object&gt; 0 a [0] 1 b [1, 2] 2 c [3, 4, 5] In\u00a0[6]: Copied! <pre>gf_group = gf &gt;&gt; summarise(data=cur_group())\ngf_group \n</pre> gf_group = gf &gt;&gt; summarise(data=cur_group()) gf_group  Out[6]: g data &lt;object&gt; &lt;object&gt; 0 a &lt;DF 1x1&gt; 1 b &lt;DF 1x1&gt; 2 c &lt;DF 1x1&gt; In\u00a0[7]: Copied! <pre>gf_group &gt;&gt; pull(f.data)\n</pre> gf_group &gt;&gt; pull(f.data) Out[7]: <pre>0    &lt;DF 1x1&gt;\n1    &lt;DF 1x1&gt;\n2    &lt;DF 1x1&gt;\nName: data, dtype: object</pre> In\u00a0[8]: Copied! <pre>gf_data = gf &gt;&gt; summarise(data=cur_data())\ngf_data\n</pre> gf_data = gf &gt;&gt; summarise(data=cur_data()) gf_data Out[8]: g data &lt;object&gt; &lt;object&gt; 0 a &lt;DF 1x2&gt; 1 b &lt;DF 2x2&gt; 2 c &lt;DF 3x2&gt; In\u00a0[9]: Copied! <pre>gf_data &gt;&gt; pull(f.data, to='list')\n</pre> gf_data &gt;&gt; pull(f.data, to='list') Out[9]: <pre>[          x         y\n   &lt;float64&gt; &lt;float64&gt;\n 0  0.879733  0.242456,\n           x         y\n   &lt;float64&gt; &lt;float64&gt;\n 1  0.789550  0.165711\n 2  0.073877  0.198040,\n           x         y\n   &lt;float64&gt; &lt;float64&gt;\n 3  0.677826  0.186310\n 4  0.324069  0.212226\n 5  0.589881  0.990174]</pre> In\u00a0[10]: Copied! <pre>gf_data_all = gf &gt;&gt; summarise(data=cur_data_all())\ngf_data_all\n</pre> gf_data_all = gf &gt;&gt; summarise(data=cur_data_all()) gf_data_all Out[10]: g data &lt;object&gt; &lt;object&gt; 0 a &lt;DF 1x3&gt; 1 b &lt;DF 2x3&gt; 2 c &lt;DF 3x3&gt; In\u00a0[11]: Copied! <pre>gf_data_all &gt;&gt; pull(f.data, to='list')\n</pre> gf_data_all &gt;&gt; pull(f.data, to='list') Out[11]: <pre>[         g         x         y\n   &lt;object&gt; &lt;float64&gt; &lt;float64&gt;\n 0        a  0.879733  0.242456,\n          g         x         y\n   &lt;object&gt; &lt;float64&gt; &lt;float64&gt;\n 1        b  0.789550  0.165711\n 2        b  0.073877  0.198040,\n          g         x         y\n   &lt;object&gt; &lt;float64&gt; &lt;float64&gt;\n 3        c  0.677826  0.186310\n 4        c  0.324069  0.212226\n 5        c  0.589881  0.990174]</pre> In\u00a0[12]: Copied! <pre>df &gt;&gt; select(f.x, f.y) &gt;&gt; mutate(\n    across(\n        everything(), \n        lambda x, cc: [cc + ' '] * x.shape[0] + (x**2).astype(str), cc=cur_column()\n    )\n)\n</pre> df &gt;&gt; select(f.x, f.y) &gt;&gt; mutate(     across(         everything(),          lambda x, cc: [cc + ' '] * x.shape[0] + (x**2).astype(str), cc=cur_column()     ) ) Out[12]: x y &lt;object&gt; &lt;object&gt; 0 x 0.7739296633011361 y 0.05878489331508395 1 x 0.6233885082054422 y 0.027460112154048803 2 x 0.005457753705443728 y 0.03921965587769912 3 x 0.45944873370090106 y 0.034711398724083777 4 x 0.10502100613889181 y 0.04504004423820979 5 x 0.3479600358358678 y 0.9804449881028017 In\u00a0[13]: Copied! <pre># or you can use x.name, since x is a Series\ndf &gt;&gt; mutate(across(\n    [f.x, f.y], \n    lambda x: [x.name + ' '] * x.shape[0] + (x**2).astype(str)\n))\n</pre> # or you can use x.name, since x is a Series df &gt;&gt; mutate(across(     [f.x, f.y],      lambda x: [x.name + ' '] * x.shape[0] + (x**2).astype(str) )) Out[13]: g x y &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 a x 0.7739296633011361 y 0.05878489331508395 1 b x 0.6233885082054422 y 0.027460112154048803 2 b x 0.005457753705443728 y 0.03921965587769912 3 c x 0.45944873370090106 y 0.034711398724083777 4 c x 0.10502100613889181 y 0.04504004423820979 5 c x 0.3479600358358678 y 0.9804449881028017"},{"location":"notebooks/context/#cur_group_id","title":"\u2605 cur_group_id\u00b6","text":""},{"location":"notebooks/context/#get-the-current-group-id","title":"Get the current group id\u00b6","text":""},{"location":"notebooks/context/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: The dataframe</p>"},{"location":"notebooks/context/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The current group id</p>"},{"location":"notebooks/context/#cur_group_rows","title":"\u2605 cur_group_rows\u00b6","text":""},{"location":"notebooks/context/#get-the-current-group-row-indices","title":"Get the current group row indices\u00b6","text":""},{"location":"notebooks/context/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: The dataframe</p>"},{"location":"notebooks/context/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The current group rows</p>"},{"location":"notebooks/context/#cur_data","title":"\u2605 cur_data\u00b6","text":""},{"location":"notebooks/context/#get-the-current-dataframe","title":"Get the current dataframe\u00b6","text":""},{"location":"notebooks/context/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: The dataframe</p>"},{"location":"notebooks/context/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The current dataframe</p>"},{"location":"notebooks/context/#cur_data_all","title":"\u2605 cur_data_all\u00b6","text":""},{"location":"notebooks/context/#get-the-current-data-for-the-current-group-including","title":"Get the current data for the current group including\u00b6","text":"<p>the grouping variables</p>"},{"location":"notebooks/context/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: The dataframe</p>"},{"location":"notebooks/context/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The current dataframe</p>"},{"location":"notebooks/context/#cur_column","title":"\u2605 cur_column\u00b6","text":""},{"location":"notebooks/context/#get-the-current-column","title":"Get the current column\u00b6","text":""},{"location":"notebooks/context/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: The dataframe <code>_name</code>: The column name</p>"},{"location":"notebooks/context/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The current column</p>"},{"location":"notebooks/count/","title":"count","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/count.html\n%run nb_helpers.py\n\nfrom datar.data import starwars\nfrom datar.all import *\n\nnb_header(count, tally, add_count, add_tally)\n</pre> # https://dplyr.tidyverse.org/reference/count.html %run nb_helpers.py  from datar.data import starwars from datar.all import *  nb_header(count, tally, add_count, add_tally) Try this notebook on binder. In\u00a0[2]: Copied! <pre>starwars &gt;&gt; count(f.species)\n</pre> starwars &gt;&gt; count(f.species) Out[2]: species n &lt;object&gt; &lt;int64&gt; 0 Human 35 1 Droid 6 2 Wookiee 2 3 Rodian 1 4 Hutt 1 5 Yoda's species 1 6 Trandoshan 1 7 Mon Calamari 1 8 Ewok 1 9 Sullustan 1 10 Neimodian 1 11 Gungan 3 12 NaN 4 13 Toydarian 1 14 Dug 1 15 Zabrak 2 16 Twi'lek 2 17 Vulptereen 1 18 Xexto 1 19 Toong 1 20 Cerean 1 21 Nautolan 1 22 Tholothian 1 23 Iktotchi 1 24 Quermian 1 25 Kel Dor 1 26 Chagrian 1 27 Geonosian 1 28 Mirialan 2 29 Clawdite 1 30 Besalisk 1 31 Kaminoan 2 32 Aleena 1 33 Skakoan 1 34 Muun 1 35 Togruta 1 36 Kaleesh 1 37 Pau'an 1 In\u00a0[3]: Copied! <pre>starwars &gt;&gt; count(f.species, sort=True)\n</pre> starwars &gt;&gt; count(f.species, sort=True) Out[3]: species n &lt;object&gt; &lt;int64&gt; 0 Human 35 1 Droid 6 2 NaN 4 3 Gungan 3 4 Twi'lek 2 5 Zabrak 2 6 Kaminoan 2 7 Mirialan 2 8 Wookiee 2 9 Besalisk 1 10 Clawdite 1 11 Iktotchi 1 12 Skakoan 1 13 Muun 1 14 Geonosian 1 15 Chagrian 1 16 Togruta 1 17 Kel Dor 1 18 Quermian 1 19 Aleena 1 20 Tholothian 1 21 Xexto 1 22 Cerean 1 23 Toong 1 24 Kaleesh 1 25 Vulptereen 1 26 Dug 1 27 Toydarian 1 28 Neimodian 1 29 Sullustan 1 30 Ewok 1 31 Mon Calamari 1 32 Trandoshan 1 33 Yoda's species 1 34 Hutt 1 35 Rodian 1 36 Nautolan 1 37 Pau'an 1 <p>TibbleGrouped: species (n=38) </p> In\u00a0[4]: Copied! <pre>starwars &gt;&gt; count(f.sex, f.gender, sort=True)\n</pre> starwars &gt;&gt; count(f.sex, f.gender, sort=True) Out[4]: sex gender n &lt;object&gt; &lt;object&gt; &lt;int64&gt; 0 male masculine 60 1 female feminine 16 2 none masculine 5 3 NaN NaN 4 4 hermaphroditic masculine 1 5 none feminine 1 <p>TibbleGrouped: sex, gender (n=6) </p> In\u00a0[5]: Copied! <pre>starwars &gt;&gt; count(birth_decade=round(f.birth_year, -1))\n</pre> starwars &gt;&gt; count(birth_decade=round(f.birth_year, -1)) Out[5]: birth_decade n &lt;float64&gt; &lt;int64&gt; 0 20.0 6 1 110.0 1 2 30.0 4 3 40.0 6 4 50.0 8 5 NaN 44 6 60.0 4 7 200.0 1 8 600.0 1 9 900.0 1 10 80.0 2 11 10.0 1 12 90.0 3 13 70.0 4 14 100.0 1 In\u00a0[6]: Copied! <pre>df = tribble(\n  f.name,    f.gender,   f.runs,\n  \"Max\",    \"male\",       10,\n  \"Sandra\", \"female\",      1,\n  \"Susan\",  \"female\",      4\n)\n# counts rows:\ndf &gt;&gt; count(f.gender)\n</pre> df = tribble(   f.name,    f.gender,   f.runs,   \"Max\",    \"male\",       10,   \"Sandra\", \"female\",      1,   \"Susan\",  \"female\",      4 ) # counts rows: df &gt;&gt; count(f.gender) Out[6]: gender n &lt;object&gt; &lt;int64&gt; 0 male 1 1 female 2 In\u00a0[7]: Copied! <pre>df &gt;&gt; count(f.gender, wt=f.runs)\n</pre> df &gt;&gt; count(f.gender, wt=f.runs) Out[7]: gender n &lt;object&gt; &lt;int64&gt; 0 male 10 1 female 5 In\u00a0[8]: Copied! <pre>starwars &gt;&gt; tally()\n</pre> starwars &gt;&gt; tally() Out[8]: n &lt;int64&gt; 0 87 In\u00a0[9]: Copied! <pre>starwars &gt;&gt; group_by(f.species) &gt;&gt; tally() \n</pre> starwars &gt;&gt; group_by(f.species) &gt;&gt; tally()  Out[9]: species n &lt;object&gt; &lt;int64&gt; 0 Human 35 1 Droid 6 2 Wookiee 2 3 Rodian 1 4 Hutt 1 5 Yoda's species 1 6 Trandoshan 1 7 Mon Calamari 1 8 Ewok 1 9 Sullustan 1 10 Neimodian 1 11 Gungan 3 12 NaN 4 13 Toydarian 1 14 Dug 1 15 Zabrak 2 16 Twi'lek 2 17 Vulptereen 1 18 Xexto 1 19 Toong 1 20 Cerean 1 21 Nautolan 1 22 Tholothian 1 23 Iktotchi 1 24 Quermian 1 25 Kel Dor 1 26 Chagrian 1 27 Geonosian 1 28 Mirialan 2 29 Clawdite 1 30 Besalisk 1 31 Kaminoan 2 32 Aleena 1 33 Skakoan 1 34 Muun 1 35 Togruta 1 36 Kaleesh 1 37 Pau'an 1 In\u00a0[10]: Copied! <pre>df &gt;&gt; add_count(f.gender, wt=f.runs)\n</pre> df &gt;&gt; add_count(f.gender, wt=f.runs) Out[10]: name gender runs n &lt;object&gt; &lt;object&gt; &lt;int64&gt; &lt;int64&gt; 0 Max male 10 10 1 Sandra female 1 5 2 Susan female 4 5 <p>TibbleGrouped: gender (n=2) </p> In\u00a0[11]: Copied! <pre>df\n</pre> df Out[11]: name gender runs &lt;object&gt; &lt;object&gt; &lt;int64&gt; 0 Max male 10 1 Sandra female 1 2 Susan female 4 In\u00a0[12]: Copied! <pre>df &gt;&gt; add_tally(wt=f.runs)\n</pre> df &gt;&gt; add_tally(wt=f.runs) Out[12]: name gender runs n &lt;object&gt; &lt;object&gt; &lt;int64&gt; &lt;int64&gt; 0 Max male 10 15 1 Sandra female 1 15 2 Susan female 4 15"},{"location":"notebooks/count/#count","title":"\u2605 count\u00b6","text":""},{"location":"notebooks/count/#count-the-number-of-rows-in-each-group","title":"Count the number of rows in each group\u00b6","text":"<p>Original API: https://dplyr.tidyverse.org/reference/count.html</p>"},{"location":"notebooks/count/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>*args</code>: Variables, or functions of variables. \u2003\u2003\u2003\u2003Use desc() to sort a variable in descending order.</p> <p> <code>wt</code>: A variable or function of variables to weight by. <code>sort</code>: If TRUE, the result will be sorted by the count. <code>name</code>: The name of the count column. <code>_drop</code>: If <code>False</code>, keep grouping variables even if they are not used. \u2003\u2003\u2003\u2003Original API does not support this.</p> <p> <code>**kwargs</code>: Name-value pairs that apply with mutate</p>"},{"location":"notebooks/count/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with the same number of rows as the number of groups. \u2003\u2003The output has the following properties: \u2003\u2003\u2003\u2003All rows appear in the output, but (usually) in a different place. \u2003\u2003\u2003\u2003Columns are not modified. \u2003\u2003\u2003\u2003Groups are not modified. \u2003\u2003\u2003\u2003Data frame attributes are preserved.</p>"},{"location":"notebooks/count/#tally","title":"\u2605 tally\u00b6","text":""},{"location":"notebooks/count/#count-the-number-of-rows-in-each-group","title":"Count the number of rows in each group\u00b6","text":"<p>Original API: https://dplyr.tidyverse.org/reference/count.html</p>"},{"location":"notebooks/count/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>wt</code>: A variable or function of variables to weight by. <code>sort</code>: If TRUE, the result will be sorted by the count. <code>name</code>: The name of the count column.</p>"},{"location":"notebooks/count/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with the same number of rows as the number of groups. \u2003\u2003The output has the following properties: \u2003\u2003\u2003\u2003All rows appear in the output, but (usually) in a different place. \u2003\u2003\u2003\u2003Columns are not modified. \u2003\u2003\u2003\u2003Groups are not modified. \u2003\u2003\u2003\u2003Data frame attributes are preserved.</p>"},{"location":"notebooks/count/#add_count","title":"\u2605 add_count\u00b6","text":""},{"location":"notebooks/count/#add-a-count-column-to-a-data-frame","title":"Add a count column to a data frame\u00b6","text":"<p>Original API: https://dplyr.tidyverse.org/reference/count.html</p>"},{"location":"notebooks/count/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>*args</code>: Variables, or functions of variables. \u2003\u2003\u2003\u2003Use desc() to sort a variable in descending order.</p> <p> <code>wt</code>: A variable or function of variables to weight by. <code>sort</code>: If TRUE, the result will be sorted by the count. <code>name</code>: The name of the count column. <code>**kwargs</code>: Name-value pairs that apply with mutate</p>"},{"location":"notebooks/count/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with the same number of rows as the number of groups. \u2003\u2003The output has the following properties: \u2003\u2003\u2003\u2003All rows appear in the output, but (usually) in a different place. \u2003\u2003\u2003\u2003Columns are not modified. \u2003\u2003\u2003\u2003Groups are not modified. \u2003\u2003\u2003\u2003Data frame attributes are preserved.</p>"},{"location":"notebooks/count/#add_tally","title":"\u2605 add_tally\u00b6","text":""},{"location":"notebooks/count/#add-a-count-column-to-a-data-frame","title":"Add a count column to a data frame\u00b6","text":"<p>Original API: https://dplyr.tidyverse.org/reference/count.html</p>"},{"location":"notebooks/count/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>wt</code>: A variable or function of variables to weight by. <code>sort</code>: If TRUE, the result will be sorted by the count. <code>name</code>: The name of the count column.</p>"},{"location":"notebooks/count/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with the same number of rows as the number of groups. \u2003\u2003The output has the following properties: \u2003\u2003\u2003\u2003All rows appear in the output, but (usually) in a different place. \u2003\u2003\u2003\u2003Columns are not modified. \u2003\u2003\u2003\u2003Groups are not modified. \u2003\u2003\u2003\u2003Data frame attributes are preserved.</p>"},{"location":"notebooks/cumall/","title":"cumall","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/cumall.html\n%run nb_helpers.py\n\nimport numpy\n\nfrom datar.all import *\n\nnb_header(cummean, cumsum, cumall, cumany, cumany, book='cumall')\n</pre> # https://dplyr.tidyverse.org/reference/cumall.html %run nb_helpers.py  import numpy  from datar.all import *  nb_header(cummean, cumsum, cumall, cumany, cumany, book='cumall') Try this notebook on binder. In\u00a0[2]: Copied! <pre>x = [1, 3, 5, 2, 2]\ncummean(x)\n</pre> x = [1, 3, 5, 2, 2] cummean(x) Out[2]: <pre>0    1.00\n1    2.00\n2    3.00\n3    2.75\n4    2.60\ndtype: float64</pre> In\u00a0[3]: Copied! <pre>cumsum(x) / seq_along(x) \n</pre> cumsum(x) / seq_along(x)  Out[3]: <pre>array([1.  , 2.  , 3.  , 2.75, 2.6 ])</pre> In\u00a0[4]: Copied! <pre>cumall(numpy.array(x) &lt; 5)\n</pre> cumall(numpy.array(x) &lt; 5) Out[4]: <pre>0     True\n1     True\n2    False\n3    False\n4    False\ndtype: bool</pre> In\u00a0[5]: Copied! <pre>cumany(numpy.array(x) == 3)\n</pre> cumany(numpy.array(x) == 3) Out[5]: <pre>0    False\n1     True\n2     True\n3     True\n4     True\ndtype: bool</pre> In\u00a0[6]: Copied! <pre>df = tibble(\n  date = as_date([f\"2020-01-0{i+1}\" for i in range(7)]),\n  balance = c(100, 50, 25, -25, -50, 30, 120)\n)\ndf &gt;&gt; filter(cumany(f.balance &lt; 0))\n</pre> df = tibble(   date = as_date([f\"2020-01-0{i+1}\" for i in range(7)]),   balance = c(100, 50, 25, -25, -50, 30, 120) ) df &gt;&gt; filter(cumany(f.balance &lt; 0)) Out[6]: date balance &lt;object&gt; &lt;int64&gt; 3 2020-01-04 -25 4 2020-01-05 -50 5 2020-01-06 30 6 2020-01-07 120 In\u00a0[7]: Copied! <pre>df &gt;&gt; filter(cumall(~(f.balance &lt; 0)))\n</pre> df &gt;&gt; filter(cumall(~(f.balance &lt; 0))) Out[7]: date balance &lt;object&gt; &lt;int64&gt; 0 2020-01-01 100 1 2020-01-02 50 2 2020-01-03 25"},{"location":"notebooks/cumall/#cummean","title":"\u2605 cummean\u00b6","text":""},{"location":"notebooks/cumall/#cumulative-mean","title":"Cumulative mean\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/cumall.html</p>"},{"location":"notebooks/cumall/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>na_rm</code>: If <code>True</code>, remove missing values before computing.</p>"},{"location":"notebooks/cumall/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003An array of cumulative means</p>"},{"location":"notebooks/cumall/#cumsum","title":"\u2605 cumsum\u00b6","text":""},{"location":"notebooks/cumall/#cumulative-sums","title":"Cumulative sums\u00b6","text":""},{"location":"notebooks/cumall/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector</p>"},{"location":"notebooks/cumall/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The cumulative sums</p>"},{"location":"notebooks/cumall/#cumall","title":"\u2605 cumall\u00b6","text":""},{"location":"notebooks/cumall/#get-cumulative-bool-all-cases-after-first-false","title":"Get cumulative bool. All cases after first False\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/cumall.html</p>"},{"location":"notebooks/cumall/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A logical vector</p>"},{"location":"notebooks/cumall/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003An array of cumulative conjunctions</p>"},{"location":"notebooks/cumall/#cumany","title":"\u2605 cumany\u00b6","text":""},{"location":"notebooks/cumall/#get-cumulative-bool-all-cases-after-first-true","title":"Get cumulative bool. All cases after first True\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/cumany.html</p>"},{"location":"notebooks/cumall/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A logical vector</p>"},{"location":"notebooks/cumall/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003An array of cumulative disjunctions</p>"},{"location":"notebooks/cumall/#cumany","title":"\u2605 cumany\u00b6","text":""},{"location":"notebooks/cumall/#get-cumulative-bool-all-cases-after-first-true","title":"Get cumulative bool. All cases after first True\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/cumany.html</p>"},{"location":"notebooks/cumall/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A logical vector</p>"},{"location":"notebooks/cumall/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003An array of cumulative disjunctions</p>"},{"location":"notebooks/desc/","title":"desc","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\nfrom datar.base import factor, letters\nfrom datar.dplyr import desc\n\nnb_header(desc)\n</pre> %run nb_helpers.py from datar.base import factor, letters from datar.dplyr import desc  nb_header(desc) Try this notebook on binder. In\u00a0[2]: Copied! <pre>desc(range(1,11))\n</pre> desc(range(1,11)) Out[2]: <pre>array([ -1,  -2,  -3,  -4,  -5,  -6,  -7,  -8,  -9, -10])</pre> In\u00a0[3]: Copied! <pre>desc(factor(letters))\n</pre> desc(factor(letters)) Out[3]: <pre>array([ -0.,  -1.,  -2.,  -3.,  -4.,  -5.,  -6.,  -7.,  -8.,  -9., -10.,\n       -11., -12., -13., -14., -15., -16., -17., -18., -19., -20., -21.,\n       -22., -23., -24., -25.])</pre>"},{"location":"notebooks/desc/#desc","title":"\u2605 desc\u00b6","text":""},{"location":"notebooks/desc/#transform-a-vector-into-a-format-that-will-be-sorted-in-descending-order","title":"Transform a vector into a format that will be sorted in descending order\u00b6","text":"<p>This is useful within arrange().</p> <p>The original API: https://dplyr.tidyverse.org/reference/desc.html</p>"},{"location":"notebooks/desc/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: vector to transform</p>"},{"location":"notebooks/desc/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The descending order of x</p>"},{"location":"notebooks/distinct/","title":"distinct","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/distinct.html\n%run nb_helpers.py\nfrom datar.data import starwars\nfrom datar.all import *\n\nnb_header(distinct, n_distinct, book='distinct')\n</pre> # https://dplyr.tidyverse.org/reference/distinct.html %run nb_helpers.py from datar.data import starwars from datar.all import *  nb_header(distinct, n_distinct, book='distinct') Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(\n  x=sample(range(10), 100, replace=True),\n  y=sample(range(10), 100, replace=True)\n)\nnrow(df)\n</pre> df = tibble(   x=sample(range(10), 100, replace=True),   y=sample(range(10), 100, replace=True) ) nrow(df) Out[2]: <pre>100</pre> In\u00a0[3]: Copied! <pre>nrow(distinct(df))\n</pre> nrow(distinct(df)) Out[3]: <pre>59</pre> In\u00a0[4]: Copied! <pre>df &gt;&gt; distinct(f.x, f.y) &gt;&gt; nrow()\n</pre> df &gt;&gt; distinct(f.x, f.y) &gt;&gt; nrow() Out[4]: <pre>59</pre> In\u00a0[5]: Copied! <pre>df &gt;&gt; distinct(f.x)\n</pre> df &gt;&gt; distinct(f.x) Out[5]: x &lt;int64&gt; 0 4 1 6 2 1 3 8 4 5 6 9 14 2 19 7 22 0 38 3 In\u00a0[6]: Copied! <pre>df &gt;&gt; distinct(f.y)\n</pre> df &gt;&gt; distinct(f.y) Out[6]: y &lt;int64&gt; 0 4 1 3 2 1 3 7 4 8 6 6 10 9 13 0 16 5 18 2 In\u00a0[7]: Copied! <pre>df &gt;&gt; distinct(f.x, _keep_all=True)\n</pre> df &gt;&gt; distinct(f.x, _keep_all=True) Out[7]: x y &lt;int64&gt; &lt;int64&gt; 0 4 4 1 6 3 2 1 1 3 8 7 4 5 8 6 9 6 14 2 0 19 7 8 22 0 6 38 3 0 In\u00a0[8]: Copied! <pre>df &gt;&gt; distinct(f.y, _keep_all=True)\n</pre> df &gt;&gt; distinct(f.y, _keep_all=True) Out[8]: x y &lt;int64&gt; &lt;int64&gt; 0 4 4 1 6 3 2 1 1 3 8 7 4 5 8 6 9 6 10 1 9 13 6 0 16 4 5 18 6 2 In\u00a0[9]: Copied! <pre>df &gt;&gt; distinct(diff=abs(f.x-f.y))\n</pre> df &gt;&gt; distinct(diff=abs(f.x-f.y)) Out[9]: diff &lt;int64&gt; 0 0 1 3 3 1 8 5 10 8 13 6 14 2 18 4 36 7 89 9 In\u00a0[10]: Copied! <pre>starwars &gt;&gt; distinct(across(contains(\"color\")))\n</pre> starwars &gt;&gt; distinct(across(contains(\"color\"))) Out[10]: hair_color skin_color eye_color &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 blond fair blue 1 NaN gold yellow 2 NaN white, blue red 3 none white yellow ... ... ... ... 4 brown light brown 79 none pale white 81 black dark dark 82 brown light hazel 84 none none black 85 unknown unknown unknown <p>67 rows \u00d7 3 columns</p> In\u00a0[11]: Copied! <pre>df = tibble(\n  g=[1, 1, 2, 2],\n  x=[1, 1, 2, 1]\n) &gt;&gt; group_by(f.g)\n\ndf &gt;&gt; distinct(f.x) \n</pre> df = tibble(   g=[1, 1, 2, 2],   x=[1, 1, 2, 1] ) &gt;&gt; group_by(f.g)  df &gt;&gt; distinct(f.x)  Out[11]: g x &lt;int64&gt; &lt;int64&gt; 0 1 1 2 2 2 <p>TibbleGrouped: g (n=2) </p>"},{"location":"notebooks/distinct/#distinct","title":"\u2605 distinct\u00b6","text":""},{"location":"notebooks/distinct/#filter-a-data-frame-based-on-conditions","title":"Filter a data frame based on conditions\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/distinct.html</p>"},{"location":"notebooks/distinct/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>*args</code>: Variables to filter by. <code>keep_all</code>: If <code>True</code>, keep all rows that match. <code>_preserve</code>: If <code>True</code>, keep grouping variables even if they are not used.</p>"},{"location":"notebooks/distinct/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The subset dataframe</p>"},{"location":"notebooks/distinct/#n_distinct","title":"\u2605 n_distinct\u00b6","text":""},{"location":"notebooks/distinct/#count-the-number-of-distinct-values","title":"Count the number of distinct values\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/distinct.html</p>"},{"location":"notebooks/distinct/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>na_rm</code>: If <code>True</code>, remove missing values before counting.</p>"},{"location":"notebooks/distinct/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The number of distinct values</p>"},{"location":"notebooks/drop_na/","title":"drop_na","text":"In\u00a0[1]: Copied! <pre># https://tidyr.tidyverse.org/reference/drop_na.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(drop_na)\n</pre> # https://tidyr.tidyverse.org/reference/drop_na.html %run nb_helpers.py  from datar.all import *  nb_header(drop_na) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x = c(1, 2, NA), y = c(\"a\", NA, \"b\"))\ndf &gt;&gt; drop_na()\n</pre> df = tibble(x = c(1, 2, NA), y = c(\"a\", NA, \"b\")) df &gt;&gt; drop_na() Out[2]: x y &lt;float64&gt; &lt;object&gt; 0 1.0 a In\u00a0[3]: Copied! <pre>df &gt;&gt; drop_na(f.x)\n</pre> df &gt;&gt; drop_na(f.x) Out[3]: x y &lt;float64&gt; &lt;object&gt; 0 1.0 a 1 2.0 NaN In\u00a0[4]: Copied! <pre>vars = [\"y\"]\ndf &gt;&gt; drop_na(f.x, any_of(vars))\n</pre> vars = [\"y\"] df &gt;&gt; drop_na(f.x, any_of(vars)) Out[4]: x y &lt;float64&gt; &lt;object&gt; 0 1.0 a In\u00a0[5]: Copied! <pre># how_='any' or how_='all'\n# not supported by tidyr\ndf &gt;&gt; drop_na(how_='all')\n</pre> # how_='any' or how_='all' # not supported by tidyr df &gt;&gt; drop_na(how_='all') Out[5]: x y &lt;float64&gt; &lt;object&gt; 0 1.0 a 1 2.0 NaN 2 NaN b In\u00a0[6]: Copied! <pre>df &gt;&gt; drop_na(how_='any')\n</pre> df &gt;&gt; drop_na(how_='any') Out[6]: x y &lt;float64&gt; &lt;object&gt; 0 1.0 a"},{"location":"notebooks/drop_na/#drop_na","title":"\u2605 drop_na\u00b6","text":""},{"location":"notebooks/drop_na/#drop-rows-containing-missing-values","title":"Drop rows containing missing values\u00b6","text":"<p>See https://tidyr.tidyverse.org/reference/drop_na.html</p>"},{"location":"notebooks/drop_na/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: A data frame. <code>*columns</code>: Columns to inspect for missing values. <code>_how</code>: How to select the rows to drop \u2003\u2003\u2003\u2003- all: All columns of <code>columns</code> to be <code>NA</code>s</p> <p>\u2003\u2003\u2003\u2003- any: Any columns of <code>columns</code> to be <code>NA</code>s</p> <p>\u2003\u2003\u2003\u2003(tidyr doesn't support this argument)</p>"},{"location":"notebooks/drop_na/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003Dataframe with rows with NAs dropped and indexes dropped</p>"},{"location":"notebooks/enframe/","title":"enframe","text":"In\u00a0[1]: Copied! <pre># https://tibble.tidyverse.org/reference/enframe.html\n%run nb_helpers.py\n\nfrom datar.tibble import *\nfrom datar.base import seq\n\nnb_header(enframe, deframe, book='enframe')\n</pre> # https://tibble.tidyverse.org/reference/enframe.html %run nb_helpers.py  from datar.tibble import * from datar.base import seq  nb_header(enframe, deframe, book='enframe') Try this notebook on binder. In\u00a0[2]: Copied! <pre>enframe(seq(1,3))\n</pre> enframe(seq(1,3)) Out[2]: name value &lt;int64&gt; &lt;int64&gt; 0 0 1 1 1 2 2 2 3 In\u00a0[3]: Copied! <pre>enframe(dict(a=5, b=7))\n</pre> enframe(dict(a=5, b=7)) Out[3]: name value &lt;object&gt; &lt;int64&gt; 0 a 5 1 b 7 In\u00a0[4]: Copied! <pre>enframe(dict(one=1, two=[2,3], three=[4,5,6]))\n</pre> enframe(dict(one=1, two=[2,3], three=[4,5,6])) Out[4]: name value &lt;object&gt; &lt;object&gt; 0 one 1 1 two [2, 3] 2 three [4, 5, 6] In\u00a0[5]: Copied! <pre>deframe(enframe(seq(3,1)))\n</pre> deframe(enframe(seq(3,1))) Out[5]: <pre>{0: 3, 1: 2, 2: 1}</pre> In\u00a0[6]: Copied! <pre>deframe(tibble(a=seq(1,3)))\n</pre> deframe(tibble(a=seq(1,3))) Out[6]: <pre>array([1, 2, 3])</pre> In\u00a0[7]: Copied! <pre>deframe(tibble(a=[seq(1,3)]))\n</pre> deframe(tibble(a=[seq(1,3)])) Out[7]: <pre>array([array([1, 2, 3])], dtype=object)</pre>"},{"location":"notebooks/enframe/#enframe","title":"\u2605 enframe\u00b6","text":""},{"location":"notebooks/enframe/#converts-mappings-or-lists-to-one-or-two-column-data-frames","title":"Converts mappings or lists to one- or two-column data frames.\u00b6","text":""},{"location":"notebooks/enframe/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: a list, a dictionary or a dataframe with one or two columns <code>name</code>: and <code>value</code>: value Names of the columns that store the names and values. \u2003\u2003\u2003\u2003If <code>None</code>, a one-column dataframe is returned. <code>value</code> cannot be <code>None</code></p>"},{"location":"notebooks/enframe/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with two columns if <code>name</code> is not None (default) or \u2003\u2003one-column otherwise.</p>"},{"location":"notebooks/enframe/#deframe","title":"\u2605 deframe\u00b6","text":""},{"location":"notebooks/enframe/#converts-two-column-data-frames-to-a-dictionary","title":"Converts two-column data frames to a dictionary\u00b6","text":"<p>using the first column as name and the second column as value. If the input has only one column, a list.</p>"},{"location":"notebooks/enframe/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame.</p>"},{"location":"notebooks/enframe/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A dictionary or a list if only one column in the data frame.</p>"},{"location":"notebooks/expand/","title":"expand","text":"In\u00a0[1]: Copied! <pre># https://tidyr.tidyverse.org/reference/expand.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(expand, nesting, crossing)\n</pre> # https://tidyr.tidyverse.org/reference/expand.html %run nb_helpers.py  from datar.all import *  nb_header(expand, nesting, crossing) Try this notebook on binder. In\u00a0[2]: Copied! <pre>fruits = tibble(\n  type   = c(\"apple\", \"orange\", \"apple\", \"orange\", \"orange\", \"orange\"),\n  year   = c(2010, 2010, 2012, 2010, 2010, 2012),\n  size  =  factor(\n    c(\"XS\", \"S\",  \"M\", \"S\", \"S\", \"M\"),\n    levels = c(\"XS\", \"S\", \"M\", \"L\")\n  ),\n  weights = rnorm(6)\n)\nfruits \n</pre>  fruits = tibble(   type   = c(\"apple\", \"orange\", \"apple\", \"orange\", \"orange\", \"orange\"),   year   = c(2010, 2010, 2012, 2010, 2010, 2012),   size  =  factor(     c(\"XS\", \"S\",  \"M\", \"S\", \"S\", \"M\"),     levels = c(\"XS\", \"S\", \"M\", \"L\")   ),   weights = rnorm(6) ) fruits  Out[2]: type year size weights &lt;object&gt; &lt;int64&gt; &lt;category&gt; &lt;float64&gt; 0 apple 2010 XS 2.522472 1 orange 2010 S 0.206341 2 apple 2012 M -0.667409 3 orange 2010 S 0.887561 4 orange 2010 S -1.317738 5 orange 2012 M -0.228718 In\u00a0[3]: Copied! <pre>fruits &gt;&gt; expand(f.type)\n</pre> fruits &gt;&gt; expand(f.type) Out[3]: type &lt;object&gt; 0 apple 1 orange In\u00a0[4]: Copied! <pre>fruits &gt;&gt; expand(f.type, f.size) \n</pre> fruits &gt;&gt; expand(f.type, f.size)  Out[4]: type size &lt;object&gt; &lt;category&gt; 0 apple XS 1 apple S 2 apple M 3 apple L 4 orange XS 5 orange S 6 orange M 7 orange L In\u00a0[5]: Copied! <pre>fruits &gt;&gt; expand(f.type, f.size, f.year)\n</pre> fruits &gt;&gt; expand(f.type, f.size, f.year) Out[5]: type size year &lt;object&gt; &lt;category&gt; &lt;int64&gt; 0 apple XS 2010 1 apple XS 2012 2 apple S 2010 3 apple S 2012 4 apple M 2010 5 apple M 2012 6 apple L 2010 7 apple L 2012 8 orange XS 2010 9 orange XS 2012 10 orange S 2010 11 orange S 2012 12 orange M 2010 13 orange M 2012 14 orange L 2010 15 orange L 2012 In\u00a0[6]: Copied! <pre>fruits &gt;&gt; expand(nesting(f.type))\n</pre> fruits &gt;&gt; expand(nesting(f.type)) Out[6]: type &lt;object&gt; 0 apple 1 orange In\u00a0[7]: Copied! <pre>fruits &gt;&gt; expand(nesting(f.type, f.size))\n</pre> fruits &gt;&gt; expand(nesting(f.type, f.size)) Out[7]: type size &lt;object&gt; &lt;category&gt; 0 apple XS 1 orange S 2 apple M 3 orange M In\u00a0[8]: Copied! <pre>fruits &gt;&gt; expand(nesting(f.type, f.size, f.year))\n</pre> fruits &gt;&gt; expand(nesting(f.type, f.size, f.year)) Out[8]: type size year &lt;object&gt; &lt;category&gt; &lt;int64&gt; 0 apple XS 2010 1 orange S 2010 2 apple M 2012 3 orange M 2012 In\u00a0[9]: Copied! <pre>fruits &gt;&gt; expand(f.type, f.size, full_seq(f.year, 1))\n</pre> fruits &gt;&gt; expand(f.type, f.size, full_seq(f.year, 1)) Out[9]: type size _VAR_2 &lt;object&gt; &lt;category&gt; &lt;int64&gt; 0 apple XS 2010 1 apple XS 2011 2 apple XS 2012 3 apple S 2010 4 apple S 2011 5 apple S 2012 6 apple M 2010 7 apple M 2011 8 apple M 2012 9 apple L 2010 10 apple L 2011 11 apple L 2012 12 orange XS 2010 13 orange XS 2011 14 orange XS 2012 15 orange S 2010 16 orange S 2011 17 orange S 2012 18 orange M 2010 19 orange M 2011 20 orange M 2012 21 orange L 2010 22 orange L 2011 23 orange L 2012 In\u00a0[10]: Copied! <pre>fruits &gt;&gt; expand(f.type, f.size, seq(2010, 2012))\n</pre> fruits &gt;&gt; expand(f.type, f.size, seq(2010, 2012)) Out[10]: type size _VAR_2 &lt;object&gt; &lt;category&gt; &lt;int64&gt; 0 apple XS 2010 1 apple XS 2011 2 apple XS 2012 3 apple S 2010 4 apple S 2011 5 apple S 2012 6 apple M 2010 7 apple M 2011 8 apple M 2012 9 apple L 2010 10 apple L 2011 11 apple L 2012 12 orange XS 2010 13 orange XS 2011 14 orange XS 2012 15 orange S 2010 16 orange S 2011 17 orange S 2012 18 orange M 2010 19 orange M 2011 20 orange M 2012 21 orange L 2010 22 orange L 2011 23 orange L 2012 In\u00a0[11]: Copied! <pre>fruits &gt;&gt; expand(f.type, f.size, year=seq(2010, 2012))\n</pre> fruits &gt;&gt; expand(f.type, f.size, year=seq(2010, 2012)) Out[11]: type size year &lt;object&gt; &lt;category&gt; &lt;int64&gt; 0 apple XS 2010 1 apple XS 2011 2 apple XS 2012 3 apple S 2010 4 apple S 2011 5 apple S 2012 6 apple M 2010 7 apple M 2011 8 apple M 2012 9 apple L 2010 10 apple L 2011 11 apple L 2012 12 orange XS 2010 13 orange XS 2011 14 orange XS 2012 15 orange S 2010 16 orange S 2011 17 orange S 2012 18 orange M 2010 19 orange M 2011 20 orange M 2012 21 orange L 2010 22 orange L 2011 23 orange L 2012 In\u00a0[12]: Copied! <pre>all = fruits &gt;&gt; expand(f.type, f.size, f.year)\nall\n</pre> all = fruits &gt;&gt; expand(f.type, f.size, f.year) all Out[12]: type size year &lt;object&gt; &lt;category&gt; &lt;int64&gt; 0 apple XS 2010 1 apple XS 2012 2 apple S 2010 3 apple S 2012 4 apple M 2010 5 apple M 2012 6 apple L 2010 7 apple L 2012 8 orange XS 2010 9 orange XS 2012 10 orange S 2010 11 orange S 2012 12 orange M 2010 13 orange M 2012 14 orange L 2010 15 orange L 2012 In\u00a0[13]: Copied! <pre>all &gt;&gt; anti_join(fruits)\n</pre> all &gt;&gt; anti_join(fruits) Out[13]: type size year &lt;object&gt; &lt;category&gt; &lt;int64&gt; 1 apple XS 2012 2 apple S 2010 3 apple S 2012 4 apple M 2010 6 apple L 2010 7 apple L 2012 8 orange XS 2010 9 orange XS 2012 13 orange S 2012 14 orange M 2010 16 orange L 2010 17 orange L 2012 In\u00a0[14]: Copied! <pre>fruits &gt;&gt; right_join(all)\n</pre> fruits &gt;&gt; right_join(all) Out[14]: type year size weights &lt;object&gt; &lt;int64&gt; &lt;category&gt; &lt;float64&gt; 0 apple 2010 XS 2.522472 1 apple 2012 XS NaN 2 apple 2010 S NaN 3 apple 2012 S NaN 4 apple 2010 M NaN 5 apple 2012 M -0.667409 6 apple 2010 L NaN 7 apple 2012 L NaN 8 orange 2010 XS NaN 9 orange 2012 XS NaN 10 orange 2010 S 0.206341 11 orange 2010 S 0.887561 12 orange 2010 S -1.317738 13 orange 2012 S NaN 14 orange 2010 M NaN 15 orange 2012 M -0.228718 16 orange 2010 L NaN 17 orange 2012 L NaN"},{"location":"notebooks/expand/#expand","title":"\u2605 expand\u00b6","text":""},{"location":"notebooks/expand/#generates-all-combination-of-variables-found-in-a-dataset","title":"Generates all combination of variables found in a dataset.\u00b6","text":""},{"location":"notebooks/expand/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: A data frame <code>*args</code>: and, <code>**kwargs</code>: columns to expand. Columns can be atomic lists. \u2003\u2003\u2003\u2003- To find all unique combinations of x, y and z, including \u2003\u2003\u2003\u2003\u2003\u2003those not present in the data, supply each variable as a \u2003\u2003\u2003\u2003\u2003\u2003separate argument: <code>expand(df, x, y, z)</code>.</p> <p>\u2003\u2003\u2003\u2003- To find only the combinations that occur in the data, use \u2003\u2003\u2003\u2003\u2003\u2003<code>nesting</code>: <code>expand(df, nesting(x, y, z))</code>.</p> <p>\u2003\u2003\u2003\u2003- You can combine the two forms. For example, \u2003\u2003\u2003\u2003\u2003\u2003<code>expand(df, nesting(school_id, student_id), date)</code> would \u2003\u2003\u2003\u2003\u2003\u2003produce a row for each present school-student combination \u2003\u2003\u2003\u2003\u2003\u2003for all possible dates.</p> <p> <code>_name_repair</code>: treatment of problematic column names: \u2003\u2003\u2003\u2003- \"minimal\": No name repair or checks, beyond basic existence,</p> <p>\u2003\u2003\u2003\u2003- \"unique\": Make sure names are unique and not empty,</p> <p>\u2003\u2003\u2003\u2003- \"check_unique\": (default value), no name repair, \u2003\u2003\u2003\u2003\u2003\u2003but check they are unique,</p> <p>\u2003\u2003\u2003\u2003- \"universal\": Make the names unique and syntactic</p> <p>\u2003\u2003\u2003\u2003- a function: apply custom name repair</p>"},{"location":"notebooks/expand/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with all combination of variables.</p>"},{"location":"notebooks/expand/#nesting","title":"\u2605 nesting\u00b6","text":""},{"location":"notebooks/expand/#a-helper-that-only-finds-combinations-already-present-in-the-data","title":"A helper that only finds combinations already present in the data.\u00b6","text":""},{"location":"notebooks/expand/#args","title":"Args:\u00b6","text":"<p> <code>*args</code>: and, <code>**kwargs</code>: columns to expand. Columns can be atomic lists. \u2003\u2003\u2003\u2003- To find all unique combinations of x, y and z, including \u2003\u2003\u2003\u2003\u2003\u2003those not present in the data, supply each variable as a \u2003\u2003\u2003\u2003\u2003\u2003separate argument: <code>expand(df, x, y, z)</code>.</p> <p>\u2003\u2003\u2003\u2003- To find only the combinations that occur in the data, use \u2003\u2003\u2003\u2003\u2003\u2003<code>nesting</code>: <code>expand(df, nesting(x, y, z))</code>.</p> <p>\u2003\u2003\u2003\u2003- You can combine the two forms. For example, \u2003\u2003\u2003\u2003\u2003\u2003<code>expand(df, nesting(school_id, student_id), date)</code> would \u2003\u2003\u2003\u2003\u2003\u2003produce a row for each present school-student combination \u2003\u2003\u2003\u2003\u2003\u2003for all possible dates.</p> <p> <code>_name_repair</code>: treatment of problematic column names: \u2003\u2003\u2003\u2003- \"minimal\": No name repair or checks, beyond basic existence,</p> <p>\u2003\u2003\u2003\u2003- \"unique\": Make sure names are unique and not empty,</p> <p>\u2003\u2003\u2003\u2003- \"check_unique\": (default value), no name repair, \u2003\u2003\u2003\u2003\u2003\u2003but check they are unique,</p> <p>\u2003\u2003\u2003\u2003- \"universal\": Make the names unique and syntactic</p> <p>\u2003\u2003\u2003\u2003- a function: apply custom name repair</p>"},{"location":"notebooks/expand/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with all combinations in data.</p>"},{"location":"notebooks/expand/#crossing","title":"\u2605 crossing\u00b6","text":""},{"location":"notebooks/expand/#a-wrapper-around-expand_grid-that-de-duplicates-and-sorts-its-inputs","title":"A wrapper around <code>expand_grid()</code> that de-duplicates and sorts its inputs\u00b6","text":"<p>When values are not specified by literal <code>list</code>, they will be sorted.</p>"},{"location":"notebooks/expand/#args","title":"Args:\u00b6","text":"<p> <code>*args</code>: and, <code>**kwargs</code>: columns to expand. Columns can be atomic lists. \u2003\u2003\u2003\u2003- To find all unique combinations of x, y and z, including \u2003\u2003\u2003\u2003\u2003\u2003those not present in the data, supply each variable as a \u2003\u2003\u2003\u2003\u2003\u2003separate argument: <code>expand(df, x, y, z)</code>.</p> <p>\u2003\u2003\u2003\u2003- To find only the combinations that occur in the data, use \u2003\u2003\u2003\u2003\u2003\u2003<code>nesting</code>: <code>expand(df, nesting(x, y, z))</code>.</p> <p>\u2003\u2003\u2003\u2003- You can combine the two forms. For example, \u2003\u2003\u2003\u2003\u2003\u2003<code>expand(df, nesting(school_id, student_id), date)</code> would \u2003\u2003\u2003\u2003\u2003\u2003produce a row for each present school-student combination \u2003\u2003\u2003\u2003\u2003\u2003for all possible dates.</p> <p> <code>_name_repair</code>: treatment of problematic column names: \u2003\u2003\u2003\u2003- \"minimal\": No name repair or checks, beyond basic existence,</p> <p>\u2003\u2003\u2003\u2003- \"unique\": Make sure names are unique and not empty,</p> <p>\u2003\u2003\u2003\u2003- \"check_unique\": (default value), no name repair, \u2003\u2003\u2003\u2003\u2003\u2003but check they are unique,</p> <p>\u2003\u2003\u2003\u2003- \"universal\": Make the names unique and syntactic</p> <p>\u2003\u2003\u2003\u2003- a function: apply custom name repair</p>"},{"location":"notebooks/expand/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with values deduplicated and sorted.</p>"},{"location":"notebooks/expand_grid/","title":"expand_grid","text":"In\u00a0[1]: Copied! <pre># https://tidyr.tidyverse.org/reference/expand_grid.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(expand_grid)\n</pre> # https://tidyr.tidyverse.org/reference/expand_grid.html %run nb_helpers.py  from datar.all import *  nb_header(expand_grid) Try this notebook on binder. In\u00a0[2]: Copied! <pre>expand_grid(x=seq(1,3), y=seq(1,2))\n</pre> expand_grid(x=seq(1,3), y=seq(1,2)) Out[2]: x y &lt;int64&gt; &lt;int64&gt; 0 1 1 1 1 2 2 2 1 3 2 2 4 3 1 5 3 2 In\u00a0[3]: Copied! <pre>expand_grid(l1=letters, l2=LETTERS)\n</pre> expand_grid(l1=letters, l2=LETTERS) Out[3]: l1 l2 &lt;object&gt; &lt;object&gt; 0 a A 1 a B 2 a C 3 a D ... ... ... 4 a E 671 z V 672 z W 673 z X 674 z Y 675 z Z <p>676 rows \u00d7 2 columns</p> In\u00a0[4]: Copied! <pre>expand_grid(df=tibble(x=[1,2], y=c(2, 1)), z=[1,2,3])\n</pre> expand_grid(df=tibble(x=[1,2], y=c(2, 1)), z=[1,2,3]) Out[4]: df$x df$y z &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 1 2 1 1 1 2 2 2 1 2 3 3 2 1 1 4 2 1 2 5 2 1 3 In\u00a0[5]: Copied! <pre>expand_grid(x1=tibble(a=[1,2], b=[3,4]), x2=tibble(a=[5,6], b=[7,8]))\n</pre> expand_grid(x1=tibble(a=[1,2], b=[3,4]), x2=tibble(a=[5,6], b=[7,8])) Out[5]: x1$a x1$b x2$a x2$b &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 1 3 5 7 1 1 3 6 8 2 2 4 5 7 3 2 4 6 8"},{"location":"notebooks/expand_grid/#expand_grid","title":"\u2605 expand_grid\u00b6","text":""},{"location":"notebooks/expand_grid/#expand-a-grid","title":"Expand a grid\u00b6","text":""},{"location":"notebooks/expand_grid/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>*args</code>: Additional numeric vectors <code>**kwargs</code>: Additional keyword arguments</p>"},{"location":"notebooks/expand_grid/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The expanded grid</p>"},{"location":"notebooks/extract/","title":"extract","text":"In\u00a0[1]: Copied! <pre># https://tidyr.tidyverse.org/reference/extract.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(extract)\n</pre> # https://tidyr.tidyverse.org/reference/extract.html %run nb_helpers.py  from datar.all import *  nb_header(extract) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x = c(NA, \"a-b\", \"a-d\", \"b-c\", \"d-e\"))\ndf &gt;&gt; extract(f.x, \"A\")\n</pre> df = tibble(x = c(NA, \"a-b\", \"a-d\", \"b-c\", \"d-e\")) df &gt;&gt; extract(f.x, \"A\") Out[2]: A &lt;object&gt; 0 NaN 1 a 2 a 3 b 4 d In\u00a0[3]: Copied! <pre>df &gt;&gt; extract(f.x, c(\"A\", \"B\"), r\"(\\w+)-(\\w+)\")\n</pre> df &gt;&gt; extract(f.x, c(\"A\", \"B\"), r\"(\\w+)-(\\w+)\") Out[3]: A B &lt;object&gt; &lt;object&gt; 0 NaN NaN 1 a b 2 a d 3 b c 4 d e In\u00a0[4]: Copied! <pre>df &gt;&gt; extract(f.x, c(\"A\", \"B\"), r\"([a-d]+)-([a-d]+)\")\n</pre> df &gt;&gt; extract(f.x, c(\"A\", \"B\"), r\"([a-d]+)-([a-d]+)\") Out[4]: A B &lt;object&gt; &lt;object&gt; 0 NaN NaN 1 a b 2 a d 3 b c 4 NaN NaN In\u00a0[5]: Copied! <pre># combine multiple columns\ndf = tibble(x='abcd')\ndf &gt;&gt; extract(f.x, ['a', 'b', 'a', 'b'], r'(.)(.)(.)(.)')\n</pre> # combine multiple columns df = tibble(x='abcd') df &gt;&gt; extract(f.x, ['a', 'b', 'a', 'b'], r'(.)(.)(.)(.)') Out[5]: a b &lt;object&gt; &lt;object&gt; 0 ac bd"},{"location":"notebooks/extract/#extract","title":"\u2605 extract\u00b6","text":""},{"location":"notebooks/extract/#given-a-regular-expression-with-capturing-groups-extract-turns-each","title":"Given a regular expression with capturing groups, extract() turns each\u00b6","text":"<p>group into a new column. If the groups don't match, or the input is NA, the output will be NA.</p> <p>See https://tidyr.tidyverse.org/reference/extract.html</p>"},{"location":"notebooks/extract/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: The dataframe <code>col</code>: Column name or position. <code>into</code>: Names of new variables to create as character vector. \u2003\u2003\u2003\u2003Use None to omit the variable in the output.</p> <p> <code>regex</code>: a regular expression used to extract the desired values. \u2003\u2003\u2003\u2003There should be one group (defined by ()) for each element of into.</p> <p> <code>remove</code>: If TRUE, remove input column from output data frame. <code>convert</code>: The universal type for the extracted columns or a dict for \u2003\u2003\u2003\u2003individual ones</p>"},{"location":"notebooks/extract/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003Dataframe with extracted columns.</p>"},{"location":"notebooks/fill/","title":"fill","text":"In\u00a0[1]: Copied! <pre># https://tidyr.tidyverse.org/reference/fill.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(fill)\n</pre> # https://tidyr.tidyverse.org/reference/fill.html %run nb_helpers.py  from datar.all import *  nb_header(fill) Try this notebook on binder. In\u00a0[2]: Copied! <pre>sales = tribble(\n  f.quarter, f.year, f.sales,\n  \"Q1\",      2000,   66013,\n  \"Q2\",        NA,   69182,\n  \"Q3\",        NA,   53175,\n  \"Q4\",        NA,   21001,\n  \"Q1\",      2001,   46036,\n  \"Q2\",        NA,   58842,\n  \"Q3\",        NA,   44568,\n  \"Q4\",        NA,   50197,\n  \"Q1\",      2002,   39113,\n  \"Q2\",        NA,   41668,\n  \"Q3\",        NA,   30144,\n  \"Q4\",        NA,   52897,\n  \"Q1\",      2004,   32129,\n  \"Q2\",        NA,   67686,\n  \"Q3\",        NA,   31768,\n  \"Q4\",        NA,   49094\n)\nsales\n</pre> sales = tribble(   f.quarter, f.year, f.sales,   \"Q1\",      2000,   66013,   \"Q2\",        NA,   69182,   \"Q3\",        NA,   53175,   \"Q4\",        NA,   21001,   \"Q1\",      2001,   46036,   \"Q2\",        NA,   58842,   \"Q3\",        NA,   44568,   \"Q4\",        NA,   50197,   \"Q1\",      2002,   39113,   \"Q2\",        NA,   41668,   \"Q3\",        NA,   30144,   \"Q4\",        NA,   52897,   \"Q1\",      2004,   32129,   \"Q2\",        NA,   67686,   \"Q3\",        NA,   31768,   \"Q4\",        NA,   49094 ) sales Out[2]: quarter year sales &lt;object&gt; &lt;float64&gt; &lt;int64&gt; 0 Q1 2000.0 66013 1 Q2 NaN 69182 2 Q3 NaN 53175 3 Q4 NaN 21001 4 Q1 2001.0 46036 5 Q2 NaN 58842 6 Q3 NaN 44568 7 Q4 NaN 50197 8 Q1 2002.0 39113 9 Q2 NaN 41668 10 Q3 NaN 30144 11 Q4 NaN 52897 12 Q1 2004.0 32129 13 Q2 NaN 67686 14 Q3 NaN 31768 15 Q4 NaN 49094 In\u00a0[3]: Copied! <pre>sales &gt;&gt; fill(f.year)\n</pre> sales &gt;&gt; fill(f.year) Out[3]: quarter year sales &lt;object&gt; &lt;float64&gt; &lt;int64&gt; 0 Q1 2000.0 66013 1 Q2 2000.0 69182 2 Q3 2000.0 53175 3 Q4 2000.0 21001 4 Q1 2001.0 46036 5 Q2 2001.0 58842 6 Q3 2001.0 44568 7 Q4 2001.0 50197 8 Q1 2002.0 39113 9 Q2 2002.0 41668 10 Q3 2002.0 30144 11 Q4 2002.0 52897 12 Q1 2004.0 32129 13 Q2 2004.0 67686 14 Q3 2004.0 31768 15 Q4 2004.0 49094 In\u00a0[4]: Copied! <pre>tidy_pets = tribble(\n  f.rank,  f.pet_type, f.breed,\n  1,          NA,      \"Boston Terrier\",\n  2,          NA,      \"Retrievers (Labrador)\",\n  3,          NA,      \"Retrievers (Golden)\",\n  4,          NA,      \"French Bulldogs\",\n  5,          NA,      \"Bulldogs\",\n  6,       \"Dog\",      \"Beagles\",\n  1,          NA,      \"Persian\",\n  2,          NA,      \"Maine Coon\",\n  3,          NA,      \"Ragdoll\",\n  4,          NA,      \"Exotic\",\n  5,          NA,      \"Siamese\",\n  6,       \"Cat\",      \"American Short\"\n)\ntidy_pets &gt;&gt; fill(f.pet_type, _direction = \"up\")\n</pre> tidy_pets = tribble(   f.rank,  f.pet_type, f.breed,   1,          NA,      \"Boston Terrier\",   2,          NA,      \"Retrievers (Labrador)\",   3,          NA,      \"Retrievers (Golden)\",   4,          NA,      \"French Bulldogs\",   5,          NA,      \"Bulldogs\",   6,       \"Dog\",      \"Beagles\",   1,          NA,      \"Persian\",   2,          NA,      \"Maine Coon\",   3,          NA,      \"Ragdoll\",   4,          NA,      \"Exotic\",   5,          NA,      \"Siamese\",   6,       \"Cat\",      \"American Short\" ) tidy_pets &gt;&gt; fill(f.pet_type, _direction = \"up\") Out[4]: rank pet_type breed &lt;int64&gt; &lt;object&gt; &lt;object&gt; 0 1 Dog Boston Terrier 1 2 Dog Retrievers (Labrador) 2 3 Dog Retrievers (Golden) 3 4 Dog French Bulldogs 4 5 Dog Bulldogs 5 6 Dog Beagles 6 1 Cat Persian 7 2 Cat Maine Coon 8 3 Cat Ragdoll 9 4 Cat Exotic 10 5 Cat Siamese 11 6 Cat American Short In\u00a0[5]: Copied! <pre>squirrels = tribble(\n  f.group,    f.name,        f.role, f.n_squirrels,\n  1,           \"Sam\",    \"Observer\",            NA,\n  1,          \"Mara\", \"Scorekeeper\",             8,\n  1,         \"Jesse\",    \"Observer\",            NA,\n  1,           \"Tom\",    \"Observer\",            NA,\n  2,          \"Mike\",    \"Observer\",            NA,\n  2,       \"Rachael\",    \"Observer\",            NA,\n  2,       \"Sydekea\", \"Scorekeeper\",            14,\n  2,      \"Gabriela\",    \"Observer\",            NA,\n  3,       \"Derrick\",    \"Observer\",            NA,\n  3,          \"Kara\", \"Scorekeeper\",             9,\n  3,         \"Emily\",    \"Observer\",            NA,\n  3,      \"Danielle\",    \"Observer\",            NA\n)\n        \nsquirrels &gt;&gt; \\\n  group_by(f.group) &gt;&gt; \\\n  fill(f.n_squirrels, _direction = \"downup\") \n</pre> squirrels = tribble(   f.group,    f.name,        f.role, f.n_squirrels,   1,           \"Sam\",    \"Observer\",            NA,   1,          \"Mara\", \"Scorekeeper\",             8,   1,         \"Jesse\",    \"Observer\",            NA,   1,           \"Tom\",    \"Observer\",            NA,   2,          \"Mike\",    \"Observer\",            NA,   2,       \"Rachael\",    \"Observer\",            NA,   2,       \"Sydekea\", \"Scorekeeper\",            14,   2,      \"Gabriela\",    \"Observer\",            NA,   3,       \"Derrick\",    \"Observer\",            NA,   3,          \"Kara\", \"Scorekeeper\",             9,   3,         \"Emily\",    \"Observer\",            NA,   3,      \"Danielle\",    \"Observer\",            NA )          squirrels &gt;&gt; \\   group_by(f.group) &gt;&gt; \\   fill(f.n_squirrels, _direction = \"downup\")  Out[5]: group name role n_squirrels &lt;int64&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; 0 1 Sam Observer 8.0 1 1 Mara Scorekeeper 8.0 2 1 Jesse Observer 8.0 3 1 Tom Observer 8.0 4 2 Mike Observer 14.0 5 2 Rachael Observer 14.0 6 2 Sydekea Scorekeeper 14.0 7 2 Gabriela Observer 14.0 8 3 Derrick Observer 9.0 9 3 Kara Scorekeeper 9.0 10 3 Emily Observer 9.0 11 3 Danielle Observer 9.0 <p>TibbleGrouped: group (n=3) </p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/fill/#fill","title":"\u2605 fill\u00b6","text":""},{"location":"notebooks/fill/#fills-missing-values-in-selected-columns-using-the-next-or","title":"Fills missing values in selected columns using the next or\u00b6","text":"<p>previous entry.</p> <p>See https://tidyr.tidyverse.org/reference/fill.html</p>"},{"location":"notebooks/fill/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A dataframe <code>*columns</code>: Columns to fill <code>_direction</code>: Direction in which to fill missing values. \u2003\u2003\u2003\u2003Currently either \"down\" (the default), \"up\", \u2003\u2003\u2003\u2003\"downup\" (i.e. first down and then up) or \u2003\u2003\u2003\u2003\"updown\" (first up and then down).</p>"},{"location":"notebooks/fill/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The dataframe with NAs being replaced.</p>"},{"location":"notebooks/filter-joins/","title":"filter-joins","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/filter-joins.html\n%run nb_helpers.py\n\nfrom datar.data import band_members, band_instruments\nfrom datar.all import *\n\nnb_header(semi_join, anti_join, book='filter-joins')\n</pre> # https://dplyr.tidyverse.org/reference/filter-joins.html %run nb_helpers.py  from datar.data import band_members, band_instruments from datar.all import *  nb_header(semi_join, anti_join, book='filter-joins') Try this notebook on binder. In\u00a0[2]: Copied! <pre>band_members\n</pre> band_members Out[2]: name band &lt;object&gt; &lt;object&gt; 0 Mick Stones 1 John Beatles 2 Paul Beatles In\u00a0[3]: Copied! <pre>band_instruments\n</pre> band_instruments Out[3]: name plays &lt;object&gt; &lt;object&gt; 0 John guitar 1 Paul bass 2 Keith guitar In\u00a0[4]: Copied! <pre>band_members &gt;&gt; semi_join(band_instruments)\n</pre> band_members &gt;&gt; semi_join(band_instruments) Out[4]: name band &lt;object&gt; &lt;object&gt; 1 John Beatles 2 Paul Beatles In\u00a0[5]: Copied! <pre>band_members &gt;&gt; anti_join(band_instruments, by={'name': 'name'})\n</pre> band_members &gt;&gt; anti_join(band_instruments, by={'name': 'name'}) Out[5]: name band &lt;object&gt; &lt;object&gt; 0 Mick Stones"},{"location":"notebooks/filter-joins/#semi_join","title":"\u2605 semi_join\u00b6","text":""},{"location":"notebooks/filter-joins/#semi-join-two-data-frames-by-matching-rows","title":"Semi join two data frames by matching rows.\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/join.html</p>"},{"location":"notebooks/filter-joins/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame <code>by</code>: A list of column names to join by. \u2003\u2003\u2003\u2003If None, use the intersection of the columns of x and y.</p> <p> <code>copy</code>: If True, always copy the data.</p>"},{"location":"notebooks/filter-joins/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame</p>"},{"location":"notebooks/filter-joins/#anti_join","title":"\u2605 anti_join\u00b6","text":""},{"location":"notebooks/filter-joins/#anti-join-two-data-frames-by-matching-rows","title":"Anti join two data frames by matching rows.\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/join.html</p>"},{"location":"notebooks/filter-joins/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame <code>by</code>: A list of column names to join by. \u2003\u2003\u2003\u2003If None, use the intersection of the columns of x and y.</p> <p> <code>copy</code>: If True, always copy the data.</p>"},{"location":"notebooks/filter-joins/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame</p>"},{"location":"notebooks/filter/","title":"filter","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/filter.html\n%run nb_helpers.py\nfrom datar.data import starwars\nfrom datar.all import *\n\nnb_header(filter)\n</pre> # https://dplyr.tidyverse.org/reference/filter.html %run nb_helpers.py from datar.data import starwars from datar.all import *  nb_header(filter) Try this notebook on binder. In\u00a0[2]: Copied! <pre>filter(starwars, f.species == \"Human\")\n</pre> filter(starwars, f.species == \"Human\") Out[2]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Luke Skywalker 172.0 77.0 blond fair blue 19.0 male masculine Tatooine Human 3 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human 4 Leia Organa 150.0 49.0 brown light brown 19.0 female feminine Alderaan Human 5 Owen Lars 178.0 120.0 brown, grey light blue 52.0 male masculine Tatooine Human 6 Beru Whitesun lars 165.0 75.0 brown light blue 47.0 female feminine Tatooine Human 8 Biggs Darklighter 183.0 84.0 black light brown 24.0 male masculine Tatooine Human 9 Obi-Wan Kenobi 182.0 77.0 auburn, white fair blue-gray 57.0 male masculine Stewjon Human 10 Anakin Skywalker 188.0 84.0 blond fair blue 41.9 male masculine Tatooine Human 11 Wilhuff Tarkin 180.0 NaN auburn, grey fair blue 64.0 male masculine Eriadu Human 13 Han Solo 180.0 80.0 brown fair brown 29.0 male masculine Corellia Human 16 Wedge Antilles 170.0 77.0 brown fair hazel 21.0 male masculine Corellia Human 17 Jek Tono Porkins 180.0 110.0 brown fair blue NaN male masculine Bestine IV Human 19 Palpatine 170.0 75.0 grey pale yellow 82.0 male masculine Naboo Human 20 Boba Fett 183.0 78.2 black fair brown 31.5 male masculine Kamino Human 23 Lando Calrissian 177.0 79.0 black dark brown 31.0 male masculine Socorro Human 24 Lobot 175.0 79.0 none light blue 37.0 male masculine Bespin Human 26 Mon Mothma 150.0 NaN auburn fair blue 48.0 female feminine Chandrila Human 27 Arvel Crynyd NaN NaN brown fair brown NaN male masculine NaN Human 30 Qui-Gon Jinn 193.0 89.0 brown fair blue 92.0 male masculine NaN Human 32 Finis Valorum 170.0 NaN blond fair blue 91.0 male masculine Coruscant Human 40 Shmi Skywalker 163.0 NaN black fair brown 72.0 female feminine Tatooine Human 47 Mace Windu 188.0 84.0 none dark brown 72.0 male masculine Haruun Kal Human 56 Gregar Typho 185.0 85.0 black dark brown NaN male masculine Naboo Human 57 Cord\u00e9 157.0 NaN brown light brown NaN female feminine Naboo Human 58 Cliegg Lars 183.0 NaN brown fair blue 82.0 male masculine Tatooine Human 62 Dorm\u00e9 165.0 NaN brown light brown NaN female feminine Naboo Human 63 Dooku 193.0 80.0 white fair brown 102.0 male masculine Serenno Human 64 Bail Prestor Organa 191.0 NaN black tan brown 67.0 male masculine Alderaan Human 65 Jango Fett 183.0 79.0 black tan brown 66.0 male masculine Concord Dawn Human 70 Jocasta Nu 167.0 NaN white fair blue NaN female feminine Coruscant Human 78 Raymus Antilles 188.0 79.0 brown light brown NaN male masculine Alderaan Human 81 Finn NaN NaN black dark dark NaN male masculine NaN Human 82 Rey NaN NaN brown light hazel NaN female feminine NaN Human 83 Poe Dameron NaN NaN brown light brown NaN male masculine NaN Human 86 Padm\u00e9 Amidala 165.0 45.0 brown light brown 46.0 female feminine Naboo Human In\u00a0[3]: Copied! <pre>filter(starwars, f.mass &gt; 1000)\n</pre> filter(starwars, f.mass &gt; 1000) Out[3]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 15 Jabba Desilijic Tiure 175.0 1358.0 NaN green-tan, brown orange 600.0 hermaphroditic masculine Nal Hutta Hutt In\u00a0[4]: Copied! <pre># Conditions connected by &amp; or | have to wrapped, since == has lower priority than &amp; does\nfilter(starwars, (f.hair_color == \"none\") &amp; (f.eye_color == \"black\"))\n</pre> # Conditions connected by &amp; or | have to wrapped, since == has lower priority than &amp; does filter(starwars, (f.hair_color == \"none\") &amp; (f.eye_color == \"black\")) Out[4]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 29 Nien Nunb 160.0 68.0 none grey black NaN male masculine Sullust Sullustan 45 Gasgano 122.0 NaN none white, blue black NaN male masculine Troiken Xexto 49 Kit Fisto 196.0 87.0 none green black NaN male masculine Glee Anselm Nautolan 54 Plo Koon 188.0 80.0 none orange black 22.0 male masculine Dorin Kel Dor 68 Lama Su 229.0 88.0 none grey black NaN male masculine Kamino Kaminoan 69 Taun We 213.0 NaN none grey black NaN female feminine Kamino Kaminoan 75 Shaak Ti 178.0 57.0 none red, blue, white black NaN female feminine Shili Togruta 80 Tion Medon 206.0 80.0 none grey black NaN male masculine Utapau Pau'an 84 BB8 NaN NaN none none black NaN none masculine NaN Droid In\u00a0[5]: Copied! <pre>filter(starwars, (f.hair_color == \"none\") | (f.eye_color == \"black\"))\n</pre> filter(starwars, (f.hair_color == \"none\") | (f.eye_color == \"black\")) Out[5]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 3 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human 14 Greedo 173.0 74.0 NaN green black 44.0 male masculine Rodia Rodian 21 IG-88 200.0 140.0 none metal red 15.0 none masculine NaN Droid 22 Bossk 190.0 113.0 none green red 53.0 male masculine Trandosha Trandoshan 24 Lobot 175.0 79.0 none light blue 37.0 male masculine Bespin Human 25 Ackbar 180.0 83.0 none brown mottle orange 41.0 male masculine Mon Cala Mon Calamari 29 Nien Nunb 160.0 68.0 none grey black NaN male masculine Sullust Sullustan 31 Nute Gunray 191.0 90.0 none mottled green red NaN male masculine Cato Neimoidia Neimodian 33 Jar Jar Binks 196.0 66.0 none orange orange 52.0 male masculine Naboo Gungan 34 Roos Tarpals 224.0 82.0 none grey orange NaN male masculine Naboo Gungan 35 Rugor Nass 206.0 NaN none green orange NaN male masculine Naboo Gungan 38 Sebulba 112.0 40.0 none grey, red orange NaN male masculine Malastare Dug 41 Darth Maul 175.0 80.0 none red yellow 54.0 male masculine Dathomir Zabrak 42 Bib Fortuna 180.0 NaN none pale pink NaN male masculine Ryloth Twi'lek 43 Ayla Secura 178.0 55.0 none blue hazel 48.0 female feminine Ryloth Twi'lek 44 Dud Bolt 94.0 45.0 none blue, grey yellow NaN male masculine Vulpter Vulptereen 45 Gasgano 122.0 NaN none white, blue black NaN male masculine Troiken Xexto 46 Ben Quadinaros 163.0 65.0 none grey, green, yellow orange NaN male masculine Tund Toong 47 Mace Windu 188.0 84.0 none dark brown 72.0 male masculine Haruun Kal Human 49 Kit Fisto 196.0 87.0 none green black NaN male masculine Glee Anselm Nautolan 51 Adi Gallia 184.0 50.0 none dark blue NaN female feminine Coruscant Tholothian 52 Saesee Tiin 188.0 NaN none pale orange NaN male masculine Iktotch Iktotchi 53 Yarael Poof 264.0 NaN none white yellow NaN male masculine Quermia Quermian 54 Plo Koon 188.0 80.0 none orange black 22.0 male masculine Dorin Kel Dor 55 Mas Amedda 196.0 NaN none blue blue NaN male masculine Champala Chagrian 59 Poggle the Lesser 183.0 80.0 none green yellow NaN male masculine Geonosis Geonosian 67 Dexter Jettster 198.0 102.0 none brown yellow NaN male masculine Ojom Besalisk 68 Lama Su 229.0 88.0 none grey black NaN male masculine Kamino Kaminoan 69 Taun We 213.0 NaN none grey black NaN female feminine Kamino Kaminoan 71 Ratts Tyerell 79.0 15.0 none grey, blue unknown NaN male masculine Aleen Minor Aleena 72 R4-P17 96.0 NaN none silver, red red, blue NaN none feminine NaN Droid 73 Wat Tambor 193.0 48.0 none green, grey unknown NaN male masculine Skako Skakoan 74 San Hill 191.0 NaN none grey gold NaN male masculine Muunilinst Muun 75 Shaak Ti 178.0 57.0 none red, blue, white black NaN female feminine Shili Togruta 76 Grievous 216.0 159.0 none brown, white green, yellow NaN male masculine Kalee Kaleesh 79 Sly Moore 178.0 48.0 none pale white NaN NaN NaN Umbara NaN 80 Tion Medon 206.0 80.0 none grey black NaN male masculine Utapau Pau'an 84 BB8 NaN NaN none none black NaN none masculine NaN Droid In\u00a0[6]: Copied! <pre>filter(starwars, f.hair_color == \"none\", f.eye_color == \"black\")\n</pre> filter(starwars, f.hair_color == \"none\", f.eye_color == \"black\") Out[6]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 29 Nien Nunb 160.0 68.0 none grey black NaN male masculine Sullust Sullustan 45 Gasgano 122.0 NaN none white, blue black NaN male masculine Troiken Xexto 49 Kit Fisto 196.0 87.0 none green black NaN male masculine Glee Anselm Nautolan 54 Plo Koon 188.0 80.0 none orange black 22.0 male masculine Dorin Kel Dor 68 Lama Su 229.0 88.0 none grey black NaN male masculine Kamino Kaminoan 69 Taun We 213.0 NaN none grey black NaN female feminine Kamino Kaminoan 75 Shaak Ti 178.0 57.0 none red, blue, white black NaN female feminine Shili Togruta 80 Tion Medon 206.0 80.0 none grey black NaN male masculine Utapau Pau'an 84 BB8 NaN NaN none none black NaN none masculine NaN Droid In\u00a0[8]: Copied! <pre>starwars &gt;&gt; filter(f.mass &gt; mean(f.mass))\n</pre> starwars &gt;&gt; filter(f.mass &gt; mean(f.mass)) Out[8]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 3 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human 5 Owen Lars 178.0 120.0 brown, grey light blue 52.0 male masculine Tatooine Human 12 Chewbacca 228.0 112.0 brown unknown blue 200.0 male masculine Kashyyyk Wookiee 15 Jabba Desilijic Tiure 175.0 1358.0 NaN green-tan, brown orange 600.0 hermaphroditic masculine Nal Hutta Hutt 17 Jek Tono Porkins 180.0 110.0 brown fair blue NaN male masculine Bestine IV Human 21 IG-88 200.0 140.0 none metal red 15.0 none masculine NaN Droid 22 Bossk 190.0 113.0 none green red 53.0 male masculine Trandosha Trandoshan 67 Dexter Jettster 198.0 102.0 none brown yellow NaN male masculine Ojom Besalisk 76 Grievous 216.0 159.0 none brown, white green, yellow NaN male masculine Kalee Kaleesh 77 Tarfful 234.0 136.0 brown brown blue NaN male masculine Kashyyyk Wookiee In\u00a0[\u00a0]: Copied! <pre>starwars &gt;&gt; group_by(f.gender) &gt;&gt; filter(f.mass &gt; mean(f.mass, na_rm=True))\n</pre> starwars &gt;&gt; group_by(f.gender) &gt;&gt; filter(f.mass &gt; mean(f.mass, na_rm=True)) Out[\u00a0]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human 1 Owen Lars 178.0 120.0 brown, grey light blue 52.0 male masculine Tatooine Human 2 Beru Whitesun lars 165.0 75.0 brown light blue 47.0 female feminine Tatooine Human 3 Chewbacca 228.0 112.0 brown unknown blue 200.0 male masculine Kashyyyk Wookiee 4 Jabba Desilijic Tiure 175.0 1358.0 NaN green-tan, brown orange 600.0 hermaphroditic masculine Nal Hutta Hutt 5 Jek Tono Porkins 180.0 110.0 brown fair blue NaN male masculine Bestine IV Human 6 IG-88 200.0 140.0 none metal red 15.0 none masculine NaN Droid 7 Bossk 190.0 113.0 none green red 53.0 male masculine Trandosha Trandoshan 8 Ayla Secura 178.0 55.0 none blue hazel 48.0 female feminine Ryloth Twi'lek 9 Luminara Unduli 170.0 56.2 black yellow blue 58.0 female feminine Mirial Mirialan 10 Zam Wesell 168.0 55.0 blonde fair, green, yellow yellow NaN female feminine Zolan Clawdite 11 Shaak Ti 178.0 57.0 none red, blue, white black NaN female feminine Shili Togruta 12 Grievous 216.0 159.0 none brown, white green, yellow NaN male masculine Kalee Kaleesh 13 Tarfful 234.0 136.0 brown brown blue NaN male masculine Kashyyyk Wookiee <p>TibbleGrouped: gender (n=2) </p> In\u00a0[\u00a0]: Copied! <pre># To refer to column names that are stored as strings, use `f[...]`:\nvars = c(\"mass\", \"height\")\ncond = c(80, 150)\nstarwars &gt;&gt; \\\n  filter(\n    f[vars[0]] &gt; cond[0],\n    f[vars[1]] &gt; cond[1]\n  )\n</pre> # To refer to column names that are stored as strings, use `f[...]`: vars = c(\"mass\", \"height\") cond = c(80, 150) starwars &gt;&gt; \\   filter(     f[vars[0]] &gt; cond[0],     f[vars[1]] &gt; cond[1]   ) Out[\u00a0]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 3 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human 5 Owen Lars 178.0 120.0 brown, grey light blue 52.0 male masculine Tatooine Human 8 Biggs Darklighter 183.0 84.0 black light brown 24.0 male masculine Tatooine Human 10 Anakin Skywalker 188.0 84.0 blond fair blue 41.9 male masculine Tatooine Human 12 Chewbacca 228.0 112.0 brown unknown blue 200.0 male masculine Kashyyyk Wookiee 15 Jabba Desilijic Tiure 175.0 1358.0 NaN green-tan, brown orange 600.0 hermaphroditic masculine Nal Hutta Hutt 17 Jek Tono Porkins 180.0 110.0 brown fair blue NaN male masculine Bestine IV Human 21 IG-88 200.0 140.0 none metal red 15.0 none masculine NaN Droid 22 Bossk 190.0 113.0 none green red 53.0 male masculine Trandosha Trandoshan 25 Ackbar 180.0 83.0 none brown mottle orange 41.0 male masculine Mon Cala Mon Calamari 30 Qui-Gon Jinn 193.0 89.0 brown fair blue 92.0 male masculine NaN Human 31 Nute Gunray 191.0 90.0 none mottled green red NaN male masculine Cato Neimoidia Neimodian 34 Roos Tarpals 224.0 82.0 none grey orange NaN male masculine Naboo Gungan 47 Mace Windu 188.0 84.0 none dark brown 72.0 male masculine Haruun Kal Human 48 Ki-Adi-Mundi 198.0 82.0 white pale yellow 92.0 male masculine Cerea Cerean 49 Kit Fisto 196.0 87.0 none green black NaN male masculine Glee Anselm Nautolan 56 Gregar Typho 185.0 85.0 black dark brown NaN male masculine Naboo Human 67 Dexter Jettster 198.0 102.0 none brown yellow NaN male masculine Ojom Besalisk 68 Lama Su 229.0 88.0 none grey black NaN male masculine Kamino Kaminoan 76 Grievous 216.0 159.0 none brown, white green, yellow NaN male masculine Kalee Kaleesh 77 Tarfful 234.0 136.0 brown brown blue NaN male masculine Kashyyyk Wookiee"},{"location":"notebooks/filter/#filter_","title":"\u2605 filter_\u00b6","text":""},{"location":"notebooks/filter/#filter-a-data-frame-based-on-conditions","title":"Filter a data frame based on conditions\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/filter.html</p>"},{"location":"notebooks/filter/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>*conditions</code>: Conditions to filter by. <code>_preserve</code>: If <code>True</code>, keep grouping variables even if they are not used.</p>"},{"location":"notebooks/filter/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The subset dataframe</p>"},{"location":"notebooks/forcats_fct_multi/","title":"forcats_fct_multi","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\nfrom datar.all import *\n\nnb_header(\n    fct_c,\n    fct_cross,\n    book=\"forcat_fct_multi\",\n)\n</pre> %run nb_helpers.py from datar.all import *  nb_header(     fct_c,     fct_cross,     book=\"forcat_fct_multi\", )  Try this notebook on binder. In\u00a0[2]: Copied! <pre>fa = factor(\"a\")\nfb = factor(\"b\")\nfab = factor(c(\"a\", \"b\"))\n\n# c(fa, fb, fab)\n# convert factor to integer for `c`?\n</pre> fa = factor(\"a\") fb = factor(\"b\") fab = factor(c(\"a\", \"b\"))  # c(fa, fb, fab) # convert factor to integer for `c`? In\u00a0[3]: Copied! <pre>fct_c(fa, fb, fab)\n</pre> fct_c(fa, fb, fab) Out[3]: <pre>['a', 'b', 'a', 'b']\nCategories (2, object): ['a', 'b']</pre> In\u00a0[4]: Copied! <pre>fs = [fa, fb, fab]\nfct_c(*fs)\n</pre> fs = [fa, fb, fab] fct_c(*fs) Out[4]: <pre>['a', 'b', 'a', 'b']\nCategories (2, object): ['a', 'b']</pre> In\u00a0[5]: Copied! <pre>fruit = factor(c(\"apple\", \"kiwi\", \"apple\", \"apple\"))\ncolour = factor(c(\"green\", \"green\", \"red\", \"green\"))\neaten = c(\"yes\", \"no\", \"yes\", \"no\")\nfct_cross(fruit, colour)\n</pre> fruit = factor(c(\"apple\", \"kiwi\", \"apple\", \"apple\")) colour = factor(c(\"green\", \"green\", \"red\", \"green\")) eaten = c(\"yes\", \"no\", \"yes\", \"no\") fct_cross(fruit, colour) Out[5]: <pre>['apple:green', 'kiwi:green', 'apple:red', 'apple:green']\nCategories (3, object): ['apple:green', 'apple:red', 'kiwi:green']</pre> In\u00a0[6]: Copied! <pre>fct_cross(fruit, colour, eaten)\n</pre> fct_cross(fruit, colour, eaten) Out[6]: <pre>['apple:green:yes', 'kiwi:green:no', 'apple:red:yes', 'apple:green:no']\nCategories (4, object): ['apple:green:no', 'apple:green:yes', 'apple:red:yes', 'kiwi:green:no']</pre> In\u00a0[7]: Copied! <pre>fct_cross(fruit, colour, keep_empty = TRUE)\n</pre> fct_cross(fruit, colour, keep_empty = TRUE) Out[7]: <pre>['apple:green', 'kiwi:green', 'apple:red', 'apple:green']\nCategories (4, object): ['apple:green', 'apple:red', 'kiwi:green', 'kiwi:red']</pre>"},{"location":"notebooks/forcats_fct_multi/#fct_c","title":"\u2605 fct_c\u00b6","text":""},{"location":"notebooks/forcats_fct_multi/#concatenate-factors-combining-levels","title":"Concatenate factors, combining levels\u00b6","text":"<p>This is a useful ways of patching together factors from multiple sources that really should have the same levels but don't.</p>"},{"location":"notebooks/forcats_fct_multi/#args","title":"Args:\u00b6","text":"<p> <code>*fs</code>: factors to concatenate</p>"},{"location":"notebooks/forcats_fct_multi/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The concatenated factor</p>"},{"location":"notebooks/forcats_fct_multi/#fct_cross","title":"\u2605 fct_cross\u00b6","text":""},{"location":"notebooks/forcats_fct_multi/#combine-levels-from-two-or-more-factors-to-create-a-new-factor","title":"Combine levels from two or more factors to create a new factor\u00b6","text":"<p>Computes a factor whose levels are all the combinations of the levels of the input factors.</p>"},{"location":"notebooks/forcats_fct_multi/#args","title":"Args:\u00b6","text":"<p> <code>*fs</code>: factors to cross <code>sep</code>: A string to separate levels <code>keep_empty</code>: If True, keep combinations with no observations as levels</p>"},{"location":"notebooks/forcats_fct_multi/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The new factor</p>"},{"location":"notebooks/forcats_fct_multi/#fct_c","title":"fct_c\u00b6","text":""},{"location":"notebooks/forcats_fct_multi/#fct_cross","title":"fct_cross\u00b6","text":""},{"location":"notebooks/forcats_lvl_addrm/","title":"forcats_lvl_addrm","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\nfrom datar.all import *\n\nnb_header(\n    fct_expand,\n    fct_explicit_na,\n    fct_drop,\n    fct_unify,\n    book=\"forcat_lvl_addrm\",\n)\n</pre> %run nb_helpers.py from datar.all import *  nb_header(     fct_expand,     fct_explicit_na,     fct_drop,     fct_unify,     book=\"forcat_lvl_addrm\", )  Try this notebook on binder. In\u00a0[2]: Copied! <pre>fct = factor(sample(letters[:3], 20, replace = TRUE))\nfct\n</pre> fct = factor(sample(letters[:3], 20, replace = TRUE)) fct Out[2]: <pre>['c', 'c', 'b', 'c', 'a', ..., 'b', 'c', 'b', 'b', 'c']\nLength: 20\nCategories (3, object): ['a', 'b', 'c']</pre> In\u00a0[3]: Copied! <pre>fct_expand(fct, \"d\", \"e\", \"f\")\n</pre> fct_expand(fct, \"d\", \"e\", \"f\") Out[3]: <pre>['c', 'c', 'b', 'c', 'a', ..., 'b', 'c', 'b', 'b', 'c']\nLength: 20\nCategories (6, object): ['a', 'b', 'c', 'd', 'e', 'f']</pre> In\u00a0[4]: Copied! <pre>fct_expand(fct, letters[:6])\n</pre> fct_expand(fct, letters[:6]) Out[4]: <pre>['c', 'c', 'b', 'c', 'a', ..., 'b', 'c', 'b', 'b', 'c']\nLength: 20\nCategories (6, object): ['a', 'b', 'c', 'd', 'e', 'f']</pre> In\u00a0[5]: Copied! <pre>f1 = factor(c(\"a\", \"a\", NA, NA, \"a\", \"b\", NA, \"c\", \"a\", \"c\", \"b\"))\nfct_count(f1)\n</pre> f1 = factor(c(\"a\", \"a\", NA, NA, \"a\", \"b\", NA, \"c\", \"a\", \"c\", \"b\")) fct_count(f1) Out[5]: f n &lt;category&gt; &lt;float64&gt; 0 a 4.0 1 b 2.0 2 c 2.0 3 NaN 3.0 In\u00a0[6]: Copied! <pre>f2 = fct_explicit_na(f1)\nfct_count(f2)\n</pre> f2 = fct_explicit_na(f1) fct_count(f2) Out[6]: f n &lt;category&gt; &lt;int64&gt; 0 a 4 1 b 2 2 c 2 3 (Missing) 3 In\u00a0[7]: Copied! <pre>fct = factor(c(\"a\", \"b\"), levels = c(\"a\", \"b\", \"c\"))\nfct\n</pre> fct = factor(c(\"a\", \"b\"), levels = c(\"a\", \"b\", \"c\")) fct Out[7]: <pre>['a', 'b']\nCategories (3, object): ['a', 'b', 'c']</pre> In\u00a0[8]: Copied! <pre>fct_drop(fct)\n</pre> fct_drop(fct) Out[8]: <pre>['a', 'b']\nCategories (2, object): ['a', 'b']</pre> In\u00a0[9]: Copied! <pre>fct_drop(fct, only = \"a\")\n</pre> fct_drop(fct, only = \"a\") Out[9]: <pre>['a', 'b']\nCategories (3, object): ['a', 'b', 'c']</pre> In\u00a0[10]: Copied! <pre>fct_drop(fct, only = \"c\")\n</pre> fct_drop(fct, only = \"c\") Out[10]: <pre>['a', 'b']\nCategories (2, object): ['a', 'b']</pre> In\u00a0[11]: Copied! <pre>fs = [factor(\"a\"), factor(\"b\"), factor(c(\"a\", \"b\"))]\nfct_unify(fs)\n</pre> fs = [factor(\"a\"), factor(\"b\"), factor(c(\"a\", \"b\"))] fct_unify(fs) Out[11]: <pre>[['a']\n Categories (2, object): ['a', 'b'],\n ['b']\n Categories (2, object): ['a', 'b'],\n ['a', 'b']\n Categories (2, object): ['a', 'b']]</pre>"},{"location":"notebooks/forcats_lvl_addrm/#fct_expand","title":"\u2605 fct_expand\u00b6","text":""},{"location":"notebooks/forcats_lvl_addrm/#add-additional-levels-to-a-factor","title":"Add additional levels to a factor\u00b6","text":""},{"location":"notebooks/forcats_lvl_addrm/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>*additional_levels</code>: Additional levels to add to the factor. \u2003\u2003\u2003\u2003Levels that already exist will be silently ignored.</p>"},{"location":"notebooks/forcats_lvl_addrm/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels expanded</p>"},{"location":"notebooks/forcats_lvl_addrm/#fct_explicit_na","title":"\u2605 fct_explicit_na\u00b6","text":""},{"location":"notebooks/forcats_lvl_addrm/#make-missing-values-explicit","title":"Make missing values explicit\u00b6","text":"<p>This gives missing values an explicit factor level, ensuring that they appear in summaries and on plots.</p>"},{"location":"notebooks/forcats_lvl_addrm/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>na_level</code>: Level to use for missing values. \u2003\u2003\u2003\u2003This is what NAs will be changed to.</p>"},{"location":"notebooks/forcats_lvl_addrm/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with explict na_levels</p>"},{"location":"notebooks/forcats_lvl_addrm/#fct_drop","title":"\u2605 fct_drop\u00b6","text":""},{"location":"notebooks/forcats_lvl_addrm/#drop-unused-levels","title":"Drop unused levels\u00b6","text":""},{"location":"notebooks/forcats_lvl_addrm/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>only</code>: A character vector restricting the set of levels to be dropped. \u2003\u2003\u2003\u2003If supplied, only levels that have no entries and appear in \u2003\u2003\u2003\u2003this vector will be removed.</p>"},{"location":"notebooks/forcats_lvl_addrm/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with unused levels dropped</p>"},{"location":"notebooks/forcats_lvl_addrm/#fct_unify","title":"\u2605 fct_unify\u00b6","text":""},{"location":"notebooks/forcats_lvl_addrm/#unify-the-levels-in-a-list-of-factors","title":"Unify the levels in a list of factors\u00b6","text":""},{"location":"notebooks/forcats_lvl_addrm/#args","title":"Args:\u00b6","text":"<p> <code>fs</code>: A list of factors <code>levels</code>: Set of levels to apply to every factor. Default to union \u2003\u2003\u2003\u2003of all factor levels</p>"},{"location":"notebooks/forcats_lvl_addrm/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A list of factors with the levels expanded</p>"},{"location":"notebooks/forcats_lvl_addrm/#fct_expand","title":"fct_expand\u00b6","text":""},{"location":"notebooks/forcats_lvl_addrm/#fct_explicit_na","title":"fct_explicit_na\u00b6","text":""},{"location":"notebooks/forcats_lvl_addrm/#fct_drop","title":"fct_drop\u00b6","text":""},{"location":"notebooks/forcats_lvl_addrm/#fct_unify","title":"fct_unify\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/","title":"forcats_lvl_order","text":"In\u00a0[32]: Copied! <pre>%run nb_helpers.py\n\nimport plotnine as p9\nfrom datar.all import *\nfrom datar.data import gss_cat, iris, ChickWeight\n\nnb_header(\n    fct_relevel,\n    fct_inorder,\n    fct_infreq,\n    fct_inseq,\n    fct_reorder,\n    fct_reorder2,\n    fct_rev,\n    fct_shift,\n    fct_shuffle,\n    first2,\n    last2, \n    book=\"forcat_lvl_order\",\n)\n</pre> %run nb_helpers.py  import plotnine as p9 from datar.all import * from datar.data import gss_cat, iris, ChickWeight  nb_header(     fct_relevel,     fct_inorder,     fct_infreq,     fct_inseq,     fct_reorder,     fct_reorder2,     fct_rev,     fct_shift,     fct_shuffle,     first2,     last2,      book=\"forcat_lvl_order\", )  Try this notebook on binder. In\u00a0[2]: Copied! <pre>fct = factor(c(\"a\", \"b\", \"c\", \"d\"), levels = c(\"b\", \"c\", \"d\", \"a\"))\nfct_relevel(fct)\n</pre> fct = factor(c(\"a\", \"b\", \"c\", \"d\"), levels = c(\"b\", \"c\", \"d\", \"a\")) fct_relevel(fct) Out[2]: <pre>['a', 'b', 'c', 'd']\nCategories (4, object): ['b', 'c', 'd', 'a']</pre> In\u00a0[3]: Copied! <pre>fct_relevel(fct, \"a\")\n</pre> fct_relevel(fct, \"a\") Out[3]: <pre>['a', 'b', 'c', 'd']\nCategories (4, object): ['a', 'b', 'c', 'd']</pre> In\u00a0[4]: Copied! <pre>fct_relevel(fct, \"b\", \"a\")\n</pre> fct_relevel(fct, \"b\", \"a\") Out[4]: <pre>['a', 'b', 'c', 'd']\nCategories (4, object): ['b', 'a', 'c', 'd']</pre> In\u00a0[5]: Copied! <pre>fct_relevel(fct, \"a\", after=1)\n</pre> fct_relevel(fct, \"a\", after=1) Out[5]: <pre>['a', 'b', 'c', 'd']\nCategories (4, object): ['b', 'c', 'a', 'd']</pre> In\u00a0[6]: Copied! <pre># use -1 instead of Inf\nfct_relevel(fct, \"a\", after = None)\n</pre> # use -1 instead of Inf fct_relevel(fct, \"a\", after = None) Out[6]: <pre>['a', 'b', 'c', 'd']\nCategories (4, object): ['a', 'b', 'c', 'd']</pre> In\u00a0[7]: Copied! <pre>fct_relevel(fct, \"a\", after = 2)\n</pre> fct_relevel(fct, \"a\", after = 2) Out[7]: <pre>['a', 'b', 'c', 'd']\nCategories (4, object): ['b', 'c', 'd', 'a']</pre> In\u00a0[8]: Copied! <pre>fct_relevel(fct, sort)\n</pre> fct_relevel(fct, sort) Out[8]: <pre>['a', 'b', 'c', 'd']\nCategories (4, object): ['a', 'b', 'c', 'd']</pre> In\u00a0[9]: Copied! <pre>fct_relevel(fct, sample)\n</pre> fct_relevel(fct, sample) Out[9]: <pre>['a', 'b', 'c', 'd']\nCategories (4, object): ['b', 'd', 'a', 'c']</pre> In\u00a0[10]: Copied! <pre>fct_relevel(fct, rev)\n</pre> fct_relevel(fct, rev) Out[10]: <pre>['a', 'b', 'c', 'd']\nCategories (4, object): ['a', 'd', 'c', 'b']</pre> In\u00a0[11]: Copied! <pre>df = gss_cat[[\"rincome\", \"denom\"]] &gt;&gt; mutate(across(everything(), as_factor)) \n\n(\n    df \n        &gt;&gt; summarize(across(everything(), lambda col: [levels(col).tolist()]))\n        &gt;&gt; t()\n        &gt;&gt; rename_with(str)\n        &gt;&gt; pull(to=\"dict\", name=rownames(f))\n) \n</pre> df = gss_cat[[\"rincome\", \"denom\"]] &gt;&gt; mutate(across(everything(), as_factor))   (     df          &gt;&gt; summarize(across(everything(), lambda col: [levels(col).tolist()]))         &gt;&gt; t()         &gt;&gt; rename_with(str)         &gt;&gt; pull(to=\"dict\", name=rownames(f)) )  Out[11]: <pre>{'rincome': ['$1000 to 2999',\n  '$10000 - 14999',\n  '$15000 - 19999',\n  '$20000 - 24999',\n  '$25000 or more',\n  '$3000 to 3999',\n  '$4000 to 4999',\n  '$5000 to 5999',\n  '$6000 to 6999',\n  '$7000 to 7999',\n  '$8000 to 9999',\n  \"Don't know\",\n  'Lt $1000',\n  'No answer',\n  'Not applicable',\n  'Refused'],\n 'denom': ['Afr meth ep zion',\n  'Afr meth episcopal',\n  'Am bapt ch in usa',\n  'Am baptist asso',\n  'Am lutheran',\n  'Baptist-dk which',\n  \"Don't know\",\n  'Episcopal',\n  'Evangelical luth',\n  'Luth ch in america',\n  'Lutheran-dk which',\n  'Lutheran-mo synod',\n  'Methodist-dk which',\n  'Nat bapt conv of am',\n  'Nat bapt conv usa',\n  'No answer',\n  'No denomination',\n  'Not applicable',\n  'Other',\n  'Other baptists',\n  'Other lutheran',\n  'Other methodist',\n  'Other presbyterian',\n  'Presbyterian c in us',\n  'Presbyterian, merged',\n  'Presbyterian-dk wh',\n  'Southern baptist',\n  'United methodist',\n  'United pres ch in us',\n  'Wi evan luth synod']}</pre> In\u00a0[12]: Copied! <pre>df2 = df &gt;&gt; mutate(across(everything(), fct_relevel, \"Don't know\", after=-1))\n(\n    df2 \n        &gt;&gt; summarize(across(everything(), lambda col: [levels(col).tolist()]))\n        &gt;&gt; t()\n        &gt;&gt; rename_with(str)\n        &gt;&gt; pull(to=\"dict\", name=rownames(f))\n) \n</pre> df2 = df &gt;&gt; mutate(across(everything(), fct_relevel, \"Don't know\", after=-1)) (     df2          &gt;&gt; summarize(across(everything(), lambda col: [levels(col).tolist()]))         &gt;&gt; t()         &gt;&gt; rename_with(str)         &gt;&gt; pull(to=\"dict\", name=rownames(f)) )  Out[12]: <pre>{'rincome': ['$1000 to 2999',\n  '$10000 - 14999',\n  '$15000 - 19999',\n  '$20000 - 24999',\n  '$25000 or more',\n  '$3000 to 3999',\n  '$4000 to 4999',\n  '$5000 to 5999',\n  '$6000 to 6999',\n  '$7000 to 7999',\n  '$8000 to 9999',\n  'Lt $1000',\n  'No answer',\n  'Not applicable',\n  'Refused',\n  \"Don't know\"],\n 'denom': ['Afr meth ep zion',\n  'Afr meth episcopal',\n  'Am bapt ch in usa',\n  'Am baptist asso',\n  'Am lutheran',\n  'Baptist-dk which',\n  'Episcopal',\n  'Evangelical luth',\n  'Luth ch in america',\n  'Lutheran-dk which',\n  'Lutheran-mo synod',\n  'Methodist-dk which',\n  'Nat bapt conv of am',\n  'Nat bapt conv usa',\n  'No answer',\n  'No denomination',\n  'Not applicable',\n  'Other',\n  'Other baptists',\n  'Other lutheran',\n  'Other methodist',\n  'Other presbyterian',\n  'Presbyterian c in us',\n  'Presbyterian, merged',\n  'Presbyterian-dk wh',\n  'Southern baptist',\n  'United methodist',\n  'United pres ch in us',\n  'Wi evan luth synod',\n  \"Don't know\"]}</pre> In\u00a0[13]: Copied! <pre>fct_relevel(fct, \"e\")\n</pre> fct_relevel(fct, \"e\") <pre>[2022-12-02 14:00:07][datar][WARNING] [fct_relevel] Unknown levels in `_f`: ['e']\n</pre> Out[13]: <pre>['a', 'b', 'c', 'd']\nCategories (4, object): ['b', 'c', 'd', 'a']</pre> In\u00a0[14]: Copied! <pre>fct = factor(c(\"b\", \"b\", \"a\", \"c\", \"c\", \"c\"))\nfct\n</pre> fct = factor(c(\"b\", \"b\", \"a\", \"c\", \"c\", \"c\")) fct Out[14]: <pre>['b', 'b', 'a', 'c', 'c', 'c']\nCategories (3, object): ['a', 'b', 'c']</pre> In\u00a0[15]: Copied! <pre>fct_inorder(fct)\n</pre> fct_inorder(fct) Out[15]: <pre>['b', 'b', 'a', 'c', 'c', 'c']\nCategories (3, object): ['b', 'a', 'c']</pre> In\u00a0[16]: Copied! <pre>fct_infreq(fct)\n</pre> fct_infreq(fct) Out[16]: <pre>['b', 'b', 'a', 'c', 'c', 'c']\nCategories (3, object): ['c', 'b', 'a']</pre> In\u00a0[17]: Copied! <pre>fct = factor([1,2,3], levels = [3,2,1])\nfct_inseq(fct)\n</pre> fct = factor([1,2,3], levels = [3,2,1]) fct_inseq(fct) Out[17]: <pre>[1, 2, 3]\nCategories (3, int64): [1, 2, 3]</pre> In\u00a0[18]: Copied! <pre>df = tribble(\n    f.color,  f.a, f.b,\n    \"blue\",   1,   2,\n    \"green\",  6,   2,\n    \"purple\", 3,   3,\n    \"red\",    2,   3,\n    \"yellow\", 5,   1\n) &gt;&gt; mutate(color=as_factor(f.color))\n\nfct_reorder(df.color, df.a, _fun=min)\n</pre> df = tribble(     f.color,  f.a, f.b,     \"blue\",   1,   2,     \"green\",  6,   2,     \"purple\", 3,   3,     \"red\",    2,   3,     \"yellow\", 5,   1 ) &gt;&gt; mutate(color=as_factor(f.color))  fct_reorder(df.color, df.a, _fun=min) Out[18]: <pre>['blue', 'green', 'purple', 'red', 'yellow']\nCategories (5, object): ['blue', 'red', 'purple', 'yellow', 'green']</pre> In\u00a0[19]: Copied! <pre>fct_reorder2(df.color, df.a, df.b)\n</pre> fct_reorder2(df.color, df.a, df.b) Out[19]: <pre>['blue', 'green', 'purple', 'red', 'yellow']\nCategories (5, object): ['red', 'purple', 'green', 'blue', 'yellow']</pre> In\u00a0[20]: Copied! <pre>p9.ggplot(iris) + p9.geom_boxplot(\n    p9.aes(x=\"Species\", y=\"Sepal_Width\")\n)\n</pre> p9.ggplot(iris) + p9.geom_boxplot(     p9.aes(x=\"Species\", y=\"Sepal_Width\") ) Out[20]: <pre>&lt;ggplot: (8749823469044)&gt;</pre> In\u00a0[21]: Copied! <pre>p9.ggplot(\n    iris &gt;&gt; mutate(Species=fct_reorder(f.Species, f.Sepal_Width))\n) + p9.geom_boxplot(\n    p9.aes(x=\"Species\", y=\"Sepal_Width\")\n)\n</pre> p9.ggplot(     iris &gt;&gt; mutate(Species=fct_reorder(f.Species, f.Sepal_Width)) ) + p9.geom_boxplot(     p9.aes(x=\"Species\", y=\"Sepal_Width\") ) Out[21]: <pre>&lt;ggplot: (8749823508375)&gt;</pre> In\u00a0[22]: Copied! <pre>p9.ggplot(\n    iris &gt;&gt; mutate(Species=fct_reorder(f.Species, f.Sepal_Width, _desc=True))\n) + p9.geom_boxplot(\n    p9.aes(x=\"Species\", y=\"Sepal_Width\")\n)\n</pre> p9.ggplot(     iris &gt;&gt; mutate(Species=fct_reorder(f.Species, f.Sepal_Width, _desc=True)) ) + p9.geom_boxplot(     p9.aes(x=\"Species\", y=\"Sepal_Width\") ) Out[22]: <pre>&lt;ggplot: (8749821226873)&gt;</pre> In\u00a0[23]: Copied! <pre>chks = (\n    ChickWeight \n    &gt;&gt; filter(as_integer(f.Chick) &lt; 10)\n    &gt;&gt; mutate(Chick=fct_shuffle(f.Chick))\n)\n\n(\n    p9.ggplot(chks, p9.aes(\"Time\", \"weight\", colour=\"Chick\")) \n    + p9.geom_point() \n    + p9.geom_line()\n)\n</pre>  chks = (     ChickWeight      &gt;&gt; filter(as_integer(f.Chick) &lt; 10)     &gt;&gt; mutate(Chick=fct_shuffle(f.Chick)) )  (     p9.ggplot(chks, p9.aes(\"Time\", \"weight\", colour=\"Chick\"))      + p9.geom_point()      + p9.geom_line() ) Out[23]: <pre>&lt;ggplot: (8749821203432)&gt;</pre> In\u00a0[24]: Copied! <pre>(\n    p9.ggplot(\n        chks &gt;&gt; mutate(Chick=fct_reorder2(f.Chick, f.Time, f.weight)),\n        p9.aes(\"Time\", \"weight\", colour=\"Chick\"),\n    )\n    + p9.geom_point()\n    + p9.geom_line()\n    + p9.labs(colour=\"Chick\")\n)\n</pre> (     p9.ggplot(         chks &gt;&gt; mutate(Chick=fct_reorder2(f.Chick, f.Time, f.weight)),         p9.aes(\"Time\", \"weight\", colour=\"Chick\"),     )     + p9.geom_point()     + p9.geom_line()     + p9.labs(colour=\"Chick\") )  Out[24]: <pre>&lt;ggplot: (8749821116657)&gt;</pre> In\u00a0[25]: Copied! <pre>fct = factor(c(\"a\", \"b\", \"c\"))\nfct_shuffle(fct)\n</pre> fct = factor(c(\"a\", \"b\", \"c\")) fct_shuffle(fct) Out[25]: <pre>['a', 'b', 'c']\nCategories (3, object): ['b', 'c', 'a']</pre> In\u00a0[26]: Copied! <pre>fct_shuffle(fct)\n</pre> fct_shuffle(fct) Out[26]: <pre>['a', 'b', 'c']\nCategories (3, object): ['c', 'b', 'a']</pre> In\u00a0[27]: Copied! <pre>fct_rev(fct)\n</pre> fct_rev(fct) Out[27]: <pre>['a', 'b', 'c']\nCategories (3, object): ['c', 'b', 'a']</pre> In\u00a0[28]: Copied! <pre>x = factor(\n  c(\"Mon\", \"Tue\", \"Wed\"),\n  levels = c(\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"),\n  ordered = TRUE\n)\nx\n</pre> x = factor(   c(\"Mon\", \"Tue\", \"Wed\"),   levels = c(\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"),   ordered = TRUE ) x Out[28]: <pre>['Mon', 'Tue', 'Wed']\nCategories (7, object): ['Sun' &lt; 'Mon' &lt; 'Tue' &lt; 'Wed' &lt; 'Thu' &lt; 'Fri' &lt; 'Sat']</pre> In\u00a0[29]: Copied! <pre>fct_shift(x)\n</pre> fct_shift(x) Out[29]: <pre>['Mon', 'Tue', 'Wed']\nCategories (7, object): ['Mon' &lt; 'Tue' &lt; 'Wed' &lt; 'Thu' &lt; 'Fri' &lt; 'Sat' &lt; 'Sun']</pre> In\u00a0[30]: Copied! <pre>fct_shift(x, 2)\n</pre> fct_shift(x, 2) Out[30]: <pre>['Mon', 'Tue', 'Wed']\nCategories (7, object): ['Tue' &lt; 'Wed' &lt; 'Thu' &lt; 'Fri' &lt; 'Sat' &lt; 'Sun' &lt; 'Mon']</pre> In\u00a0[31]: Copied! <pre>fct_shift(x, -1)\n</pre> fct_shift(x, -1) Out[31]: <pre>['Mon', 'Tue', 'Wed']\nCategories (7, object): ['Sat' &lt; 'Sun' &lt; 'Mon' &lt; 'Tue' &lt; 'Wed' &lt; 'Thu' &lt; 'Fri']</pre>"},{"location":"notebooks/forcats_lvl_order/#fct_relevel","title":"\u2605 fct_relevel\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#reorder-factor-levels-by-hand","title":"Reorder factor levels by hand\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor (categoriccal), or a string vector <code>*lvls</code>: Either a function (then <code>len(lvls)</code> should equal to <code>1</code>) or \u2003\u2003\u2003\u2003the new levels. \u2003\u2003\u2003\u2003A function will be called with the current levels as input, and the \u2003\u2003\u2003\u2003return value (which must be a character vector) will be used to \u2003\u2003\u2003\u2003relevel the factor. \u2003\u2003\u2003\u2003Any levels not mentioned will be left in their existing order, \u2003\u2003\u2003\u2003by default after the explicitly mentioned levels.</p> <p> <code>after</code>: Where should the new values be placed?</p>"},{"location":"notebooks/forcats_lvl_order/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels replaced</p>"},{"location":"notebooks/forcats_lvl_order/#fct_inorder","title":"\u2605 fct_inorder\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#reorder-factor-levels-by-first-appearance","title":"Reorder factor levels by first appearance\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>ordered</code>: A logical which determines the \"ordered\" status of the \u2003\u2003\u2003\u2003output factor.</p>"},{"location":"notebooks/forcats_lvl_order/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels reordered</p>"},{"location":"notebooks/forcats_lvl_order/#fct_infreq","title":"\u2605 fct_infreq\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#reorder-factor-levels-by-frequency","title":"Reorder factor levels by frequency\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>ordered</code>: A logical which determines the \"ordered\" status of the \u2003\u2003\u2003\u2003output factor.</p>"},{"location":"notebooks/forcats_lvl_order/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels reordered</p>"},{"location":"notebooks/forcats_lvl_order/#fct_inseq","title":"\u2605 fct_inseq\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#reorder-factor-levels-by-sequence","title":"Reorder factor levels by sequence\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>ordered</code>: A logical which determines the \"ordered\" status of the \u2003\u2003\u2003\u2003output factor.</p>"},{"location":"notebooks/forcats_lvl_order/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels reordered</p>"},{"location":"notebooks/forcats_lvl_order/#fct_reorder","title":"\u2605 fct_reorder\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#reorder-factor-levels-by-a-function-default-median","title":"Reorder factor levels by a function (default: median)\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>_x</code>: The data to be used to reorder the factor <code>_fun</code>: A function to be used to reorder the factor <code>_desc</code>: If <code>True</code>, the factor will be reordered in descending order <code>*args</code>: Extra arguments to be passed to <code>_fun</code> <code>**kwargs</code>: Extra keyword arguments to be passed to <code>_fun</code></p>"},{"location":"notebooks/forcats_lvl_order/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels reordered</p>"},{"location":"notebooks/forcats_lvl_order/#fct_reorder2","title":"\u2605 fct_reorder2\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#reorder-factor-levels-by-a-function-default-last2","title":"Reorder factor levels by a function (default: <code>last2</code>)\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>_x</code>: The data to be used to reorder the factor <code>_fun</code>: A function to be used to reorder the factor <code>_desc</code>: If <code>True</code>, the factor will be reordered in descending order <code>*args</code>: Extra arguments to be passed to <code>_fun</code> <code>**kwargs</code>: Extra keyword arguments to be passed to <code>_fun</code></p>"},{"location":"notebooks/forcats_lvl_order/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels reordered</p>"},{"location":"notebooks/forcats_lvl_order/#fct_rev","title":"\u2605 fct_rev\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#reverse-the-order-of-the-levels-of-a-factor","title":"Reverse the order of the levels of a factor\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor</p>"},{"location":"notebooks/forcats_lvl_order/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels reversed</p>"},{"location":"notebooks/forcats_lvl_order/#fct_shift","title":"\u2605 fct_shift\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#shift-the-levels-of-a-factor","title":"Shift the levels of a factor\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>n</code>: The number of levels to shift</p>"},{"location":"notebooks/forcats_lvl_order/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels shifted</p>"},{"location":"notebooks/forcats_lvl_order/#fct_shuffle","title":"\u2605 fct_shuffle\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#shuffle-the-levels-of-a-factor","title":"Shuffle the levels of a factor\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor</p>"},{"location":"notebooks/forcats_lvl_order/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels shuffled</p>"},{"location":"notebooks/forcats_lvl_order/#first2","title":"\u2605 first2\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#find-the-first-element-of-_y-ordered-by-_x","title":"Find the first element of <code>_y</code> ordered by <code>_x</code>\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#args","title":"Args:\u00b6","text":"<p> <code>_x</code>: The vector used to order <code>_y</code> <code>_y</code>: The vector to get the first element of</p>"},{"location":"notebooks/forcats_lvl_order/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003First element of <code>_y</code> ordered by <code>_x</code></p>"},{"location":"notebooks/forcats_lvl_order/#last2","title":"\u2605 last2\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#find-the-last-element-of-_y-ordered-by-_x","title":"Find the last element of <code>_y</code> ordered by <code>_x</code>\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#args","title":"Args:\u00b6","text":"<p> <code>_x</code>: The vector used to order <code>_y</code> <code>_y</code>: The vector to get the last element of</p>"},{"location":"notebooks/forcats_lvl_order/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003Last element of <code>_y</code> ordered by <code>_x</code></p>"},{"location":"notebooks/forcats_lvl_order/#fct_relevel","title":"fct_relevel\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#fct_inorder-fct_infreq-and-fct_inseq","title":"fct_inorder, fct_infreq, and fct_inseq\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#fct_reorder-fct_reorder2-last2-and-first2","title":"fct_reorder, fct_reorder2, last2, and first2\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#fct_shuffle","title":"fct_shuffle\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#fct_rev","title":"fct_rev\u00b6","text":""},{"location":"notebooks/forcats_lvl_order/#fct_shift","title":"fct_shift\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/","title":"forcats_lvl_value","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\n\nfrom datar.all import *\nfrom datar.data import gss_cat\n\ngss_cat &gt;&gt;= mutate(rincome=as_factor(f.rincome))\n\nnb_header(\n    fct_anon,\n    fct_collapse,\n    fct_lump,\n    fct_lump_min,\n    fct_lump_prop,\n    fct_lump_n,\n    fct_lump_lowfreq,\n    fct_other,\n    fct_recode,\n    fct_relabel,\n    book=\"forcat_lvl_value\",\n)\n</pre> %run nb_helpers.py  from datar.all import * from datar.data import gss_cat  gss_cat &gt;&gt;= mutate(rincome=as_factor(f.rincome))  nb_header(     fct_anon,     fct_collapse,     fct_lump,     fct_lump_min,     fct_lump_prop,     fct_lump_n,     fct_lump_lowfreq,     fct_other,     fct_recode,     fct_relabel,     book=\"forcat_lvl_value\", )  Try this notebook on binder. In\u00a0[2]: Copied! <pre>gss_cat.relig &gt;&gt; fct_count()\n</pre> gss_cat.relig &gt;&gt; fct_count() Out[2]: f n &lt;category&gt; &lt;int64&gt; 0 Buddhism 147 1 Catholic 5124 2 Christian 689 3 Don't know 15 4 Hinduism 71 5 Inter-nondenominational 109 6 Jewish 388 7 Moslem/islam 104 8 Native american 23 9 No answer 93 10 None 3523 11 Orthodox-christian 95 12 Other 224 13 Other eastern 32 14 Protestant 10846 In\u00a0[3]: Copied! <pre>gss_cat.relig &gt;&gt; fct_anon() &gt;&gt; fct_count()\n</pre> gss_cat.relig &gt;&gt; fct_anon() &gt;&gt; fct_count() Out[3]: f n &lt;category&gt; &lt;int64&gt; 0 00 147 1 01 104 2 02 93 3 03 109 4 04 5124 5 05 689 6 06 32 7 07 15 8 08 224 9 09 71 10 10 3523 11 11 10846 12 12 23 13 13 388 14 14 95 In\u00a0[4]: Copied! <pre>gss_cat.relig &gt;&gt; fct_anon(\"X\") &gt;&gt; fct_count()\n</pre> gss_cat.relig &gt;&gt; fct_anon(\"X\") &gt;&gt; fct_count() Out[4]: f n &lt;category&gt; &lt;int64&gt; 0 X00 388 1 X01 689 2 X02 224 3 X03 3523 4 X04 5124 5 X05 147 6 X06 10846 7 X07 109 8 X08 95 9 X09 23 10 X10 15 11 X11 71 12 X12 104 13 X13 32 14 X14 93 In\u00a0[5]: Copied! <pre>fct_count(gss_cat.partyid)\n</pre> fct_count(gss_cat.partyid) Out[5]: f n &lt;category&gt; &lt;int64&gt; 0 Don't know 1 1 Ind,near dem 2499 2 Ind,near rep 1791 3 Independent 4119 4 No answer 154 5 Not str democrat 3690 6 Not str republican 3032 7 Other party 393 8 Strong democrat 3490 9 Strong republican 2314 In\u00a0[6]: Copied! <pre>partyid2 = fct_collapse(\n    gss_cat.partyid,\n    missing = c(\"No answer\", \"Don't know\"),\n    other = \"Other party\",\n    rep = c(\"Strong republican\", \"Not str republican\"),\n    ind = c(\"Ind,near rep\", \"Independent\", \"Ind,near dem\"),\n    dem = c(\"Not str democrat\", \"Strong democrat\")\n)\nfct_count(partyid2)\n</pre> partyid2 = fct_collapse(     gss_cat.partyid,     missing = c(\"No answer\", \"Don't know\"),     other = \"Other party\",     rep = c(\"Strong republican\", \"Not str republican\"),     ind = c(\"Ind,near rep\", \"Independent\", \"Ind,near dem\"),     dem = c(\"Not str democrat\", \"Strong democrat\") ) fct_count(partyid2) Out[6]: f n &lt;category&gt; &lt;int64&gt; 0 missing 155 1 ind 8409 2 dem 7180 3 rep 5346 4 other 393 In\u00a0[7]: Copied! <pre>x = factor(c(\"apple\", \"bear\", \"banana\", \"dear\"))\nfct_recode(x, fruit=[\"apple\", \"banana\"])\n</pre> x = factor(c(\"apple\", \"bear\", \"banana\", \"dear\")) fct_recode(x, fruit=[\"apple\", \"banana\"]) Out[7]: <pre>['fruit', 'bear', 'fruit', 'dear']\nCategories (3, object): ['fruit', 'bear', 'dear']</pre> In\u00a0[8]: Copied! <pre># If you make a mistake you'll get a warning\nfct_recode(x, fruit=[\"apple\", \"bananana\"])\n</pre> # If you make a mistake you'll get a warning fct_recode(x, fruit=[\"apple\", \"bananana\"]) <pre>[2022-12-02 14:01:25][datar][WARNING] [fct_recode] Unknown levels in `_f`: {'bananana'}\n</pre> Out[8]: <pre>['fruit', 'bear', 'banana', 'dear']\nCategories (4, object): ['fruit', 'banana', 'bear', 'dear']</pre> In\u00a0[9]: Copied! <pre>fct_recode(x, {NULL: \"apple\"}, fruit = \"banana\")\n</pre> fct_recode(x, {NULL: \"apple\"}, fruit = \"banana\") Out[9]: <pre>[NaN, 'fruit', 'bear', 'dear']\nCategories (3, object): ['fruit', 'bear', 'dear']</pre> In\u00a0[10]: Copied! <pre># Anything cannot be a keyword directly, use a dict\nfct_recode(x, {\"an apple\": \"apple\", \"a bear\": \"bear\"})\n</pre> # Anything cannot be a keyword directly, use a dict fct_recode(x, {\"an apple\": \"apple\", \"a bear\": \"bear\"}) Out[10]: <pre>['an apple', 'a bear', 'banana', 'dear']\nCategories (4, object): ['an apple', 'banana', 'a bear', 'dear']</pre> In\u00a0[11]: Copied! <pre>x = factor(rep(LETTERS[:9], times = c(40, 10, 5, 27, 1, 1, 1, 1, 1)))\ntable(x)\n</pre> x = factor(rep(LETTERS[:9], times = c(40, 10, 5, 27, 1, 1, 1, 1, 1))) table(x) Out[11]: A B C D E F G H I &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; count 40 10 5 27 1 1 1 1 1 In\u00a0[12]: Copied! <pre>x &gt;&gt; fct_lump_n(3) \ntable(_)\n</pre> x &gt;&gt; fct_lump_n(3)  table(_) Out[12]: <pre>['A', 'A', 'A', 'A', 'A', ..., 'Other', 'Other', 'Other', 'Other', 'Other']\nLength: 87\nCategories (4, object): ['A', 'B', 'D', 'Other']</pre> Out[12]: A B D Other &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; count 40 10 27 10 In\u00a0[13]: Copied! <pre>x &gt;&gt; fct_lump_prop(0.10) \ntable(_)\n</pre> x &gt;&gt; fct_lump_prop(0.10)  table(_) Out[13]: <pre>['A', 'A', 'A', 'A', 'A', ..., 'Other', 'Other', 'Other', 'Other', 'Other']\nLength: 87\nCategories (4, object): ['A', 'B', 'D', 'Other']</pre> Out[13]: A B D Other &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; count 40 10 27 10 In\u00a0[14]: Copied! <pre>x &gt;&gt; fct_lump_min(5) \ntable(_)\n</pre> x &gt;&gt; fct_lump_min(5)  table(_) Out[14]: <pre>['A', 'A', 'A', 'A', 'A', ..., 'Other', 'Other', 'Other', 'Other', 'Other']\nLength: 87\nCategories (5, object): ['A', 'B', 'C', 'D', 'Other']</pre> Out[14]: A B C D Other &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; count 40 10 5 27 5 In\u00a0[15]: Copied! <pre>x &gt;&gt; fct_lump_lowfreq() \ntable(_)\n</pre> x &gt;&gt; fct_lump_lowfreq()  table(_) Out[15]: <pre>['A', 'A', 'A', 'A', 'A', ..., 'Other', 'Other', 'Other', 'Other', 'Other']\nLength: 87\nCategories (3, object): ['A', 'D', 'Other']</pre> Out[15]: A D Other &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; count 40 27 20 In\u00a0[16]: Copied! <pre>x = factor(LETTERS[rpois(100, 5)])\nx\n</pre> x = factor(LETTERS[rpois(100, 5)]) x Out[16]: <pre>['D', 'E', 'D', 'I', 'E', ..., 'D', 'E', 'L', 'D', 'E']\nLength: 100\nCategories (12, object): ['B', 'C', 'D', 'E', ..., 'J', 'K', 'L', 'M']</pre> In\u00a0[17]: Copied! <pre>table(x)\n</pre> table(x) Out[17]: B C D E F G H I J K L M &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; count 1 9 17 18 18 13 8 8 4 1 1 2 In\u00a0[18]: Copied! <pre>table(fct_lump_lowfreq(x))\n</pre> table(fct_lump_lowfreq(x)) Out[18]: B C D E F G H I J K L M &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; count 1 9 17 18 18 13 8 8 4 1 1 2 In\u00a0[19]: Copied! <pre>fct_lump_n(x, n = 3)\n</pre> fct_lump_n(x, n = 3) Out[19]: <pre>['D', 'E', 'D', 'Other', 'E', ..., 'D', 'E', 'Other', 'D', 'E']\nLength: 100\nCategories (4, object): ['D', 'E', 'F', 'Other']</pre> In\u00a0[20]: Copied! <pre>fct_lump_prop(x, prop = 0.1)\n</pre> fct_lump_prop(x, prop = 0.1) Out[20]: <pre>['D', 'E', 'D', 'Other', 'E', ..., 'D', 'E', 'Other', 'D', 'E']\nLength: 100\nCategories (5, object): ['D', 'E', 'F', 'G', 'Other']</pre> In\u00a0[21]: Copied! <pre># Use negative values to collapse the most common\nfct_lump_n(x, n = -3)\n</pre> # Use negative values to collapse the most common fct_lump_n(x, n = -3) Out[21]: <pre>['Other', 'Other', 'Other', 'Other', 'Other', ..., 'Other', 'Other', 'L', 'Other', 'Other']\nLength: 100\nCategories (4, object): ['B', 'K', 'L', 'Other']</pre> In\u00a0[22]: Copied! <pre>fct_lump_prop(x, prop = -0.1)\n</pre> fct_lump_prop(x, prop = -0.1) Out[22]: <pre>['Other', 'Other', 'Other', 'I', 'Other', ..., 'Other', 'Other', 'L', 'Other', 'Other']\nLength: 100\nCategories (9, object): ['B', 'C', 'H', 'I', ..., 'K', 'L', 'M', 'Other']</pre> In\u00a0[23]: Copied! <pre>w = c(rep(2, 50), rep(1, 50))\nfct_lump_n(x, n = 5, w = w)\n</pre> w = c(rep(2, 50), rep(1, 50)) fct_lump_n(x, n = 5, w = w) Out[23]: <pre>['D', 'E', 'D', 'Other', 'E', ..., 'D', 'E', 'Other', 'D', 'E']\nLength: 100\nCategories (6, object): ['B', 'C', 'D', 'E', 'H', 'Other']</pre> In\u00a0[24]: Copied! <pre>fct_lump_n(x, n = 6)\n</pre> fct_lump_n(x, n = 6) Out[24]: <pre>['D', 'E', 'D', 'I', 'E', ..., 'D', 'E', 'Other', 'D', 'E']\nLength: 100\nCategories (8, object): ['C', 'D', 'E', 'F', 'G', 'H', 'I', 'Other']</pre> In\u00a0[25]: Copied! <pre>fct_lump_n(x, n = 6, ties_method = \"max\")\n</pre> fct_lump_n(x, n = 6, ties_method = \"max\") Out[25]: <pre>['D', 'E', 'D', 'Other', 'E', ..., 'D', 'E', 'Other', 'D', 'E']\nLength: 100\nCategories (6, object): ['C', 'D', 'E', 'F', 'G', 'Other']</pre> In\u00a0[26]: Copied! <pre># Use fct_lump_min() to lump together all levels with fewer than `n` values\ntable(fct_lump_min(x, min = 10))\n</pre> # Use fct_lump_min() to lump together all levels with fewer than `n` values table(fct_lump_min(x, min = 10))  Out[26]: D E F G Other &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; count 17 18 18 13 34 In\u00a0[27]: Copied! <pre>table(fct_lump_min(x, min = 15))\n</pre> table(fct_lump_min(x, min = 15)) Out[27]: D E F Other &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; count 17 18 18 47 In\u00a0[28]: Copied! <pre>fct_other(x, keep = c(\"A\", \"B\"))\n</pre> fct_other(x, keep = c(\"A\", \"B\")) Out[28]: <pre>['Other', 'Other', 'Other', 'Other', 'Other', ..., 'Other', 'Other', 'Other', 'Other', 'Other']\nLength: 100\nCategories (2, object): ['B', 'Other']</pre> In\u00a0[29]: Copied! <pre>fct_other(x, drop = c(\"A\", \"B\"))\n</pre> fct_other(x, drop = c(\"A\", \"B\")) Out[29]: <pre>['D', 'E', 'D', 'I', 'E', ..., 'D', 'E', 'L', 'D', 'E']\nLength: 100\nCategories (12, object): ['C', 'D', 'E', 'F', ..., 'K', 'L', 'M', 'Other']</pre> In\u00a0[30]: Copied! <pre>x = factor(c(\"apple\", \"bear\", \"banana\", \"dear\"))\nfct_recode(x, fruit = [\"apple\", \"banana\"])\n</pre> x = factor(c(\"apple\", \"bear\", \"banana\", \"dear\")) fct_recode(x, fruit = [\"apple\", \"banana\"]) Out[30]: <pre>['fruit', 'bear', 'fruit', 'dear']\nCategories (3, object): ['fruit', 'bear', 'dear']</pre> In\u00a0[31]: Copied! <pre># If you make a mistake you'll get a warning\nfct_recode(x, fruit = [\"apple\", \"bananana\"])\n</pre> # If you make a mistake you'll get a warning fct_recode(x, fruit = [\"apple\", \"bananana\"]) <pre>[2022-12-02 14:01:52][datar][WARNING] [fct_recode] Unknown levels in `_f`: {'bananana'}\n</pre> Out[31]: <pre>['fruit', 'bear', 'banana', 'dear']\nCategories (4, object): ['fruit', 'banana', 'bear', 'dear']</pre> In\u00a0[32]: Copied! <pre># If you name the level NULL it will be removed\nfct_recode(x, {NULL: \"apple\"}, fruit = \"banana\")\n</pre> # If you name the level NULL it will be removed fct_recode(x, {NULL: \"apple\"}, fruit = \"banana\") Out[32]: <pre>[NaN, 'fruit', 'bear', 'dear']\nCategories (3, object): ['fruit', 'bear', 'dear']</pre> In\u00a0[33]: Copied! <pre>fct_recode(x, {\"an apple\": \"apple\", \"a bear\": \"bear\"})\n</pre> fct_recode(x, {\"an apple\": \"apple\", \"a bear\": \"bear\"}) Out[33]: <pre>['an apple', 'a bear', 'banana', 'dear']\nCategories (4, object): ['an apple', 'banana', 'a bear', 'dear']</pre> In\u00a0[34]: Copied! <pre>gss_cat.partyid &gt;&gt; fct_count()\n</pre> gss_cat.partyid &gt;&gt; fct_count() Out[34]: f n &lt;category&gt; &lt;int64&gt; 0 Don't know 1 1 Ind,near dem 2499 2 Ind,near rep 1791 3 Independent 4119 4 No answer 154 5 Not str democrat 3690 6 Not str republican 3032 7 Other party 393 8 Strong democrat 3490 9 Strong republican 2314 In\u00a0[35]: Copied! <pre>gss_cat.partyid &gt;&gt; fct_relabel(lambda old: gsub(\",\", \", \", old)) &gt;&gt; fct_count()\n</pre> gss_cat.partyid &gt;&gt; fct_relabel(lambda old: gsub(\",\", \", \", old)) &gt;&gt; fct_count() Out[35]: f n &lt;category&gt; &lt;int64&gt; 0 Don't know 1 1 Ind, near dem 2499 2 Ind, near rep 1791 3 Independent 4119 4 No answer 154 5 Not str democrat 3690 6 Not str republican 3032 7 Other party 393 8 Strong democrat 3490 9 Strong republican 2314 In\u00a0[36]: Copied! <pre>fct_count(gss_cat.rincome)\n</pre> fct_count(gss_cat.rincome) Out[36]: f n &lt;category&gt; &lt;int64&gt; 0 $1000 to 2999 395 1 $10000 - 14999 1168 2 $15000 - 19999 1048 3 $20000 - 24999 1283 4 $25000 or more 7363 5 $3000 to 3999 276 6 $4000 to 4999 226 7 $5000 to 5999 227 8 $6000 to 6999 215 9 $7000 to 7999 188 10 $8000 to 9999 340 11 Don't know 267 12 Lt $1000 286 13 No answer 183 14 Not applicable 7043 15 Refused 975 In\u00a0[37]: Copied! <pre>def convert_income(income):\n    regex = r\"^(?:Lt |)[$]([0-9]+).*$\"\n    is_range = grepl(regex, income)\n    num_income = as_numeric(gsub(regex, r\"\\1\", income[is_range]))\n    num_income = trunc(num_income / 5000) * 5000\n    income[is_range] = paste0(\"Gt $\", num_income)\n    return income\n\nconvert_income(levels(gss_cat.rincome))\n</pre> def convert_income(income):     regex = r\"^(?:Lt |)[$]([0-9]+).*$\"     is_range = grepl(regex, income)     num_income = as_numeric(gsub(regex, r\"\\1\", income[is_range]))     num_income = trunc(num_income / 5000) * 5000     income[is_range] = paste0(\"Gt $\", num_income)     return income  convert_income(levels(gss_cat.rincome)) Out[37]: <pre>array(['Gt $0.0', 'Gt $10000.0', 'Gt $15000.0', 'Gt $20000.0',\n       'Gt $25000.0', 'Gt $0.0', 'Gt $0.0', 'Gt $5000.0', 'Gt $5000.0',\n       'Gt $5000.0', 'Gt $5000.0', \"Don't know\", 'Gt $0.0', 'No answer',\n       'Not applicable', 'Refused'], dtype=object)</pre> In\u00a0[38]: Copied! <pre>rincome2 = fct_relabel(gss_cat.rincome, convert_income)\nfct_count(rincome2)\n</pre> rincome2 = fct_relabel(gss_cat.rincome, convert_income) fct_count(rincome2) Out[38]: f n &lt;category&gt; &lt;int64&gt; 0 Gt $0.0 1183 1 Gt $10000.0 1168 2 Gt $15000.0 1048 3 Gt $20000.0 1283 4 Gt $25000.0 7363 5 Gt $5000.0 970 6 Don't know 267 7 No answer 183 8 Not applicable 7043 9 Refused 975"},{"location":"notebooks/forcats_lvl_value/#fct_anon","title":"\u2605 fct_anon\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#anonymise-factor-levels","title":"Anonymise factor levels\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#args","title":"Args:\u00b6","text":"<p> <code>f</code>: A factor. <code>prefix</code>: A character prefix to insert in front of the random labels.</p>"},{"location":"notebooks/forcats_lvl_value/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels anonymised</p>"},{"location":"notebooks/forcats_lvl_value/#fct_collapse","title":"\u2605 fct_collapse\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#collapse-factor-levels-into-manually-defined-groups","title":"Collapse factor levels into manually defined groups\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>**kwargs</code>: The levels to collapse. \u2003\u2003\u2003\u2003Like <code>name=[old_level, old_level1, ...]</code>. The old levels will \u2003\u2003\u2003\u2003be replaced with <code>name</code></p> <p> <code>other_level</code>: Replace all levels not named in <code>kwargs</code>. \u2003\u2003\u2003\u2003If not, don't collapse them.</p>"},{"location":"notebooks/forcats_lvl_value/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels collapsed.</p>"},{"location":"notebooks/forcats_lvl_value/#fct_lump","title":"\u2605 fct_lump\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#lump-together-factor-levels-into-other","title":"Lump together factor levels into \"other\"\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#args","title":"Args:\u00b6","text":"<p> <code>f</code>: A factor <code>n</code>: Positive <code>n</code> preserves the most common <code>n</code> values. \u2003\u2003\u2003\u2003Negative <code>n</code> preserves the least common <code>-n</code> values. \u2003\u2003\u2003\u2003It there are ties, you will get at least <code>abs(n)</code> values.</p> <p> <code>prop</code>: Positive <code>prop</code> lumps values which do not appear at least <code>prop</code> of the time. Negative <code>prop</code> lumps values that \u2003\u2003\u2003\u2003do not appear at most <code>-prop</code> of the time.</p> <p> <code>w</code>: An optional numeric vector giving weights for frequency of \u2003\u2003\u2003\u2003each value (not level) in f.</p> <p> <code>other_level</code>: Value of level used for \"other\" values. Always \u2003\u2003\u2003\u2003placed at end of levels.</p> <p>\u2003\u2003ties_method A character string specifying how ties are treated. \u2003\u2003\u2003\u2003One of: <code>average</code>, <code>first</code>, <code>dense</code>, <code>max</code>, and <code>min</code>.</p>"},{"location":"notebooks/forcats_lvl_value/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels lumped.</p>"},{"location":"notebooks/forcats_lvl_value/#fct_lump_min","title":"\u2605 fct_lump_min\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#lumps-levels-that-appear-fewer-than-min_-times","title":"lumps levels that appear fewer than <code>min_</code> times.\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>min_</code>: Preserve levels that appear at least <code>min_</code> number of times. <code>w</code>: An optional numeric vector giving weights for frequency of \u2003\u2003\u2003\u2003each value (not level) in f.</p> <p> <code>other_level</code>: Value of level used for \"other\" values. Always \u2003\u2003\u2003\u2003placed at end of levels.</p>"},{"location":"notebooks/forcats_lvl_value/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels lumped.</p>"},{"location":"notebooks/forcats_lvl_value/#fct_lump_prop","title":"\u2605 fct_lump_prop\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#lumps-levels-that-appear-in-fewer-prop-n-times","title":"Lumps levels that appear in fewer <code>prop * n</code> times.\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>prop</code>: Positive <code>prop</code> lumps values which do not appear at least <code>prop</code> of the time. Negative <code>prop</code> lumps values that \u2003\u2003\u2003\u2003do not appear at most <code>-prop</code> of the time.</p> <p> <code>w</code>: An optional numeric vector giving weights for frequency of \u2003\u2003\u2003\u2003each value (not level) in f.</p> <p> <code>other_level</code>: Value of level used for \"other\" values. Always \u2003\u2003\u2003\u2003placed at end of levels.</p>"},{"location":"notebooks/forcats_lvl_value/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels lumped.</p>"},{"location":"notebooks/forcats_lvl_value/#fct_lump_n","title":"\u2605 fct_lump_n\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#lumps-all-levels-except-for-the-n-most-frequent","title":"Lumps all levels except for the <code>n</code> most frequent.\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#args","title":"Args:\u00b6","text":"<p> <code>f</code>: A factor <code>n</code>: Positive <code>n</code> preserves the most common <code>n</code> values. \u2003\u2003\u2003\u2003Negative <code>n</code> preserves the least common <code>-n</code> values. \u2003\u2003\u2003\u2003It there are ties, you will get at least <code>abs(n)</code> values.</p> <p> <code>w</code>: An optional numeric vector giving weights for frequency of \u2003\u2003\u2003\u2003each value (not level) in f.</p> <p> <code>other_level</code>: Value of level used for \"other\" values. Always \u2003\u2003\u2003\u2003placed at end of levels.</p> <p>\u2003\u2003ties_method A character string specifying how ties are treated. \u2003\u2003\u2003\u2003One of: <code>average</code>, <code>first</code>, <code>dense</code>, <code>max</code>, and <code>min</code>.</p>"},{"location":"notebooks/forcats_lvl_value/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels lumped.</p>"},{"location":"notebooks/forcats_lvl_value/#fct_lump_lowfreq","title":"\u2605 fct_lump_lowfreq\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#lumps-together-the-least-frequent-levels-ensuring","title":"lumps together the least frequent levels, ensuring\u00b6","text":"<p>that \"other\" is still the smallest level.</p>"},{"location":"notebooks/forcats_lvl_value/#args","title":"Args:\u00b6","text":"<p> <code>f</code>: A factor <code>other_level</code>: Value of level used for \"other\" values. Always \u2003\u2003\u2003\u2003placed at end of levels.</p>"},{"location":"notebooks/forcats_lvl_value/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels lumped.</p>"},{"location":"notebooks/forcats_lvl_value/#fct_other","title":"\u2605 fct_other\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#replace-levels-with-other","title":"Replace levels with \"other\"\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>keep</code>: and <code>drop</code>: Pick one of <code>keep</code> and <code>drop</code>: \u2003\u2003\u2003\u2003- <code>keep</code> will preserve listed levels, replacing all others with \u2003\u2003\u2003\u2003\u2003\u2003<code>other_level</code>.</p> <p>\u2003\u2003\u2003\u2003- <code>drop</code> will replace listed levels with <code>other_level</code>, keeping all \u2003\u2003\u2003\u2003\u2003\u2003as is.</p> <p> <code>other_level</code>: Value of level used for \"other\" values. Always \u2003\u2003\u2003\u2003placed at end of levels.</p>"},{"location":"notebooks/forcats_lvl_value/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels replaced.</p>"},{"location":"notebooks/forcats_lvl_value/#fct_recode","title":"\u2605 fct_recode\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#change-factor-levels-by-hand","title":"Change factor levels by hand\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>*args</code>: and <code>**kwargs</code>: A sequence of named character vectors where the name \u2003\u2003\u2003\u2003gives the new level, and the value gives the old level. \u2003\u2003\u2003\u2003Levels not otherwise mentioned will be left as is. Levels can \u2003\u2003\u2003\u2003be removed by naming them <code>NULL</code>. \u2003\u2003\u2003\u2003As <code>NULL/None</code> cannot be a name of keyword arguments, replacement \u2003\u2003\u2003\u2003has to be specified as a dict \u2003\u2003\u2003\u2003(i.e. <code>fct_recode(x, {NULL: \"apple\"})</code>) \u2003\u2003\u2003\u2003If you want to replace multiple values with the same old value, \u2003\u2003\u2003\u2003use a <code>set</code>/<code>list</code>/<code>numpy.ndarray</code> \u2003\u2003\u2003\u2003(i.e. <code>fct_recode(x, fruit=[\"apple\", \"banana\"])</code>). \u2003\u2003\u2003\u2003This is a safe way, since <code>set</code>/<code>list</code>/<code>numpy.ndarray</code> is \u2003\u2003\u2003\u2003not hashable to be a level of a factor. \u2003\u2003\u2003\u2003Do NOT use a <code>tuple</code>, as it's hashable!</p> <p>\u2003\u2003\u2003\u2003Note that the order of the name-value is in the reverse way as <code>dplyr.recode()</code> and <code>dplyr.recode_factor()</code></p>"},{"location":"notebooks/forcats_lvl_value/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor recoded with given recodings</p>"},{"location":"notebooks/forcats_lvl_value/#fct_relabel","title":"\u2605 fct_relabel\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#automatically-relabel-factor-levels-collapse-as-necessary","title":"Automatically relabel factor levels, collapse as necessary\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>_fun</code>: A function to be applied to each level. Must accept the old \u2003\u2003\u2003\u2003levels and return a character vector of the same length \u2003\u2003\u2003\u2003as its input.</p> <p> <code>*args</code>: and <code>**kwargs</code>: Addtional arguments to <code>_fun</code></p>"},{"location":"notebooks/forcats_lvl_value/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels relabeled</p>"},{"location":"notebooks/forcats_lvl_value/#fct_anon","title":"fct_anon\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#fct_collapse","title":"fct_collapse\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#fct_recode","title":"fct_recode\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#fct_lump-fct_lump_min-fct_lump_prop-fct_lump_n-and-fct_lump_lowfreq","title":"fct_lump, fct_lump_min, fct_lump_prop, fct_lump_n, and fct_lump_lowfreq\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#fct_other","title":"fct_other\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#fct_recode","title":"fct_recode\u00b6","text":""},{"location":"notebooks/forcats_lvl_value/#fct_relabel","title":"fct_relabel\u00b6","text":""},{"location":"notebooks/forcats_misc/","title":"forcats_misc","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\n\nimport numpy\nfrom datar.all import *\nfrom datar.data import gss_cat\n\n\nnb_header(\n    as_factor,\n    fct_count,\n    fct_match,\n    fct_unique,\n    lvls_reorder,\n    lvls_revalue,\n    lvls_expand,\n    lvls_union,\n    book=\"forcat_lvl_addrm\",\n)\n</pre> %run nb_helpers.py  import numpy from datar.all import * from datar.data import gss_cat   nb_header(     as_factor,     fct_count,     fct_match,     fct_unique,     lvls_reorder,     lvls_revalue,     lvls_expand,     lvls_union,     book=\"forcat_lvl_addrm\", )  Try this notebook on binder. In\u00a0[2]: Copied! <pre>x = c(\"a\", \"z\", \"g\")\nas_factor(x)\n</pre> x = c(\"a\", \"z\", \"g\") as_factor(x) Out[2]: <pre>['a', 'z', 'g']\nCategories (3, object): ['a', 'g', 'z']</pre> In\u00a0[3]: Copied! <pre>y = c(\"1.1\", \"11\", \"2.2\", \"22\")\nas_factor(y)\n</pre> y = c(\"1.1\", \"11\", \"2.2\", \"22\") as_factor(y) Out[3]: <pre>['1.1', '11', '2.2', '22']\nCategories (4, object): ['1.1', '11', '2.2', '22']</pre> In\u00a0[4]: Copied! <pre>z = as_numeric(y)\nas_factor(z)\n</pre> z = as_numeric(y) as_factor(z) <pre>FutureWarning: Index.ravel returning ndarray is deprecated; in a future version this will return a view on self.\n</pre> Out[4]: <pre>[1.1, 11.0, 2.2, 22.0]\nCategories (4, float64): [1.1, 2.2, 11.0, 22.0]</pre> In\u00a0[5]: Copied! <pre>fct = factor(sample(letters)[rpois(1000, 10)])\ntable(fct)\n</pre> fct = factor(sample(letters)[rpois(1000, 10)]) table(fct) Out[5]: b c d e i k l m n o ... q r s t u v w x y z &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; ... &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; count 8 88 37 1 45 67 2 14 105 4 ... 5 22 1 87 49 17 134 128 72 112 <p>1 rows \u00d7 21 columns</p> In\u00a0[6]: Copied! <pre>fct_count(fct)\n</pre> fct_count(fct) Out[6]: f n &lt;category&gt; &lt;int64&gt; 0 b 8 1 c 88 2 d 37 3 e 1 4 i 45 5 k 67 6 l 2 7 m 14 8 n 105 9 o 4 10 p 2 11 q 5 12 r 22 13 s 1 14 t 87 15 u 49 16 v 17 17 w 134 18 x 128 19 y 72 20 z 112 In\u00a0[7]: Copied! <pre>fct_count(fct, sort = TRUE)\n</pre> fct_count(fct, sort = TRUE) Out[7]: f n &lt;category&gt; &lt;int64&gt; 17 w 134 18 x 128 20 z 112 8 n 105 1 c 88 14 t 87 19 y 72 5 k 67 15 u 49 4 i 45 2 d 37 12 r 22 16 v 17 7 m 14 0 b 8 11 q 5 9 o 4 6 l 2 10 p 2 3 e 1 13 s 1 In\u00a0[8]: Copied! <pre>fct_count(fct, sort = TRUE, prop = TRUE)\n</pre> fct_count(fct, sort = TRUE, prop = TRUE) Out[8]: f n p &lt;category&gt; &lt;int64&gt; &lt;float64&gt; 17 w 134 0.134 18 x 128 0.128 20 z 112 0.112 8 n 105 0.105 1 c 88 0.088 14 t 87 0.087 19 y 72 0.072 5 k 67 0.067 15 u 49 0.049 4 i 45 0.045 2 d 37 0.037 12 r 22 0.022 16 v 17 0.017 7 m 14 0.014 0 b 8 0.008 11 q 5 0.005 9 o 4 0.004 6 l 2 0.002 10 p 2 0.002 3 e 1 0.001 13 s 1 0.001 In\u00a0[9]: Copied! <pre>table(fct_match(gss_cat.marital, c(\"Married\", \"Divorced\")))\n</pre> table(fct_match(gss_cat.marital, c(\"Married\", \"Divorced\"))) Out[9]: False True &lt;int64&gt; &lt;int64&gt; count 7983 13500 In\u00a0[10]: Copied! <pre>table(numpy.isin(gss_cat.marital, c(\"Maried\", \"Davorced\")))\n</pre> table(numpy.isin(gss_cat.marital, c(\"Maried\", \"Davorced\"))) Out[10]: False &lt;int64&gt; count 21483 In\u00a0[11]: Copied! <pre>with try_catch():\n    table(fct_match(gss_cat.marital, c(\"Maried\", \"Davorced\")))\n</pre> with try_catch():     table(fct_match(gss_cat.marital, c(\"Maried\", \"Davorced\"))) <pre>[ValueError] Levels not present in factor: ['Maried' 'Davorced'].\n</pre> In\u00a0[12]: Copied! <pre>fct = factor(letters[rpois(100, 10)-1])\n\nunique(fct)\n</pre> fct = factor(letters[rpois(100, 10)-1])  unique(fct) Out[12]: <pre>array(['p', 'k', 'i', 'j', 'e', 'r', 'm', 'g', 'n', 'f', 'o', 'h', 'l',\n       'd', 'c'], dtype=object)</pre> In\u00a0[13]: Copied! <pre>fct_unique(fct)\n</pre> fct_unique(fct) Out[13]: <pre>['c', 'd', 'e', 'f', 'g', ..., 'm', 'n', 'o', 'p', 'r']\nLength: 15\nCategories (15, object): ['c', 'd', 'e', 'f', ..., 'n', 'o', 'p', 'r']</pre> In\u00a0[14]: Copied! <pre>fct = factor(c(\"a\", \"b\", \"c\"))\nlvls_reorder(fct, [2,1,0])\n</pre> fct = factor(c(\"a\", \"b\", \"c\")) lvls_reorder(fct, [2,1,0]) Out[14]: <pre>['a', 'b', 'c']\nCategories (3, object): ['c', 'b', 'a']</pre> In\u00a0[15]: Copied! <pre>lvls_revalue(fct, c(\"apple\", \"banana\", \"carrot\"))\n</pre> lvls_revalue(fct, c(\"apple\", \"banana\", \"carrot\")) Out[15]: <pre>['apple', 'banana', 'carrot']\nCategories (3, object): ['apple', 'banana', 'carrot']</pre> In\u00a0[16]: Copied! <pre>lvls_expand(fct, c(\"a\", \"b\", \"c\", \"d\"))\n</pre> lvls_expand(fct, c(\"a\", \"b\", \"c\", \"d\")) Out[16]: <pre>['a', 'b', 'c']\nCategories (4, object): ['a', 'b', 'c', 'd']</pre> In\u00a0[17]: Copied! <pre>fs = [factor(\"a\"), factor(\"b\"), factor(c(\"a\", \"b\"))]\nlvls_union(fs)\n</pre> fs = [factor(\"a\"), factor(\"b\"), factor(c(\"a\", \"b\"))] lvls_union(fs) Out[17]: <pre>array(['a', 'b'], dtype=object)</pre>"},{"location":"notebooks/forcats_misc/#as_factor","title":"\u2605 as_factor\u00b6","text":""},{"location":"notebooks/forcats_misc/#convert-a-vector-to-a-factor-vector","title":"Convert a vector to a factor vector\u00b6","text":""},{"location":"notebooks/forcats_misc/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector</p>"},{"location":"notebooks/forcats_misc/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor vector</p>"},{"location":"notebooks/forcats_misc/#fct_count","title":"\u2605 fct_count\u00b6","text":""},{"location":"notebooks/forcats_misc/#count-entries-in-a-factor","title":"Count entries in a factor\u00b6","text":""},{"location":"notebooks/forcats_misc/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>sort</code>: If True, sort the result so that the most common values float to \u2003\u2003\u2003\u2003the top</p> <p> <code>prop</code>: If True, compute the fraction of marginal table.</p>"},{"location":"notebooks/forcats_misc/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with columns <code>f</code>, <code>n</code> and <code>p</code>, if prop is True</p>"},{"location":"notebooks/forcats_misc/#fct_match","title":"\u2605 fct_match\u00b6","text":""},{"location":"notebooks/forcats_misc/#test-for-presence-of-levels-in-a-factor","title":"Test for presence of levels in a factor\u00b6","text":"<p>Do any of <code>lvls</code> occur in <code>_f</code>?</p>"},{"location":"notebooks/forcats_misc/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>lvls</code>: A vector specifying levels to look for.</p>"},{"location":"notebooks/forcats_misc/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A logical factor</p>"},{"location":"notebooks/forcats_misc/#fct_unique","title":"\u2605 fct_unique\u00b6","text":""},{"location":"notebooks/forcats_misc/#unique-values-of-a-factor","title":"Unique values of a factor\u00b6","text":""},{"location":"notebooks/forcats_misc/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor</p>"},{"location":"notebooks/forcats_misc/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with the unique values in <code>_f</code></p>"},{"location":"notebooks/forcats_misc/#lvls_reorder","title":"\u2605 lvls_reorder\u00b6","text":""},{"location":"notebooks/forcats_misc/#leaves-values-of-a-factor-as-they-are-but-changes-the-order-by","title":"Leaves values of a factor as they are, but changes the order by\u00b6","text":"<p>given indices</p>"},{"location":"notebooks/forcats_misc/#args","title":"Args:\u00b6","text":"<p> <code>f</code>: A factor (or character vector). <code>idx</code>: A integer index, with one integer for each existing level. <code>new_levels</code>: A character vector of new levels. <code>ordered</code>: A logical which determines the \"ordered\" status of the \u2003\u2003\u2003\u2003output factor. <code>None</code> preserves the existing status of the factor.</p>"},{"location":"notebooks/forcats_misc/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with levels reordered</p>"},{"location":"notebooks/forcats_misc/#lvls_revalue","title":"\u2605 lvls_revalue\u00b6","text":""},{"location":"notebooks/forcats_misc/#changes-the-values-of-existing-levels-there-must","title":"changes the values of existing levels; there must\u00b6","text":"<p>be one new level for each old level</p>"},{"location":"notebooks/forcats_misc/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>new_levels</code>: A character vector of new levels.</p>"},{"location":"notebooks/forcats_misc/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with the new levels</p>"},{"location":"notebooks/forcats_misc/#lvls_expand","title":"\u2605 lvls_expand\u00b6","text":""},{"location":"notebooks/forcats_misc/#expands-the-set-of-levels-the-new-levels-must","title":"Expands the set of levels; the new levels must\u00b6","text":"<p>include the old levels.</p>"},{"location":"notebooks/forcats_misc/#args","title":"Args:\u00b6","text":"<p> <code>_f</code>: A factor <code>new_levels</code>: The new levels. Must include the old ones</p>"},{"location":"notebooks/forcats_misc/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The factor with the new levels</p>"},{"location":"notebooks/forcats_misc/#lvls_union","title":"\u2605 lvls_union\u00b6","text":""},{"location":"notebooks/forcats_misc/#find-all-levels-in-a-list-of-factors","title":"Find all levels in a list of factors\u00b6","text":""},{"location":"notebooks/forcats_misc/#args","title":"Args:\u00b6","text":"<p> <code>fs</code>: A list of factors</p>"},{"location":"notebooks/forcats_misc/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A list of all levels</p>"},{"location":"notebooks/forcats_misc/#as_factor","title":"as_factor\u00b6","text":""},{"location":"notebooks/forcats_misc/#fct_count","title":"fct_count\u00b6","text":""},{"location":"notebooks/forcats_misc/#fct_match","title":"fct_match\u00b6","text":""},{"location":"notebooks/forcats_misc/#fct_unique","title":"fct_unique\u00b6","text":""},{"location":"notebooks/forcats_misc/#lvls_reorder-lvls_revalue-and-lvls_expand","title":"lvls_reorder, lvls_revalue and lvls_expand\u00b6","text":""},{"location":"notebooks/forcats_misc/#lvls_union","title":"lvls_union\u00b6","text":""},{"location":"notebooks/full_seq/","title":"full_seq","text":"In\u00a0[1]: Copied! <pre># https://tidyr.tidyverse.org/reference/full_seq.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(full_seq)\n</pre> # https://tidyr.tidyverse.org/reference/full_seq.html %run nb_helpers.py  from datar.all import *  nb_header(full_seq) Try this notebook on binder. In\u00a0[2]: Copied! <pre>full_seq(c(1, 2, 4, 5, 10), 1)\n</pre> full_seq(c(1, 2, 4, 5, 10), 1) Out[2]: <pre>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/full_seq/#full_seq","title":"\u2605 full_seq\u00b6","text":""},{"location":"notebooks/full_seq/#create-the-full-sequence-of-values-in-a-vector","title":"Create the full sequence of values in a vector\u00b6","text":""},{"location":"notebooks/full_seq/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector. <code>period</code>: Gap between each observation. The existing data will be \u2003\u2003\u2003\u2003checked to ensure that it is actually of this periodicity.</p> <p> <code>tol</code>: Numerical tolerance for checking periodicity.</p>"},{"location":"notebooks/full_seq/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The full sequence</p>"},{"location":"notebooks/group_by/","title":"group_by","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/group_by.html\n%run nb_helpers.py\n\nfrom datar.data import mtcars\nfrom datar.all import *\n\nnb_header(group_by, ungroup)\n</pre> # https://dplyr.tidyverse.org/reference/group_by.html %run nb_helpers.py  from datar.data import mtcars from datar.all import *  nb_header(group_by, ungroup) Try this notebook on binder. In\u00a0[2]: Copied! <pre>by_cyl = mtcars &gt;&gt; group_by(f.cyl) \nby_cyl\n</pre> by_cyl = mtcars &gt;&gt; group_by(f.cyl)  by_cyl Out[2]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 1 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 2 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 3 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 4 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 5 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 6 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 7 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 8 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 9 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 10 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 11 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 12 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 13 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 14 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 15 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 16 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 17 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 18 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 19 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 20 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 21 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 22 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 23 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 24 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 25 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 26 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 27 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 28 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 29 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 30 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 31 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 <p>TibbleGrouped: cyl (n=3) </p> In\u00a0[3]: Copied! <pre>by_cyl &gt;&gt; group_vars()\n</pre> by_cyl &gt;&gt; group_vars() Out[3]: <pre>['cyl']</pre> In\u00a0[4]: Copied! <pre>by_cyl &gt;&gt; summarise(\n  disp = mean(f.disp),\n  hp = mean(f.hp)\n)\n</pre> by_cyl &gt;&gt; summarise(   disp = mean(f.disp),   hp = mean(f.hp) ) Out[4]: cyl disp hp &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; 0 6 183.314286 122.285714 1 4 105.136364 82.636364 2 8 353.100000 209.214286 In\u00a0[5]: Copied! <pre>by_cyl &gt;&gt; summarise(\n  disp = f.disp.mean(),\n  hp = f.hp.mean()\n)\n</pre> by_cyl &gt;&gt; summarise(   disp = f.disp.mean(),   hp = f.hp.mean() ) Out[5]: cyl disp hp &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; 0 6 183.314286 122.285714 1 4 105.136364 82.636364 2 8 353.100000 209.214286 In\u00a0[6]: Copied! <pre>by_cyl &gt;&gt; filter(f.disp == max(f.disp))\n</pre> by_cyl &gt;&gt; filter(f.disp == max(f.disp)) Out[6]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 1 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 2 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 <p>TibbleGrouped: cyl (n=3) </p> In\u00a0[7]: Copied! <pre>by_vs_am = mtcars &gt;&gt; group_by(f.vs, f.am)\nby_vs = by_vs_am &gt;&gt; summarise(n=n())\nby_vs\n</pre> by_vs_am = mtcars &gt;&gt; group_by(f.vs, f.am) by_vs = by_vs_am &gt;&gt; summarise(n=n()) by_vs <pre>[2022-12-02 14:03:28][datar][   INFO] `summarise()` has grouped output by ['vs'] (override with `_groups` argument)\n</pre> Out[7]: vs am n &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 0 1 6 1 1 1 7 2 1 0 7 3 0 0 12 <p>TibbleGrouped: vs (n=2) </p> In\u00a0[8]: Copied! <pre>by_vs &gt;&gt; summarise(n=sum(f.n))\n</pre> by_vs &gt;&gt; summarise(n=sum(f.n)) Out[8]: vs n &lt;int64&gt; &lt;int64&gt; 0 0 18 1 1 14 In\u00a0[9]: Copied! <pre>by_vs &gt;&gt; \\\n  ungroup() &gt;&gt; \\\n  summarise(n = sum(f.n))\n</pre> by_vs &gt;&gt; \\   ungroup() &gt;&gt; \\   summarise(n = sum(f.n)) Out[9]: n &lt;int64&gt; 0 32 In\u00a0[10]: Copied! <pre>mtcars_vsam = mtcars &gt;&gt; group_by(vsam=f.vs + f.am) \nmtcars_vsam \n</pre> mtcars_vsam = mtcars &gt;&gt; group_by(vsam=f.vs + f.am)  mtcars_vsam  Out[10]: mpg cyl disp hp drat wt qsec vs am gear carb vsam &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 1 1 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 1 2 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 2 3 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 1 4 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 0 5 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 1 6 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 0 7 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 1 8 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 1 9 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 1 10 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 1 11 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 0 12 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 0 13 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 0 14 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 0 15 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 0 16 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 0 17 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 2 18 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 2 19 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 2 20 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 1 21 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 0 22 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 0 23 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 0 24 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 0 25 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 2 26 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 1 27 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 2 28 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 1 29 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 1 30 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 1 31 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 2 <p>TibbleGrouped: vsam (n=3) </p> In\u00a0[11]: Copied! <pre>by_cyl &gt;&gt; \\\n  group_by(f.vs, f.am) &gt;&gt; \\\n  group_vars()\n</pre> by_cyl &gt;&gt; \\   group_by(f.vs, f.am) &gt;&gt; \\   group_vars() Out[11]: <pre>['vs', 'am']</pre> In\u00a0[12]: Copied! <pre>by_cyl &gt;&gt; \\\n  group_by(f.vs, f.am, _add=True) &gt;&gt; \\\n  group_vars()\n</pre> by_cyl &gt;&gt; \\   group_by(f.vs, f.am, _add=True) &gt;&gt; \\   group_vars() Out[12]: <pre>['cyl', 'vs', 'am']</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/group_by/#group_by","title":"\u2605 group_by\u00b6","text":""},{"location":"notebooks/group_by/#create-a-grouped-frame","title":"Create a grouped frame\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/group_by.html</p>"},{"location":"notebooks/group_by/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>*args</code>: A variable or function of variables to group by. <code>_add</code>: If <code>True</code>, add grouping variables to an existing group. <code>_drop</code>: If <code>True</code>, drop grouping variables from the output.</p>"},{"location":"notebooks/group_by/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A grouped frame</p>"},{"location":"notebooks/group_by/#ungroup","title":"\u2605 ungroup\u00b6","text":""},{"location":"notebooks/group_by/#remove-grouping-variables","title":"Remove grouping variables\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/ungroup.html</p>"},{"location":"notebooks/group_by/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A grouped frame <code>*cols</code>: Columns to remove grouping variables from.</p>"},{"location":"notebooks/group_by/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame</p>"},{"location":"notebooks/group_map/","title":"group_map","text":"In\u00a0[2]: Copied! <pre># https://dplyr.tidyverse.org/reference/group_map.html\n%run nb_helpers.py\n\nfrom datar.data import mtcars, iris\nfrom datar.all import *\n\nnb_header(group_map)\n</pre> # https://dplyr.tidyverse.org/reference/group_map.html %run nb_helpers.py  from datar.data import mtcars, iris from datar.all import *  nb_header(group_map) Try this notebook on binder. In\u00a0[3]: Copied! <pre>list(\n  mtcars &gt;&gt; \\\n  group_by(f.cyl) &gt;&gt; \\\n  group_map(lambda df: df &gt;&gt; head(2))\n)\n</pre> list(   mtcars &gt;&gt; \\   group_by(f.cyl) &gt;&gt; \\   group_map(lambda df: df &gt;&gt; head(2)) )  Out[3]: <pre>[        mpg      disp      hp      drat  ...      vs      am    gear    carb\n   &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt;  ... &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt;\n 0      21.0     160.0     110       3.9  ...       0       1       4       4\n 1      21.0     160.0     110       3.9            0       1       4       4\n \n [2 rows x 10 columns],\n         mpg      disp      hp      drat  ...      vs      am    gear    carb\n   &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt;  ... &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt;\n 0      22.8     108.0      93      3.85  ...       1       1       4       1\n 1      24.4     146.7      62      3.69            1       0       4       2\n \n [2 rows x 10 columns],\n         mpg      disp      hp      drat  ...      vs      am    gear    carb\n   &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt;  ... &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt;\n 0      18.7     360.0     175      3.15  ...       0       0       3       2\n 1      14.3     360.0     245      3.21            0       0       3       4\n \n [2 rows x 10 columns]]</pre> In\u00a0[4]: Copied! <pre>mtcars &gt;&gt; \\\n  group_by(f.cyl) &gt;&gt; \\\n  group_modify(lambda df: df &gt;&gt; head(2))\n</pre>  mtcars &gt;&gt; \\   group_by(f.cyl) &gt;&gt; \\   group_modify(lambda df: df &gt;&gt; head(2)) Out[4]: cyl mpg disp hp drat wt qsec vs am gear carb &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 6 21.0 160.0 110 3.90 2.620 16.46 0 1 4 4 1 6 21.0 160.0 110 3.90 2.875 17.02 0 1 4 4 0 4 22.8 108.0 93 3.85 2.320 18.61 1 1 4 1 1 4 24.4 146.7 62 3.69 3.190 20.00 1 0 4 2 0 8 18.7 360.0 175 3.15 3.440 17.02 0 0 3 2 1 8 14.3 360.0 245 3.21 3.570 15.84 0 0 3 4 <p>TibbleGrouped: cyl (n=3) </p> In\u00a0[5]: Copied! <pre>list(\n  iris &gt;&gt; \\\n  group_by(f.Species) &gt;&gt; \\\n  group_map(lambda df: quantile(df['Petal_Length'], probs=c(0.25, 0.5, 0.75)))\n)\n</pre> list(   iris &gt;&gt; \\   group_by(f.Species) &gt;&gt; \\   group_map(lambda df: quantile(df['Petal_Length'], probs=c(0.25, 0.5, 0.75))) ) Out[5]: <pre>[array([1.4  , 1.5  , 1.575]),\n array([4.  , 4.35, 4.6 ]),\n array([5.1  , 5.55 , 5.875])]</pre> In\u00a0[6]: Copied! <pre>iris &gt;&gt; \\\n  group_by(f.Species) &gt;&gt; \\\n  group_walk(lambda df: print(df.shape))\n</pre> iris &gt;&gt; \\   group_by(f.Species) &gt;&gt; \\   group_walk(lambda df: print(df.shape)) <pre>(50, 4)\n(50, 4)\n(50, 4)\n</pre> In\u00a0[7]: Copied! <pre>mtcars &gt;&gt; \\\n  group_modify(lambda df: df &gt;&gt; head(2))\n</pre> mtcars &gt;&gt; \\   group_modify(lambda df: df &gt;&gt; head(2)) Out[7]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Mazda RX4 21.0 6 160.0 110 3.9 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.9 2.875 17.02 0 1 4 4 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/group_map/#group_map","title":"\u2605 group_map\u00b6","text":""},{"location":"notebooks/group_map/#apply-a-function-to-each-group","title":"Apply a function to each group\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/group_map.html</p>"},{"location":"notebooks/group_map/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A grouped frame <code>_f</code>: A function to apply to each group. <code>*args</code>: Additional arguments to pass to <code>func</code>. <code>_keep</code>: If <code>True</code>, keep the grouping variables in the output. <code>**kwargs</code>: Additional keyword arguments to pass to <code>func</code>.</p>"},{"location":"notebooks/group_map/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A list of results</p>"},{"location":"notebooks/group_split/","title":"group_split","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/group_split.html\n%run nb_helpers.py\n\nfrom datar.data import iris\nfrom datar.all import *\n\nnb_header(group_split)\n</pre> # https://dplyr.tidyverse.org/reference/group_split.html %run nb_helpers.py  from datar.data import iris from datar.all import *  nb_header(group_split) Try this notebook on binder. In\u00a0[2]: Copied! <pre>ir = iris &gt;&gt; group_by(f.Species)\n\nlist(group_split(ir))\n</pre> ir = iris &gt;&gt; group_by(f.Species)  list(group_split(ir)) Out[2]: <pre>[    Sepal_Length  Sepal_Width  Petal_Length  Petal_Width  Species\n        &lt;float64&gt;    &lt;float64&gt;     &lt;float64&gt;    &lt;float64&gt; &lt;object&gt;\n 0            5.1          3.5           1.4          0.2   setosa\n 1            4.9          3.0           1.4          0.2   setosa\n 2            4.7          3.2           1.3          0.2   setosa\n 3            4.6          3.1           1.5          0.2   setosa\n 4            5.0          3.6           1.4          0.2   setosa\n 5            5.4          3.9           1.7          0.4   setosa\n 6            4.6          3.4           1.4          0.3   setosa\n 7            5.0          3.4           1.5          0.2   setosa\n 8            4.4          2.9           1.4          0.2   setosa\n 9            4.9          3.1           1.5          0.1   setosa\n 10           5.4          3.7           1.5          0.2   setosa\n 11           4.8          3.4           1.6          0.2   setosa\n 12           4.8          3.0           1.4          0.1   setosa\n 13           4.3          3.0           1.1          0.1   setosa\n 14           5.8          4.0           1.2          0.2   setosa\n 15           5.7          4.4           1.5          0.4   setosa\n 16           5.4          3.9           1.3          0.4   setosa\n 17           5.1          3.5           1.4          0.3   setosa\n 18           5.7          3.8           1.7          0.3   setosa\n 19           5.1          3.8           1.5          0.3   setosa\n 20           5.4          3.4           1.7          0.2   setosa\n 21           5.1          3.7           1.5          0.4   setosa\n 22           4.6          3.6           1.0          0.2   setosa\n 23           5.1          3.3           1.7          0.5   setosa\n 24           4.8          3.4           1.9          0.2   setosa\n 25           5.0          3.0           1.6          0.2   setosa\n 26           5.0          3.4           1.6          0.4   setosa\n 27           5.2          3.5           1.5          0.2   setosa\n 28           5.2          3.4           1.4          0.2   setosa\n 29           4.7          3.2           1.6          0.2   setosa\n 30           4.8          3.1           1.6          0.2   setosa\n 31           5.4          3.4           1.5          0.4   setosa\n 32           5.2          4.1           1.5          0.1   setosa\n 33           5.5          4.2           1.4          0.2   setosa\n 34           4.9          3.1           1.5          0.2   setosa\n 35           5.0          3.2           1.2          0.2   setosa\n 36           5.5          3.5           1.3          0.2   setosa\n 37           4.9          3.6           1.4          0.1   setosa\n 38           4.4          3.0           1.3          0.2   setosa\n 39           5.1          3.4           1.5          0.2   setosa\n 40           5.0          3.5           1.3          0.3   setosa\n 41           4.5          2.3           1.3          0.3   setosa\n 42           4.4          3.2           1.3          0.2   setosa\n 43           5.0          3.5           1.6          0.6   setosa\n 44           5.1          3.8           1.9          0.4   setosa\n 45           4.8          3.0           1.4          0.3   setosa\n 46           5.1          3.8           1.6          0.2   setosa\n 47           4.6          3.2           1.4          0.2   setosa\n 48           5.3          3.7           1.5          0.2   setosa\n 49           5.0          3.3           1.4          0.2   setosa,\n     Sepal_Length  Sepal_Width  Petal_Length  Petal_Width     Species\n        &lt;float64&gt;    &lt;float64&gt;     &lt;float64&gt;    &lt;float64&gt;    &lt;object&gt;\n 0            7.0          3.2           4.7          1.4  versicolor\n 1            6.4          3.2           4.5          1.5  versicolor\n 2            6.9          3.1           4.9          1.5  versicolor\n 3            5.5          2.3           4.0          1.3  versicolor\n 4            6.5          2.8           4.6          1.5  versicolor\n 5            5.7          2.8           4.5          1.3  versicolor\n 6            6.3          3.3           4.7          1.6  versicolor\n 7            4.9          2.4           3.3          1.0  versicolor\n 8            6.6          2.9           4.6          1.3  versicolor\n 9            5.2          2.7           3.9          1.4  versicolor\n 10           5.0          2.0           3.5          1.0  versicolor\n 11           5.9          3.0           4.2          1.5  versicolor\n 12           6.0          2.2           4.0          1.0  versicolor\n 13           6.1          2.9           4.7          1.4  versicolor\n 14           5.6          2.9           3.6          1.3  versicolor\n 15           6.7          3.1           4.4          1.4  versicolor\n 16           5.6          3.0           4.5          1.5  versicolor\n 17           5.8          2.7           4.1          1.0  versicolor\n 18           6.2          2.2           4.5          1.5  versicolor\n 19           5.6          2.5           3.9          1.1  versicolor\n 20           5.9          3.2           4.8          1.8  versicolor\n 21           6.1          2.8           4.0          1.3  versicolor\n 22           6.3          2.5           4.9          1.5  versicolor\n 23           6.1          2.8           4.7          1.2  versicolor\n 24           6.4          2.9           4.3          1.3  versicolor\n 25           6.6          3.0           4.4          1.4  versicolor\n 26           6.8          2.8           4.8          1.4  versicolor\n 27           6.7          3.0           5.0          1.7  versicolor\n 28           6.0          2.9           4.5          1.5  versicolor\n 29           5.7          2.6           3.5          1.0  versicolor\n 30           5.5          2.4           3.8          1.1  versicolor\n 31           5.5          2.4           3.7          1.0  versicolor\n 32           5.8          2.7           3.9          1.2  versicolor\n 33           6.0          2.7           5.1          1.6  versicolor\n 34           5.4          3.0           4.5          1.5  versicolor\n 35           6.0          3.4           4.5          1.6  versicolor\n 36           6.7          3.1           4.7          1.5  versicolor\n 37           6.3          2.3           4.4          1.3  versicolor\n 38           5.6          3.0           4.1          1.3  versicolor\n 39           5.5          2.5           4.0          1.3  versicolor\n 40           5.5          2.6           4.4          1.2  versicolor\n 41           6.1          3.0           4.6          1.4  versicolor\n 42           5.8          2.6           4.0          1.2  versicolor\n 43           5.0          2.3           3.3          1.0  versicolor\n 44           5.6          2.7           4.2          1.3  versicolor\n 45           5.7          3.0           4.2          1.2  versicolor\n 46           5.7          2.9           4.2          1.3  versicolor\n 47           6.2          2.9           4.3          1.3  versicolor\n 48           5.1          2.5           3.0          1.1  versicolor\n 49           5.7          2.8           4.1          1.3  versicolor,\n     Sepal_Length  Sepal_Width  Petal_Length  Petal_Width    Species\n        &lt;float64&gt;    &lt;float64&gt;     &lt;float64&gt;    &lt;float64&gt;   &lt;object&gt;\n 0            6.3          3.3           6.0          2.5  virginica\n 1            5.8          2.7           5.1          1.9  virginica\n 2            7.1          3.0           5.9          2.1  virginica\n 3            6.3          2.9           5.6          1.8  virginica\n 4            6.5          3.0           5.8          2.2  virginica\n 5            7.6          3.0           6.6          2.1  virginica\n 6            4.9          2.5           4.5          1.7  virginica\n 7            7.3          2.9           6.3          1.8  virginica\n 8            6.7          2.5           5.8          1.8  virginica\n 9            7.2          3.6           6.1          2.5  virginica\n 10           6.5          3.2           5.1          2.0  virginica\n 11           6.4          2.7           5.3          1.9  virginica\n 12           6.8          3.0           5.5          2.1  virginica\n 13           5.7          2.5           5.0          2.0  virginica\n 14           5.8          2.8           5.1          2.4  virginica\n 15           6.4          3.2           5.3          2.3  virginica\n 16           6.5          3.0           5.5          1.8  virginica\n 17           7.7          3.8           6.7          2.2  virginica\n 18           7.7          2.6           6.9          2.3  virginica\n 19           6.0          2.2           5.0          1.5  virginica\n 20           6.9          3.2           5.7          2.3  virginica\n 21           5.6          2.8           4.9          2.0  virginica\n 22           7.7          2.8           6.7          2.0  virginica\n 23           6.3          2.7           4.9          1.8  virginica\n 24           6.7          3.3           5.7          2.1  virginica\n 25           7.2          3.2           6.0          1.8  virginica\n 26           6.2          2.8           4.8          1.8  virginica\n 27           6.1          3.0           4.9          1.8  virginica\n 28           6.4          2.8           5.6          2.1  virginica\n 29           7.2          3.0           5.8          1.6  virginica\n 30           7.4          2.8           6.1          1.9  virginica\n 31           7.9          3.8           6.4          2.0  virginica\n 32           6.4          2.8           5.6          2.2  virginica\n 33           6.3          2.8           5.1          1.5  virginica\n 34           6.1          2.6           5.6          1.4  virginica\n 35           7.7          3.0           6.1          2.3  virginica\n 36           6.3          3.4           5.6          2.4  virginica\n 37           6.4          3.1           5.5          1.8  virginica\n 38           6.0          3.0           4.8          1.8  virginica\n 39           6.9          3.1           5.4          2.1  virginica\n 40           6.7          3.1           5.6          2.4  virginica\n 41           6.9          3.1           5.1          2.3  virginica\n 42           5.8          2.7           5.1          1.9  virginica\n 43           6.8          3.2           5.9          2.3  virginica\n 44           6.7          3.3           5.7          2.5  virginica\n 45           6.7          3.0           5.2          2.3  virginica\n 46           6.3          2.5           5.0          1.9  virginica\n 47           6.5          3.0           5.2          2.0  virginica\n 48           6.2          3.4           5.4          2.3  virginica\n 49           5.9          3.0           5.1          1.8  virginica]</pre> In\u00a0[3]: Copied! <pre>group_keys(ir)\n</pre> group_keys(ir) Out[3]: Species &lt;object&gt; 0 setosa 1 versicolor 2 virginica In\u00a0[4]: Copied! <pre>ir = iris &gt;&gt; \\\n  group_by(f.Species) &gt;&gt; \\\n  filter(f['Sepal_Length'] &gt; mean(f['Sepal_Length']))\nlist(group_split(ir))\n</pre> ir = iris &gt;&gt; \\   group_by(f.Species) &gt;&gt; \\   filter(f['Sepal_Length'] &gt; mean(f['Sepal_Length'])) list(group_split(ir)) Out[4]: <pre>[    Sepal_Length  Sepal_Width  Petal_Length  Petal_Width  Species\n        &lt;float64&gt;    &lt;float64&gt;     &lt;float64&gt;    &lt;float64&gt; &lt;object&gt;\n 0            5.1          3.5           1.4          0.2   setosa\n 1            5.4          3.9           1.7          0.4   setosa\n 2            5.4          3.7           1.5          0.2   setosa\n 3            5.8          4.0           1.2          0.2   setosa\n 4            5.7          4.4           1.5          0.4   setosa\n 5            5.4          3.9           1.3          0.4   setosa\n 6            5.1          3.5           1.4          0.3   setosa\n 7            5.7          3.8           1.7          0.3   setosa\n 8            5.1          3.8           1.5          0.3   setosa\n 9            5.4          3.4           1.7          0.2   setosa\n 10           5.1          3.7           1.5          0.4   setosa\n 11           5.1          3.3           1.7          0.5   setosa\n 12           5.2          3.5           1.5          0.2   setosa\n 13           5.2          3.4           1.4          0.2   setosa\n 14           5.4          3.4           1.5          0.4   setosa\n 15           5.2          4.1           1.5          0.1   setosa\n 16           5.5          4.2           1.4          0.2   setosa\n 17           5.5          3.5           1.3          0.2   setosa\n 18           5.1          3.4           1.5          0.2   setosa\n 19           5.1          3.8           1.9          0.4   setosa\n 20           5.1          3.8           1.6          0.2   setosa\n 21           5.3          3.7           1.5          0.2   setosa,\n     Sepal_Length  Sepal_Width  Petal_Length  Petal_Width     Species\n        &lt;float64&gt;    &lt;float64&gt;     &lt;float64&gt;    &lt;float64&gt;    &lt;object&gt;\n 0            7.0          3.2           4.7          1.4  versicolor\n 1            6.4          3.2           4.5          1.5  versicolor\n 2            6.9          3.1           4.9          1.5  versicolor\n 3            6.5          2.8           4.6          1.5  versicolor\n 4            6.3          3.3           4.7          1.6  versicolor\n 5            6.6          2.9           4.6          1.3  versicolor\n 6            6.0          2.2           4.0          1.0  versicolor\n 7            6.1          2.9           4.7          1.4  versicolor\n 8            6.7          3.1           4.4          1.4  versicolor\n 9            6.2          2.2           4.5          1.5  versicolor\n 10           6.1          2.8           4.0          1.3  versicolor\n 11           6.3          2.5           4.9          1.5  versicolor\n 12           6.1          2.8           4.7          1.2  versicolor\n 13           6.4          2.9           4.3          1.3  versicolor\n 14           6.6          3.0           4.4          1.4  versicolor\n 15           6.8          2.8           4.8          1.4  versicolor\n 16           6.7          3.0           5.0          1.7  versicolor\n 17           6.0          2.9           4.5          1.5  versicolor\n 18           6.0          2.7           5.1          1.6  versicolor\n 19           6.0          3.4           4.5          1.6  versicolor\n 20           6.7          3.1           4.7          1.5  versicolor\n 21           6.3          2.3           4.4          1.3  versicolor\n 22           6.1          3.0           4.6          1.4  versicolor\n 23           6.2          2.9           4.3          1.3  versicolor,\n     Sepal_Length  Sepal_Width  Petal_Length  Petal_Width    Species\n        &lt;float64&gt;    &lt;float64&gt;     &lt;float64&gt;    &lt;float64&gt;   &lt;object&gt;\n 0            7.1          3.0           5.9          2.1  virginica\n 1            7.6          3.0           6.6          2.1  virginica\n 2            7.3          2.9           6.3          1.8  virginica\n 3            6.7          2.5           5.8          1.8  virginica\n 4            7.2          3.6           6.1          2.5  virginica\n 5            6.8          3.0           5.5          2.1  virginica\n 6            7.7          3.8           6.7          2.2  virginica\n 7            7.7          2.6           6.9          2.3  virginica\n 8            6.9          3.2           5.7          2.3  virginica\n 9            7.7          2.8           6.7          2.0  virginica\n 10           6.7          3.3           5.7          2.1  virginica\n 11           7.2          3.2           6.0          1.8  virginica\n 12           7.2          3.0           5.8          1.6  virginica\n 13           7.4          2.8           6.1          1.9  virginica\n 14           7.9          3.8           6.4          2.0  virginica\n 15           7.7          3.0           6.1          2.3  virginica\n 16           6.9          3.1           5.4          2.1  virginica\n 17           6.7          3.1           5.6          2.4  virginica\n 18           6.9          3.1           5.1          2.3  virginica\n 19           6.8          3.2           5.9          2.3  virginica\n 20           6.7          3.3           5.7          2.5  virginica\n 21           6.7          3.0           5.2          2.3  virginica]</pre> In\u00a0[5]: Copied! <pre>group_keys(ir)\n</pre> group_keys(ir) Out[5]: Species &lt;object&gt; 0 setosa 1 versicolor 2 virginica In\u00a0[6]: Copied! <pre>list(iris &gt;&gt; group_split(f.Species))\n</pre> list(iris &gt;&gt; group_split(f.Species)) Out[6]: <pre>[    Sepal_Length  Sepal_Width  Petal_Length  Petal_Width  Species\n        &lt;float64&gt;    &lt;float64&gt;     &lt;float64&gt;    &lt;float64&gt; &lt;object&gt;\n 0            5.1          3.5           1.4          0.2   setosa\n 1            4.9          3.0           1.4          0.2   setosa\n 2            4.7          3.2           1.3          0.2   setosa\n 3            4.6          3.1           1.5          0.2   setosa\n 4            5.0          3.6           1.4          0.2   setosa\n 5            5.4          3.9           1.7          0.4   setosa\n 6            4.6          3.4           1.4          0.3   setosa\n 7            5.0          3.4           1.5          0.2   setosa\n 8            4.4          2.9           1.4          0.2   setosa\n 9            4.9          3.1           1.5          0.1   setosa\n 10           5.4          3.7           1.5          0.2   setosa\n 11           4.8          3.4           1.6          0.2   setosa\n 12           4.8          3.0           1.4          0.1   setosa\n 13           4.3          3.0           1.1          0.1   setosa\n 14           5.8          4.0           1.2          0.2   setosa\n 15           5.7          4.4           1.5          0.4   setosa\n 16           5.4          3.9           1.3          0.4   setosa\n 17           5.1          3.5           1.4          0.3   setosa\n 18           5.7          3.8           1.7          0.3   setosa\n 19           5.1          3.8           1.5          0.3   setosa\n 20           5.4          3.4           1.7          0.2   setosa\n 21           5.1          3.7           1.5          0.4   setosa\n 22           4.6          3.6           1.0          0.2   setosa\n 23           5.1          3.3           1.7          0.5   setosa\n 24           4.8          3.4           1.9          0.2   setosa\n 25           5.0          3.0           1.6          0.2   setosa\n 26           5.0          3.4           1.6          0.4   setosa\n 27           5.2          3.5           1.5          0.2   setosa\n 28           5.2          3.4           1.4          0.2   setosa\n 29           4.7          3.2           1.6          0.2   setosa\n 30           4.8          3.1           1.6          0.2   setosa\n 31           5.4          3.4           1.5          0.4   setosa\n 32           5.2          4.1           1.5          0.1   setosa\n 33           5.5          4.2           1.4          0.2   setosa\n 34           4.9          3.1           1.5          0.2   setosa\n 35           5.0          3.2           1.2          0.2   setosa\n 36           5.5          3.5           1.3          0.2   setosa\n 37           4.9          3.6           1.4          0.1   setosa\n 38           4.4          3.0           1.3          0.2   setosa\n 39           5.1          3.4           1.5          0.2   setosa\n 40           5.0          3.5           1.3          0.3   setosa\n 41           4.5          2.3           1.3          0.3   setosa\n 42           4.4          3.2           1.3          0.2   setosa\n 43           5.0          3.5           1.6          0.6   setosa\n 44           5.1          3.8           1.9          0.4   setosa\n 45           4.8          3.0           1.4          0.3   setosa\n 46           5.1          3.8           1.6          0.2   setosa\n 47           4.6          3.2           1.4          0.2   setosa\n 48           5.3          3.7           1.5          0.2   setosa\n 49           5.0          3.3           1.4          0.2   setosa,\n     Sepal_Length  Sepal_Width  Petal_Length  Petal_Width     Species\n        &lt;float64&gt;    &lt;float64&gt;     &lt;float64&gt;    &lt;float64&gt;    &lt;object&gt;\n 0            7.0          3.2           4.7          1.4  versicolor\n 1            6.4          3.2           4.5          1.5  versicolor\n 2            6.9          3.1           4.9          1.5  versicolor\n 3            5.5          2.3           4.0          1.3  versicolor\n 4            6.5          2.8           4.6          1.5  versicolor\n 5            5.7          2.8           4.5          1.3  versicolor\n 6            6.3          3.3           4.7          1.6  versicolor\n 7            4.9          2.4           3.3          1.0  versicolor\n 8            6.6          2.9           4.6          1.3  versicolor\n 9            5.2          2.7           3.9          1.4  versicolor\n 10           5.0          2.0           3.5          1.0  versicolor\n 11           5.9          3.0           4.2          1.5  versicolor\n 12           6.0          2.2           4.0          1.0  versicolor\n 13           6.1          2.9           4.7          1.4  versicolor\n 14           5.6          2.9           3.6          1.3  versicolor\n 15           6.7          3.1           4.4          1.4  versicolor\n 16           5.6          3.0           4.5          1.5  versicolor\n 17           5.8          2.7           4.1          1.0  versicolor\n 18           6.2          2.2           4.5          1.5  versicolor\n 19           5.6          2.5           3.9          1.1  versicolor\n 20           5.9          3.2           4.8          1.8  versicolor\n 21           6.1          2.8           4.0          1.3  versicolor\n 22           6.3          2.5           4.9          1.5  versicolor\n 23           6.1          2.8           4.7          1.2  versicolor\n 24           6.4          2.9           4.3          1.3  versicolor\n 25           6.6          3.0           4.4          1.4  versicolor\n 26           6.8          2.8           4.8          1.4  versicolor\n 27           6.7          3.0           5.0          1.7  versicolor\n 28           6.0          2.9           4.5          1.5  versicolor\n 29           5.7          2.6           3.5          1.0  versicolor\n 30           5.5          2.4           3.8          1.1  versicolor\n 31           5.5          2.4           3.7          1.0  versicolor\n 32           5.8          2.7           3.9          1.2  versicolor\n 33           6.0          2.7           5.1          1.6  versicolor\n 34           5.4          3.0           4.5          1.5  versicolor\n 35           6.0          3.4           4.5          1.6  versicolor\n 36           6.7          3.1           4.7          1.5  versicolor\n 37           6.3          2.3           4.4          1.3  versicolor\n 38           5.6          3.0           4.1          1.3  versicolor\n 39           5.5          2.5           4.0          1.3  versicolor\n 40           5.5          2.6           4.4          1.2  versicolor\n 41           6.1          3.0           4.6          1.4  versicolor\n 42           5.8          2.6           4.0          1.2  versicolor\n 43           5.0          2.3           3.3          1.0  versicolor\n 44           5.6          2.7           4.2          1.3  versicolor\n 45           5.7          3.0           4.2          1.2  versicolor\n 46           5.7          2.9           4.2          1.3  versicolor\n 47           6.2          2.9           4.3          1.3  versicolor\n 48           5.1          2.5           3.0          1.1  versicolor\n 49           5.7          2.8           4.1          1.3  versicolor,\n     Sepal_Length  Sepal_Width  Petal_Length  Petal_Width    Species\n        &lt;float64&gt;    &lt;float64&gt;     &lt;float64&gt;    &lt;float64&gt;   &lt;object&gt;\n 0            6.3          3.3           6.0          2.5  virginica\n 1            5.8          2.7           5.1          1.9  virginica\n 2            7.1          3.0           5.9          2.1  virginica\n 3            6.3          2.9           5.6          1.8  virginica\n 4            6.5          3.0           5.8          2.2  virginica\n 5            7.6          3.0           6.6          2.1  virginica\n 6            4.9          2.5           4.5          1.7  virginica\n 7            7.3          2.9           6.3          1.8  virginica\n 8            6.7          2.5           5.8          1.8  virginica\n 9            7.2          3.6           6.1          2.5  virginica\n 10           6.5          3.2           5.1          2.0  virginica\n 11           6.4          2.7           5.3          1.9  virginica\n 12           6.8          3.0           5.5          2.1  virginica\n 13           5.7          2.5           5.0          2.0  virginica\n 14           5.8          2.8           5.1          2.4  virginica\n 15           6.4          3.2           5.3          2.3  virginica\n 16           6.5          3.0           5.5          1.8  virginica\n 17           7.7          3.8           6.7          2.2  virginica\n 18           7.7          2.6           6.9          2.3  virginica\n 19           6.0          2.2           5.0          1.5  virginica\n 20           6.9          3.2           5.7          2.3  virginica\n 21           5.6          2.8           4.9          2.0  virginica\n 22           7.7          2.8           6.7          2.0  virginica\n 23           6.3          2.7           4.9          1.8  virginica\n 24           6.7          3.3           5.7          2.1  virginica\n 25           7.2          3.2           6.0          1.8  virginica\n 26           6.2          2.8           4.8          1.8  virginica\n 27           6.1          3.0           4.9          1.8  virginica\n 28           6.4          2.8           5.6          2.1  virginica\n 29           7.2          3.0           5.8          1.6  virginica\n 30           7.4          2.8           6.1          1.9  virginica\n 31           7.9          3.8           6.4          2.0  virginica\n 32           6.4          2.8           5.6          2.2  virginica\n 33           6.3          2.8           5.1          1.5  virginica\n 34           6.1          2.6           5.6          1.4  virginica\n 35           7.7          3.0           6.1          2.3  virginica\n 36           6.3          3.4           5.6          2.4  virginica\n 37           6.4          3.1           5.5          1.8  virginica\n 38           6.0          3.0           4.8          1.8  virginica\n 39           6.9          3.1           5.4          2.1  virginica\n 40           6.7          3.1           5.6          2.4  virginica\n 41           6.9          3.1           5.1          2.3  virginica\n 42           5.8          2.7           5.1          1.9  virginica\n 43           6.8          3.2           5.9          2.3  virginica\n 44           6.7          3.3           5.7          2.5  virginica\n 45           6.7          3.0           5.2          2.3  virginica\n 46           6.3          2.5           5.0          1.9  virginica\n 47           6.5          3.0           5.2          2.0  virginica\n 48           6.2          3.4           5.4          2.3  virginica\n 49           5.9          3.0           5.1          1.8  virginica]</pre> In\u00a0[7]: Copied! <pre># group_keys(...) deprecated in dplyr\niris &gt;&gt; group_by(f.Species) &gt;&gt; group_keys()\n</pre> # group_keys(...) deprecated in dplyr iris &gt;&gt; group_by(f.Species) &gt;&gt; group_keys() Out[7]: Species &lt;object&gt; 0 setosa 1 versicolor 2 virginica In\u00a0[8]: Copied! <pre>out = iris &gt;&gt; group_by(f.Species) &gt;&gt; group_keys() &gt;&gt; rowwise() &gt;&gt; group_split()\nout\n</pre> out = iris &gt;&gt; group_by(f.Species) &gt;&gt; group_keys() &gt;&gt; rowwise() &gt;&gt; group_split() out <pre>[2022-12-02 14:07:59][datar][WARNING] `_keep` is ignored in `group_split(&lt;TibbleRowwise&gt;)`.\n</pre> Out[8]: <pre>&lt;generator object group_split_impl at 0x7f4457822190&gt;</pre> In\u00a0[9]: Copied! <pre>list(out)\n</pre> list(out) Out[9]: <pre>[   Species\n   &lt;object&gt;\n 0   setosa,\n       Species\n      &lt;object&gt;\n 0  versicolor,\n      Species\n     &lt;object&gt;\n 0  virginica]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/group_split/#group_split","title":"\u2605 group_split\u00b6","text":""},{"location":"notebooks/group_split/#split-a-grouped-frame-into-a-list-of-data-frames","title":"Split a grouped frame into a list of data frames\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/group_split.html</p>"},{"location":"notebooks/group_split/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A grouped frame <code>*args</code>: Additional arguments to pass to <code>func</code>. <code>_keep</code>: If <code>True</code>, keep the grouping variables in the output. <code>**kwargs</code>: Additional keyword arguments to pass to <code>func</code>.</p>"},{"location":"notebooks/group_split/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A list of data frames</p>"},{"location":"notebooks/group_trim/","title":"group_trim","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/group_trim.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(group_trim)\n</pre> # https://dplyr.tidyverse.org/reference/group_trim.html %run nb_helpers.py  from datar.all import *  nb_header(group_trim) Try this notebook on binder. In\u00a0[3]: Copied! <pre>df = tibble(x=factor([\"a\", \"b\"], levels=list(\"abc\")))\ndf &gt;&gt; group_by(f.x, _drop=False) &gt;&gt; group_data()\n</pre> df = tibble(x=factor([\"a\", \"b\"], levels=list(\"abc\"))) df &gt;&gt; group_by(f.x, _drop=False) &gt;&gt; group_data() Out[3]: x _rows &lt;category&gt; &lt;object&gt; 0 a [0] 1 b [1] 2 c [] In\u00a0[4]: Copied! <pre>df &gt;&gt; group_by(f.x, _drop=False) &gt;&gt; group_trim() &gt;&gt; group_data()\n</pre> df &gt;&gt; group_by(f.x, _drop=False) &gt;&gt; group_trim() &gt;&gt; group_data() Out[4]: x _rows &lt;category&gt; &lt;object&gt; 0 a [0] 1 b [1]"},{"location":"notebooks/group_trim/#group_trim","title":"\u2605 group_trim\u00b6","text":""},{"location":"notebooks/group_trim/#remove-empty-groups","title":"Remove empty groups\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/group_trim.html</p>"},{"location":"notebooks/group_trim/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A grouped frame <code>_drop</code>: See <code>group_by</code>.</p>"},{"location":"notebooks/group_trim/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A grouped frame</p>"},{"location":"notebooks/lead-lag/","title":"lead-lag","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/lead-lag.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(lead, lag, book='lead-lag')\n</pre> # https://dplyr.tidyverse.org/reference/lead-lag.html %run nb_helpers.py  from datar.all import *  nb_header(lead, lag, book='lead-lag') Try this notebook on binder. In\u00a0[2]: Copied! <pre>x = [1,2,3,4,5]\n\nlag(x)\n</pre> x = [1,2,3,4,5]  lag(x) Out[2]: <pre>0    NaN\n1    1.0\n2    2.0\n3    3.0\n4    4.0\ndtype: float64</pre> In\u00a0[3]: Copied! <pre>lead(x)\n</pre> lead(x) Out[3]: <pre>0    2.0\n1    3.0\n2    4.0\n3    5.0\n4    NaN\ndtype: float64</pre> In\u00a0[4]: Copied! <pre>tibble(behind=lag(x), x=x, ahead=lead(x))\n</pre> tibble(behind=lag(x), x=x, ahead=lead(x)) Out[4]: behind x ahead &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; 0 NaN 1 2.0 1 1.0 2 3.0 2 2.0 3 4.0 3 3.0 4 5.0 4 4.0 5 NaN In\u00a0[5]: Copied! <pre>lag(x, n=1)\n</pre> lag(x, n=1) Out[5]: <pre>0    NaN\n1    1.0\n2    2.0\n3    3.0\n4    4.0\ndtype: float64</pre> In\u00a0[6]: Copied! <pre>lag(x, n=2)\n</pre> lag(x, n=2) Out[6]: <pre>0    NaN\n1    NaN\n2    1.0\n3    2.0\n4    3.0\ndtype: float64</pre> In\u00a0[7]: Copied! <pre>lead(x, n=1)\n</pre> lead(x, n=1) Out[7]: <pre>0    2.0\n1    3.0\n2    4.0\n3    5.0\n4    NaN\ndtype: float64</pre> In\u00a0[8]: Copied! <pre>lead(x, n=2)\n</pre> lead(x, n=2) Out[8]: <pre>0    3.0\n1    4.0\n2    5.0\n3    NaN\n4    NaN\ndtype: float64</pre> In\u00a0[9]: Copied! <pre>lag(x, default=0)\n</pre> lag(x, default=0) Out[9]: <pre>0    0\n1    1\n2    2\n3    3\n4    4\ndtype: int64</pre> In\u00a0[10]: Copied! <pre>lead(x, default=6)\n</pre> lead(x, default=6) Out[10]: <pre>0    2\n1    3\n2    4\n3    5\n4    6\ndtype: int64</pre> In\u00a0[11]: Copied! <pre>scrambled = slice_sample(\n    tibble(year=[2000, 2001, 2002, 2003, 2004, 2005], \n           value=[a**2 for a in range(6)]), \n    prop=1\n) \n\nscrambled &gt;&gt; mutate(previous_year_value = lag(f.value)) &gt;&gt; arrange(f.year)\n</pre> scrambled = slice_sample(     tibble(year=[2000, 2001, 2002, 2003, 2004, 2005],             value=[a**2 for a in range(6)]),      prop=1 )   scrambled &gt;&gt; mutate(previous_year_value = lag(f.value)) &gt;&gt; arrange(f.year) Out[11]: year value previous_year_value &lt;int64&gt; &lt;int64&gt; &lt;float64&gt; 0 2000 0 1.0 1 2001 1 9.0 2 2002 4 NaN 3 2003 9 4.0 4 2004 16 0.0 5 2005 25 16.0 In\u00a0[12]: Copied! <pre># Use this for lag(value, order_by = year) instead\nscrambled &gt;&gt; mutate(previous_year_value = lag(f.value, order_by=f.year)) &gt;&gt; arrange(f.year)\n</pre> # Use this for lag(value, order_by = year) instead scrambled &gt;&gt; mutate(previous_year_value = lag(f.value, order_by=f.year)) &gt;&gt; arrange(f.year)  Out[12]: year value previous_year_value &lt;int64&gt; &lt;int64&gt; &lt;float64&gt; 0 2000 0 0.0 1 2001 1 NaN 2 2002 4 4.0 3 2003 9 1.0 4 2004 16 9.0 5 2005 25 16.0 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/lead-lag/#lead","title":"\u2605 lead\u00b6","text":""},{"location":"notebooks/lead-lag/#shift-a-vector-by-n-positions","title":"Shift a vector by <code>n</code> positions.\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/lead.html</p>"},{"location":"notebooks/lead-lag/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A vector <code>n</code>: The number of positions to shift. <code>default</code>: The default value to use for positions that don't exist. <code>order_by</code>: A vector of column names to order by.</p>"},{"location":"notebooks/lead-lag/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A vector</p>"},{"location":"notebooks/lead-lag/#lag","title":"\u2605 lag\u00b6","text":""},{"location":"notebooks/lead-lag/#shift-a-vector-by-n-positions","title":"Shift a vector by <code>n</code> positions.\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/lag.html</p>"},{"location":"notebooks/lead-lag/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A vector <code>n</code>: The number of positions to shift. <code>default</code>: The default value to use for positions that don't exist. <code>order_by</code>: A vector of column names to order by.</p>"},{"location":"notebooks/lead-lag/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A vector</p>"},{"location":"notebooks/mutate-joins/","title":"mutate-joins","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/mutate-joins.html\n%run nb_helpers.py\n\nfrom datar.data import band_members, band_instruments, band_instruments2\nfrom datar.all import *\n\nnb_header(inner_join, left_join, right_join, full_join, book='mutate-joins')\n</pre> # https://dplyr.tidyverse.org/reference/mutate-joins.html %run nb_helpers.py  from datar.data import band_members, band_instruments, band_instruments2 from datar.all import *  nb_header(inner_join, left_join, right_join, full_join, book='mutate-joins') Try this notebook on binder. In\u00a0[2]: Copied! <pre>band_members &gt;&gt; inner_join(band_instruments)\n</pre> band_members &gt;&gt; inner_join(band_instruments) Out[2]: name band plays &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 John Beatles guitar 1 Paul Beatles bass In\u00a0[3]: Copied! <pre>band_members &gt;&gt; left_join(band_instruments)\n</pre> band_members &gt;&gt; left_join(band_instruments) Out[3]: name band plays &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Mick Stones NaN 1 John Beatles guitar 2 Paul Beatles bass In\u00a0[4]: Copied! <pre>band_members &gt;&gt; right_join(band_instruments)\n</pre> band_members &gt;&gt; right_join(band_instruments) Out[4]: name band plays &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 John Beatles guitar 1 Paul Beatles bass 2 Keith NaN guitar In\u00a0[5]: Copied! <pre>band_members &gt;&gt; full_join(band_instruments)\n</pre> band_members &gt;&gt; full_join(band_instruments) Out[5]: name band plays &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Mick Stones NaN 1 John Beatles guitar 2 Paul Beatles bass 3 Keith NaN guitar In\u00a0[6]: Copied! <pre>band_members &gt;&gt; inner_join(band_instruments, by=f.name)\n</pre> band_members &gt;&gt; inner_join(band_instruments, by=f.name) Out[6]: name band plays &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 John Beatles guitar 1 Paul Beatles bass In\u00a0[7]: Copied! <pre>band_members &gt;&gt; full_join(band_instruments2, by={'name': 'artist'})\n</pre> band_members &gt;&gt; full_join(band_instruments2, by={'name': 'artist'}) Out[7]: name band plays &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Mick Stones NaN 1 John Beatles guitar 2 Paul Beatles bass 3 NaN NaN guitar In\u00a0[8]: Copied! <pre>band_members &gt;&gt; full_join(band_instruments2, by={'name': 'artist'}, keep=True)\n</pre> band_members &gt;&gt; full_join(band_instruments2, by={'name': 'artist'}, keep=True) Out[8]: name band artist plays &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Mick Stones NaN NaN 1 John Beatles John guitar 2 Paul Beatles Paul bass 3 NaN NaN Keith guitar In\u00a0[9]: Copied! <pre>df1 = tibble(x=[1,2,3])\ndf2 = tibble(x=[1,1,2], y=[\"first\", \"second\", \"third\"])\ndf1 &gt;&gt; left_join(df2)\n</pre> df1 = tibble(x=[1,2,3]) df2 = tibble(x=[1,1,2], y=[\"first\", \"second\", \"third\"]) df1 &gt;&gt; left_join(df2) Out[9]: x y &lt;int64&gt; &lt;object&gt; 0 1 first 1 1 second 2 2 third 3 3 NaN In\u00a0[10]: Copied! <pre>df1 = tibble(x=[1, NA], y=2)\ndf2 = tibble(x=[1, NA], z=3)\nleft_join(df1, df2) # na_matches not supported yet\n</pre> df1 = tibble(x=[1, NA], y=2) df2 = tibble(x=[1, NA], z=3) left_join(df1, df2) # na_matches not supported yet Out[10]: x y z &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; 0 1.0 2 3 1 NaN 2 3"},{"location":"notebooks/mutate-joins/#inner_join","title":"\u2605 inner_join\u00b6","text":""},{"location":"notebooks/mutate-joins/#inner-join-two-data-frames-by-matching-rows","title":"Inner join two data frames by matching rows.\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/join.html</p>"},{"location":"notebooks/mutate-joins/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame <code>by</code>: A list of column names to join by. \u2003\u2003\u2003\u2003If None, use the intersection of the columns of x and y.</p> <p> <code>copy</code>: If True, always copy the data. <code>suffix</code>: A tuple of suffixes to apply to overlapping columns. <code>keep</code>: If True, keep the grouping variables in the output.</p>"},{"location":"notebooks/mutate-joins/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame</p>"},{"location":"notebooks/mutate-joins/#left_join","title":"\u2605 left_join\u00b6","text":""},{"location":"notebooks/mutate-joins/#left-join-two-data-frames-by-matching-rows","title":"Left join two data frames by matching rows.\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/join.html</p>"},{"location":"notebooks/mutate-joins/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame <code>by</code>: A list of column names to join by. \u2003\u2003\u2003\u2003If None, use the intersection of the columns of x and y.</p> <p> <code>copy</code>: If True, always copy the data. <code>suffix</code>: A tuple of suffixes to apply to overlapping columns. <code>keep</code>: If True, keep the grouping variables in the output.</p>"},{"location":"notebooks/mutate-joins/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame</p>"},{"location":"notebooks/mutate-joins/#right_join","title":"\u2605 right_join\u00b6","text":""},{"location":"notebooks/mutate-joins/#right-join-two-data-frames-by-matching-rows","title":"Right join two data frames by matching rows.\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/join.html</p>"},{"location":"notebooks/mutate-joins/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame <code>by</code>: A list of column names to join by. \u2003\u2003\u2003\u2003If None, use the intersection of the columns of x and y.</p> <p> <code>copy</code>: If True, always copy the data. <code>suffix</code>: A tuple of suffixes to apply to overlapping columns. <code>keep</code>: If True, keep the grouping variables in the output.</p>"},{"location":"notebooks/mutate-joins/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame</p>"},{"location":"notebooks/mutate-joins/#full_join","title":"\u2605 full_join\u00b6","text":""},{"location":"notebooks/mutate-joins/#full-join-two-data-frames-by-matching-rows","title":"Full join two data frames by matching rows.\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/join.html</p>"},{"location":"notebooks/mutate-joins/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame <code>by</code>: A list of column names to join by. \u2003\u2003\u2003\u2003If None, use the intersection of the columns of x and y.</p> <p> <code>copy</code>: If True, always copy the data. <code>suffix</code>: A tuple of suffixes to apply to overlapping columns. <code>keep</code>: If True, keep the grouping variables in the output.</p>"},{"location":"notebooks/mutate-joins/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame</p>"},{"location":"notebooks/mutate/","title":"mutate","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/mutate.html\n%run nb_helpers.py\n\nfrom datar.data import starwars\nfrom datar.all import *\n\nnb_header(mutate, transmute)\n</pre> # https://dplyr.tidyverse.org/reference/mutate.html %run nb_helpers.py  from datar.data import starwars from datar.all import *  nb_header(mutate, transmute) Try this notebook on binder. In\u00a0[2]: Copied! <pre>starwars &gt;&gt; \\\n select(f.name, f.mass) &gt;&gt; \\\n mutate(\n  mass2 = f.mass * 2,\n  mass2_squared = f.mass2 * f.mass2\n)\n</pre> starwars &gt;&gt; \\  select(f.name, f.mass) &gt;&gt; \\  mutate(   mass2 = f.mass * 2,   mass2_squared = f.mass2 * f.mass2 ) Out[2]: name mass mass2 mass2_squared &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 Luke Skywalker 77.0 154.0 23716.0 1 C-3PO 75.0 150.0 22500.0 2 R2-D2 32.0 64.0 4096.0 3 Darth Vader 136.0 272.0 73984.0 ... ... ... ... ... 4 Leia Organa 49.0 98.0 9604.0 82 Rey NaN NaN NaN 83 Poe Dameron NaN NaN NaN 84 BB8 NaN NaN NaN 85 Captain Phasma NaN NaN NaN 86 Padm\u00e9 Amidala 45.0 90.0 8100.0 <p>87 rows \u00d7 4 columns</p> In\u00a0[3]: Copied! <pre>starwars &gt;&gt; \\\n select(f.name, f.height, f.mass, f.homeworld) &gt;&gt; \\\n mutate(\n  mass = NULL,\n  height = f.height * 0.0328084 # convert to feet\n)\n</pre> starwars &gt;&gt; \\  select(f.name, f.height, f.mass, f.homeworld) &gt;&gt; \\  mutate(   mass = NULL,   height = f.height * 0.0328084 # convert to feet ) Out[3]: name height homeworld &lt;object&gt; &lt;float64&gt; &lt;object&gt; 0 Luke Skywalker 5.643045 Tatooine 1 C-3PO 5.479003 Tatooine 2 R2-D2 3.149606 Naboo 3 Darth Vader 6.627297 Tatooine ... ... ... ... 4 Leia Organa 4.921260 Alderaan 82 Rey NaN NaN 83 Poe Dameron NaN NaN 84 BB8 NaN NaN 85 Captain Phasma NaN NaN 86 Padm\u00e9 Amidala 5.413386 Naboo <p>87 rows \u00d7 3 columns</p> In\u00a0[5]: Copied! <pre>x = starwars &gt;&gt; \\\n select(f.name, f.homeworld, f.species) &gt;&gt; \\\n mutate(across(~f.name, as_factor))\n\nx.dtypes\nx\n</pre> x = starwars &gt;&gt; \\  select(f.name, f.homeworld, f.species) &gt;&gt; \\  mutate(across(~f.name, as_factor))  x.dtypes x Out[5]: <pre>name           object\nhomeworld    category\nspecies      category\ndtype: object</pre> Out[5]: name homeworld species &lt;object&gt; &lt;category&gt; &lt;category&gt; 0 Luke Skywalker Tatooine Human 1 C-3PO Tatooine Droid 2 R2-D2 Naboo Droid 3 Darth Vader Tatooine Human ... ... ... ... 4 Leia Organa Alderaan Human 82 Rey NaN Human 83 Poe Dameron NaN Human 84 BB8 NaN Droid 85 Captain Phasma NaN NaN 86 Padm\u00e9 Amidala Naboo Human <p>87 rows \u00d7 3 columns</p> In\u00a0[6]: Copied! <pre>starwars &gt;&gt; \\\n select(f.name, f.mass, f.homeworld) &gt;&gt; \\\n group_by(f.homeworld) &gt;&gt; \\\n mutate(rank=min_rank(desc(f.mass))) \n</pre> starwars &gt;&gt; \\  select(f.name, f.mass, f.homeworld) &gt;&gt; \\  group_by(f.homeworld) &gt;&gt; \\  mutate(rank=min_rank(desc(f.mass)))  Out[6]: name mass homeworld rank &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;float64&gt; 0 Luke Skywalker 77.0 Tatooine 5.0 1 C-3PO 75.0 Tatooine 6.0 2 R2-D2 32.0 Naboo 6.0 3 Darth Vader 136.0 Tatooine 1.0 ... ... ... ... ... 4 Leia Organa 49.0 Alderaan 2.0 82 Rey NaN NaN NaN 83 Poe Dameron NaN NaN NaN 84 BB8 NaN NaN NaN 85 Captain Phasma NaN NaN NaN 86 Padm\u00e9 Amidala 45.0 Naboo 5.0 <p>87 rows \u00d7 4 columns</p> <p>TibbleGrouped: homeworld (n=49) </p> In\u00a0[7]: Copied! <pre>df = tibble(x=1, y=2)\n\ndf &gt;&gt; mutate(z=f.x+f.y)\n</pre> df = tibble(x=1, y=2)  df &gt;&gt; mutate(z=f.x+f.y) Out[7]: x y z &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 1 2 3 In\u00a0[8]: Copied! <pre>df &gt;&gt; mutate(z=f.x+f.y, _before=1) \n</pre> df &gt;&gt; mutate(z=f.x+f.y, _before=1)  Out[8]: x z y &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 1 3 2 In\u00a0[9]: Copied! <pre>df &gt;&gt; mutate(z=f.x+f.y, _after=f.x)\n</pre> df &gt;&gt; mutate(z=f.x+f.y, _after=f.x) Out[9]: x z y &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 1 3 2 In\u00a0[10]: Copied! <pre># use a temporary column\ndf &gt;&gt; mutate(_z=f.x+f.y, z=f._z*2, _after=f.x)\n</pre> # use a temporary column df &gt;&gt; mutate(_z=f.x+f.y, z=f._z*2, _after=f.x) Out[10]: x z y &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 1 6 2 In\u00a0[11]: Copied! <pre>df = tibble(x=1, y=2, a=\"a\", b=\"b\")\ndf &gt;&gt; mutate(z=f.x+f.y, _keep='all')\n</pre> df = tibble(x=1, y=2, a=\"a\", b=\"b\") df &gt;&gt; mutate(z=f.x+f.y, _keep='all') Out[11]: x y a b z &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;object&gt; &lt;int64&gt; 0 1 2 a b 3 In\u00a0[12]: Copied! <pre>df &gt;&gt; mutate(z=f.x+f.y, _keep='used')\n</pre> df &gt;&gt; mutate(z=f.x+f.y, _keep='used') Out[12]: x y z &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 1 2 3 In\u00a0[13]: Copied! <pre>df &gt;&gt; mutate(z=f.x+f.y, _keep='unused')\n</pre> df &gt;&gt; mutate(z=f.x+f.y, _keep='unused') Out[13]: a b z &lt;object&gt; &lt;object&gt; &lt;int64&gt; 0 a b 3 In\u00a0[14]: Copied! <pre>df &gt;&gt; mutate(z=f.x+f.y, _keep='none')\n</pre> df &gt;&gt; mutate(z=f.x+f.y, _keep='none') Out[14]: z &lt;int64&gt; 0 3 In\u00a0[16]: Copied! <pre>starwars &gt;&gt; \\\n  select(f.name, f.mass, f.species) &gt;&gt; \\\n  mutate(mass_norm=f.mass/mean(f.mass)) \n</pre> starwars &gt;&gt; \\   select(f.name, f.mass, f.species) &gt;&gt; \\   mutate(mass_norm=f.mass/mean(f.mass))  Out[16]: name mass species mass_norm &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;float64&gt; 0 Luke Skywalker 77.0 Human 0.791270 1 C-3PO 75.0 Droid 0.770718 2 R2-D2 32.0 Droid 0.328840 3 Darth Vader 136.0 Human 1.397569 ... ... ... ... ... 4 Leia Organa 49.0 Human 0.503536 82 Rey NaN Human NaN 83 Poe Dameron NaN Human NaN 84 BB8 NaN Droid NaN 85 Captain Phasma NaN NaN NaN 86 Padm\u00e9 Amidala 45.0 Human 0.462431 <p>87 rows \u00d7 4 columns</p> In\u00a0[18]: Copied! <pre>starwars &gt;&gt; \\\n  select(f.name, f.mass, f.species) &gt;&gt; \\\n  group_by(f.species) &gt;&gt; \\\n  mutate(mass_norm=f.mass / mean(f.mass)) &gt;&gt; \\\n  ungroup() \n</pre> starwars &gt;&gt; \\   select(f.name, f.mass, f.species) &gt;&gt; \\   group_by(f.species) &gt;&gt; \\   mutate(mass_norm=f.mass / mean(f.mass)) &gt;&gt; \\   ungroup()  Out[18]: name mass species mass_norm &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;float64&gt; 0 Luke Skywalker 77.0 Human 0.930156 1 C-3PO 75.0 Droid 1.075269 2 R2-D2 32.0 Droid 0.458781 3 Darth Vader 136.0 Human 1.642873 ... ... ... ... ... 4 Leia Organa 49.0 Human 0.591917 82 Rey NaN Human NaN 83 Poe Dameron NaN Human NaN 84 BB8 NaN Droid NaN 85 Captain Phasma NaN NaN NaN 86 Padm\u00e9 Amidala 45.0 Human 0.543598 <p>87 rows \u00d7 4 columns</p> In\u00a0[19]: Copied! <pre>vars = [\"mass\", \"height\"]\nstarwars &gt;&gt; mutate(starwars, prod=f[vars[0]] * f[vars[1]])\n</pre> vars = [\"mass\", \"height\"] starwars &gt;&gt; mutate(starwars, prod=f[vars[0]] * f[vars[1]]) Out[19]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species prod &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; 0 Luke Skywalker 172.0 77.0 blond fair blue 19.0 male masculine Tatooine Human 13244.0 1 C-3PO 167.0 75.0 NaN gold yellow 112.0 none masculine Tatooine Droid 12525.0 2 R2-D2 96.0 32.0 NaN white, blue red 33.0 none masculine Naboo Droid 3072.0 3 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human 27472.0 ... ... ... ... ... ... ... ... ... ... ... ... ... 4 Leia Organa 150.0 49.0 brown light brown 19.0 female feminine Alderaan Human 7350.0 82 Rey NaN NaN brown light hazel NaN female feminine NaN Human NaN 83 Poe Dameron NaN NaN brown light brown NaN male masculine NaN Human NaN 84 BB8 NaN NaN none none black NaN none masculine NaN Droid NaN 85 Captain Phasma NaN NaN unknown unknown unknown NaN NaN NaN NaN NaN NaN 86 Padm\u00e9 Amidala 165.0 45.0 brown light brown 46.0 female feminine Naboo Human 7425.0 <p>87 rows \u00d7 12 columns</p>"},{"location":"notebooks/mutate/#mutate","title":"\u2605 mutate\u00b6","text":""},{"location":"notebooks/mutate/#add-new-columns-to-a-data-frame","title":"Add new columns to a data frame.\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/mutate.html</p>"},{"location":"notebooks/mutate/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>_keep</code>: allows you to control which columns from _data are retained \u2003\u2003\u2003\u2003in the output:</p> <p>\u2003\u2003\u2003\u2003- \"all\", the default, retains all variables.</p> <p>\u2003\u2003\u2003\u2003- \"used\" keeps any variables used to make new variables; \u2003\u2003\u2003\u2003\u2003\u2003it's useful for checking your work as it displays inputs and \u2003\u2003\u2003\u2003\u2003\u2003outputs side-by-side.</p> <p>\u2003\u2003\u2003\u2003- \"unused\" keeps only existing variables not used to make new \u2003\u2003\u2003\u2003\u2003\u2003variables.</p> <p>\u2003\u2003\u2003\u2003- \"none\", only keeps grouping keys (like transmute()).</p> <p> <code>_before</code>: A list of column names to put the new columns before. <code>_after</code>: A list of column names to put the new columns after. <code>*args</code>: and <code>**kwargs</code>: Name-value pairs. The name gives the name of the column \u2003\u2003\u2003\u2003in the output. The value can be:</p> <p>\u2003\u2003\u2003\u2003- A vector of length 1, which will be recycled to the correct \u2003\u2003\u2003\u2003\u2003\u2003length.</p> <p>\u2003\u2003\u2003\u2003- A vector the same length as the current group (or the whole \u2003\u2003\u2003\u2003\u2003\u2003data frame if ungrouped).</p> <p>\u2003\u2003\u2003\u2003- None to remove the column</p>"},{"location":"notebooks/mutate/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003An object of the same type as _data. The output has the following \u2003\u2003properties: \u2003\u2003- Rows are not affected. \u2003\u2003- Existing columns will be preserved according to the _keep \u2003\u2003\u2003\u2003argument. New columns will be placed according to the \u2003\u2003\u2003\u2003_before and _after arguments. If _keep = \"none\" \u2003\u2003\u2003\u2003(as in transmute()), the output order is determined only \u2003\u2003\u2003\u2003by ..., not the order of existing columns.</p> <p>\u2003\u2003- Columns given value None will be removed \u2003\u2003- Groups will be recomputed if a grouping variable is mutated. \u2003\u2003- Data frame attributes are preserved.</p>"},{"location":"notebooks/mutate/#transmute","title":"\u2605 transmute\u00b6","text":""},{"location":"notebooks/mutate/#add-new-columns-to-a-data-frame-and-remove-existing-columns","title":"Add new columns to a data frame and remove existing columns\u00b6","text":"<p>using mutate with <code>_keep=\"none\"</code>.</p> <p>The original API: https://dplyr.tidyverse.org/reference/mutate.html</p>"},{"location":"notebooks/mutate/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>_before</code>: A list of column names to put the new columns before. <code>_after</code>: A list of column names to put the new columns after. <code>*args</code>: and <code>**kwargs</code>: Name-value pairs. The name gives the name of the column \u2003\u2003\u2003\u2003in the output. The value can be:</p> <p>\u2003\u2003\u2003\u2003- A vector of length 1, which will be recycled to the correct \u2003\u2003\u2003\u2003\u2003\u2003length.</p> <p>\u2003\u2003\u2003\u2003- A vector the same length as the current group (or the whole \u2003\u2003\u2003\u2003\u2003\u2003data frame if ungrouped).</p> <p>\u2003\u2003\u2003\u2003- None to remove the column</p>"},{"location":"notebooks/mutate/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003An object of the same type as _data. The output has the following \u2003\u2003properties: \u2003\u2003- Rows are not affected. \u2003\u2003- Existing columns will be preserved according to the _keep \u2003\u2003\u2003\u2003argument. New columns will be placed according to the \u2003\u2003\u2003\u2003_before and _after arguments. If _keep = \"none\" \u2003\u2003\u2003\u2003(as in transmute()), the output order is determined only \u2003\u2003\u2003\u2003by ..., not the order of existing columns.</p> <p>\u2003\u2003- Columns given value None will be removed \u2003\u2003- Groups will be recomputed if a grouping variable is mutated. \u2003\u2003- Data frame attributes are preserved.</p>"},{"location":"notebooks/n_distinct/","title":"n_distinct","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/n_distinct.html\n%run nb_helpers.py\n\nfrom datar.all import sample, n_distinct\n\nnb_header(sample, n_distinct, book='n_distinct')\n</pre> # https://dplyr.tidyverse.org/reference/n_distinct.html %run nb_helpers.py  from datar.all import sample, n_distinct  nb_header(sample, n_distinct, book='n_distinct') Try this notebook on binder. In\u00a0[2]: Copied! <pre>x = sample(range(10), 1e5, replace=True)\nlen(x)\n</pre> x = sample(range(10), 1e5, replace=True) len(x) Out[2]: <pre>100000</pre> In\u00a0[3]: Copied! <pre>n_distinct(x)\n</pre> n_distinct(x) Out[3]: <pre>10</pre>"},{"location":"notebooks/n_distinct/#sample","title":"\u2605 sample\u00b6","text":""},{"location":"notebooks/n_distinct/#sample-a-vector","title":"Sample a vector\u00b6","text":""},{"location":"notebooks/n_distinct/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: a vector or scaler <code>size</code>: the size of the sample <code>replace</code>: whether to sample with replacement <code>prob</code>: the probabilities of sampling each element</p>"},{"location":"notebooks/n_distinct/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The sampled vector</p>"},{"location":"notebooks/n_distinct/#n_distinct","title":"\u2605 n_distinct\u00b6","text":""},{"location":"notebooks/n_distinct/#count-the-number-of-distinct-values","title":"Count the number of distinct values\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/distinct.html</p>"},{"location":"notebooks/n_distinct/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>na_rm</code>: If <code>True</code>, remove missing values before counting.</p>"},{"location":"notebooks/n_distinct/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The number of distinct values</p>"},{"location":"notebooks/na_if/","title":"na_if","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/na_if.html\n%run nb_helpers.py\n\nfrom datar.data import starwars\nfrom datar.all import *\n\nnb_header(na_if)\n</pre> # https://dplyr.tidyverse.org/reference/na_if.html %run nb_helpers.py  from datar.data import starwars from datar.all import *  nb_header(na_if) Try this notebook on binder. In\u00a0[2]: Copied! <pre>na_if(range(5), list(range(4,-1,-1)))\n</pre> na_if(range(5), list(range(4,-1,-1))) Out[2]: <pre>0    0.0\n1    1.0\n2    NaN\n3    3.0\n4    4.0\nName: x, dtype: float64</pre> In\u00a0[2]: Copied! <pre>x = tibble(x=[1, -1, 0, 10]).x\n100 / x\n</pre> x = tibble(x=[1, -1, 0, 10]).x 100 / x Out[2]: <pre>0    100.0\n1   -100.0\n2      inf\n3     10.0\nName: x, dtype: float64</pre> In\u00a0[3]: Copied! <pre>na_if(x, 0)\n</pre> na_if(x, 0) Out[3]: <pre>0     1.0\n1    -1.0\n2     NaN\n3    10.0\nName: x, dtype: float64</pre> In\u00a0[4]: Copied! <pre>y = tibble(y=[\"abc\", \"def\", \"\", \"ghi\"]).y\nna_if(y, \"\")\n</pre> y = tibble(y=[\"abc\", \"def\", \"\", \"ghi\"]).y na_if(y, \"\") Out[4]: <pre>0    abc\n1    def\n2    NaN\n3    ghi\nName: x, dtype: object</pre> In\u00a0[5]: Copied! <pre>starwars &gt;&gt; \\\n  select(f.name, f.eye_color) &gt;&gt; \\\n  mutate(eye_color = na_if(f.eye_color, \"unknown\"))\n</pre> starwars &gt;&gt; \\   select(f.name, f.eye_color) &gt;&gt; \\   mutate(eye_color = na_if(f.eye_color, \"unknown\")) Out[5]: name eye_color &lt;object&gt; &lt;object&gt; 0 Luke Skywalker blue 1 C-3PO yellow 2 R2-D2 red 3 Darth Vader yellow ... ... ... 4 Leia Organa brown 82 Rey hazel 83 Poe Dameron brown 84 BB8 black 85 Captain Phasma NaN 86 Padm\u00e9 Amidala brown <p>87 rows \u00d7 2 columns</p> In\u00a0[6]: Copied! <pre>starwars &gt;&gt; \\\n   mutate(across(where(is_character), lambda x: na_if(x, \"unknown\")))\n</pre> starwars &gt;&gt; \\    mutate(across(where(is_character), lambda x: na_if(x, \"unknown\"))) Out[6]: name height mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Luke Skywalker 172.0 77.0 blond fair blue 19.0 male masculine Tatooine Human 1 C-3PO 167.0 75.0 NaN gold yellow 112.0 none masculine Tatooine Droid 2 R2-D2 96.0 32.0 NaN white, blue red 33.0 none masculine Naboo Droid 3 Darth Vader 202.0 136.0 none white yellow 41.9 male masculine Tatooine Human ... ... ... ... ... ... ... ... ... ... ... ... 4 Leia Organa 150.0 49.0 brown light brown 19.0 female feminine Alderaan Human 82 Rey NaN NaN brown light hazel NaN female feminine NaN Human 83 Poe Dameron NaN NaN brown light brown NaN male masculine NaN Human 84 BB8 NaN NaN none none black NaN none masculine NaN Droid 85 Captain Phasma NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 86 Padm\u00e9 Amidala 165.0 45.0 brown light brown 46.0 female feminine Naboo Human <p>87 rows \u00d7 11 columns</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/na_if/#na_if","title":"\u2605 na_if\u00b6","text":""},{"location":"notebooks/na_if/#replace-values-with-missing-values","title":"Replace values with missing values\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/na_if.html</p>"},{"location":"notebooks/na_if/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A vector <code>value</code>: Values to replace with missing values.</p>"},{"location":"notebooks/na_if/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003An array of values</p>"},{"location":"notebooks/nb_helpers/","title":"Nb helpers","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"helpers for notebooks\"\"\"\nfrom contextlib import contextmanager\n</pre> \"\"\"helpers for notebooks\"\"\" from contextlib import contextmanager In\u00a0[\u00a0]: Copied! <pre>from IPython.display import display, Markdown, HTML\nfrom IPython.core.interactiveshell import InteractiveShell\nimport pardoc\nfrom varname.helpers import debug  # noqa\nfrom datar import options\n</pre> from IPython.display import display, Markdown, HTML from IPython.core.interactiveshell import InteractiveShell import pardoc from varname.helpers import debug  # noqa from datar import options In\u00a0[\u00a0]: Copied! <pre>options(allow_conflict_names=True)\n</pre> options(allow_conflict_names=True) In\u00a0[\u00a0]: Copied! <pre>InteractiveShell.ast_node_interactivity = \"all\"\n</pre> InteractiveShell.ast_node_interactivity = \"all\" In\u00a0[\u00a0]: Copied! <pre>BINDER_URL = (\n    \"https://mybinder.org/v2/gh/pwwang/datar/\"\n    \"dev?filepath=docs%2Fnotebooks%2F\"\n)\n</pre> BINDER_URL = (     \"https://mybinder.org/v2/gh/pwwang/datar/\"     \"dev?filepath=docs%2Fnotebooks%2F\" ) In\u00a0[\u00a0]: Copied! <pre>def nb_header(*funcs, book=None):\n    \"\"\"Print the header of a notebooks, mostly the docs\"\"\"\n    if book is None:\n        book = funcs[0].__name__\n    display(\n        HTML(\n            '&lt;div style=\"text-align: right; text-style: italic\"&gt;'\n            'Try this notebook on '\n            f'&lt;a target=\"_blank\" href=\"{BINDER_URL}{book}.ipynb\"&gt;'\n            \"binder&lt;/a&gt;.&lt;/div&gt;\"\n        )\n    )\n\n    for func in funcs:\n        try:\n            parsed = pardoc.google_parser.parse(func.__doc__)\n            try:\n                del parsed[\"Examples\"]\n            except KeyError:\n                pass\n        except Exception:\n            formatted = func.__doc__\n        else:\n            formatted = pardoc.google_parser.format(\n                parsed,\n                to=\"markdown\",\n                heading=5,\n                indent_base=\"&amp;emsp;&amp;emsp;\",\n            )\n\n        display(Markdown(\n            f'{\"#\"*3} '\n            '&lt;div style=\"background-color: #EEE; padding: 5px 0 8px 0\"&gt;'\n            f'\u2605 {func.__name__}'\n            '&lt;/div&gt;')\n        )\n        display(Markdown(formatted))\n</pre> def nb_header(*funcs, book=None):     \"\"\"Print the header of a notebooks, mostly the docs\"\"\"     if book is None:         book = funcs[0].__name__     display(         HTML(             ''             'Try this notebook on '             f''             \"binder.\"         )     )      for func in funcs:         try:             parsed = pardoc.google_parser.parse(func.__doc__)             try:                 del parsed[\"Examples\"]             except KeyError:                 pass         except Exception:             formatted = func.__doc__         else:             formatted = pardoc.google_parser.format(                 parsed,                 to=\"markdown\",                 heading=5,                 indent_base=\"\u2003\u2003\",             )          display(Markdown(             f'{\"#\"*3} '             ''             f'\u2605 {func.__name__}'             '')         )         display(Markdown(formatted)) In\u00a0[\u00a0]: Copied! <pre>@contextmanager\ndef try_catch():\n    \"\"\"Catch the error and print it out\"\"\"\n    try:\n        yield\n    except Exception as exc:\n        print(f\"[{type(exc).__name__}] {exc}\")\n</pre> @contextmanager def try_catch():     \"\"\"Catch the error and print it out\"\"\"     try:         yield     except Exception as exc:         print(f\"[{type(exc).__name__}] {exc}\")"},{"location":"notebooks/near/","title":"near","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/near.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(near)\n</pre> # https://dplyr.tidyverse.org/reference/near.html %run nb_helpers.py  from datar.all import *  nb_header(near) Try this notebook on binder. In\u00a0[2]: Copied! <pre>sqrt(2.0) ** 2.0 == 2.0\n</pre> sqrt(2.0) ** 2.0 == 2.0 Out[2]: <pre>False</pre> In\u00a0[3]: Copied! <pre>near(sqrt(2.0) ** 2.0, 2.0)\n</pre> near(sqrt(2.0) ** 2.0, 2.0) Out[3]: <pre>True</pre>"},{"location":"notebooks/near/#near","title":"\u2605 near\u00b6","text":""},{"location":"notebooks/near/#check-if-values-are-approximately-equal","title":"Check if values are approximately equal\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/near.html</p>"},{"location":"notebooks/near/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A numeric vector <code>y</code>: A numeric vector <code>tol</code>: Tolerance</p>"},{"location":"notebooks/near/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003An array of boolean values</p>"},{"location":"notebooks/nest-join/","title":"nest-join","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/nest_join.html\n%run nb_helpers.py\n\nfrom datar.data import band_members, band_instruments\nfrom datar.all import *\n\nnb_header(nest_join, book='nest-join')\n</pre> # https://dplyr.tidyverse.org/reference/nest_join.html %run nb_helpers.py  from datar.data import band_members, band_instruments from datar.all import *  nb_header(nest_join, book='nest-join') Try this notebook on binder. In\u00a0[2]: Copied! <pre>nested = band_members &gt;&gt; nest_join(band_instruments)\nnested\n</pre> nested = band_members &gt;&gt; nest_join(band_instruments) nested Out[2]: name band _y_joined &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 Mick Stones &lt;DF 0x1&gt; 1 John Beatles &lt;DF 1x1&gt; 2 Paul Beatles &lt;DF 1x1&gt; In\u00a0[3]: Copied! <pre>nested &gt;&gt; head(2) &gt;&gt; pull(f._y_joined, to='list')\n</pre> nested &gt;&gt; head(2) &gt;&gt; pull(f._y_joined, to='list') Out[3]: <pre>[Empty Tibble\n Columns: [plays]\n Index: [],\n      plays\n   &lt;object&gt;\n 0   guitar]</pre>"},{"location":"notebooks/nest-join/#nest_join","title":"\u2605 nest_join\u00b6","text":""},{"location":"notebooks/nest-join/#nest-join-two-data-frames-by-matching-rows","title":"Nest join two data frames by matching rows.\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/join.html</p>"},{"location":"notebooks/nest-join/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame <code>by</code>: A list of column names to join by. \u2003\u2003\u2003\u2003If None, use the intersection of the columns of x and y.</p> <p> <code>copy</code>: If True, always copy the data. <code>keep</code>: If True, keep the grouping variables in the output. <code>name</code>: The name of the column to store the nested data frame.</p>"},{"location":"notebooks/nest-join/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame</p>"},{"location":"notebooks/nest/","title":"nest","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\nfrom datar.data import iris, fish_encounters, mtcars\nfrom datar.all import *\n\nnb_header(nest, unnest)\n</pre> %run nb_helpers.py from datar.data import iris, fish_encounters, mtcars from datar.all import *  nb_header(nest, unnest) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x = c(1, 1, 1, 2, 2, 3), y = c[1:7], z = c[7:1])\ndf &gt;&gt; nest(data=c(f.y, f.z))\n</pre> df = tibble(x = c(1, 1, 1, 2, 2, 3), y = c[1:7], z = c[7:1]) df &gt;&gt; nest(data=c(f.y, f.z)) Out[2]: x data &lt;int64&gt; &lt;object&gt; 0 1 &lt;DF 3x2&gt; 1 2 &lt;DF 2x2&gt; 2 3 &lt;DF 1x2&gt; In\u00a0[3]: Copied! <pre>df &gt;&gt; chop(c(f.y, f.z))\n</pre> df &gt;&gt; chop(c(f.y, f.z)) Out[3]: x y z &lt;int64&gt; &lt;object&gt; &lt;object&gt; 0 1 [1, 2, 3] [7, 6, 5] 1 2 [4, 5] [4, 3] 2 3 [6] [2] In\u00a0[4]: Copied! <pre>df &gt;&gt; nest(data=any_of(c(f.y, f.z)))\n</pre> df &gt;&gt; nest(data=any_of(c(f.y, f.z))) Out[4]: x data &lt;int64&gt; &lt;object&gt; 0 1 &lt;DF 3x2&gt; 1 2 &lt;DF 2x2&gt; 2 3 &lt;DF 1x2&gt; In\u00a0[5]: Copied! <pre>out = iris &gt;&gt; nest(data=~f.Species)\nout.data[0]\n</pre> out = iris &gt;&gt; nest(data=~f.Species) out.data[0] Out[5]: Sepal_Length Sepal_Width Petal_Length Petal_Width &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 5.1 3.5 1.4 0.2 1 4.9 3.0 1.4 0.2 2 4.7 3.2 1.3 0.2 3 4.6 3.1 1.5 0.2 4 5.0 3.6 1.4 0.2 5 5.4 3.9 1.7 0.4 6 4.6 3.4 1.4 0.3 7 5.0 3.4 1.5 0.2 8 4.4 2.9 1.4 0.2 9 4.9 3.1 1.5 0.1 10 5.4 3.7 1.5 0.2 11 4.8 3.4 1.6 0.2 12 4.8 3.0 1.4 0.1 13 4.3 3.0 1.1 0.1 14 5.8 4.0 1.2 0.2 15 5.7 4.4 1.5 0.4 16 5.4 3.9 1.3 0.4 17 5.1 3.5 1.4 0.3 18 5.7 3.8 1.7 0.3 19 5.1 3.8 1.5 0.3 20 5.4 3.4 1.7 0.2 21 5.1 3.7 1.5 0.4 22 4.6 3.6 1.0 0.2 23 5.1 3.3 1.7 0.5 24 4.8 3.4 1.9 0.2 25 5.0 3.0 1.6 0.2 26 5.0 3.4 1.6 0.4 27 5.2 3.5 1.5 0.2 28 5.2 3.4 1.4 0.2 29 4.7 3.2 1.6 0.2 30 4.8 3.1 1.6 0.2 31 5.4 3.4 1.5 0.4 32 5.2 4.1 1.5 0.1 33 5.5 4.2 1.4 0.2 34 4.9 3.1 1.5 0.2 35 5.0 3.2 1.2 0.2 36 5.5 3.5 1.3 0.2 37 4.9 3.6 1.4 0.1 38 4.4 3.0 1.3 0.2 39 5.1 3.4 1.5 0.2 40 5.0 3.5 1.3 0.3 41 4.5 2.3 1.3 0.3 42 4.4 3.2 1.3 0.2 43 5.0 3.5 1.6 0.6 44 5.1 3.8 1.9 0.4 45 4.8 3.0 1.4 0.3 46 5.1 3.8 1.6 0.2 47 4.6 3.2 1.4 0.2 48 5.3 3.7 1.5 0.2 49 5.0 3.3 1.4 0.2 In\u00a0[6]: Copied! <pre>nest_vars = colnames(iris)[:4]\niris &gt;&gt; nest(data = any_of(nest_vars))\n</pre> nest_vars = colnames(iris)[:4] iris &gt;&gt; nest(data = any_of(nest_vars)) Out[6]: Species data &lt;object&gt; &lt;object&gt; 0 setosa &lt;DF 50x4&gt; 1 versicolor &lt;DF 50x4&gt; 2 virginica &lt;DF 50x4&gt; In\u00a0[7]: Copied! <pre>iris &gt;&gt; nest(petal = starts_with(\"Petal\"), sepal = starts_with(\"Sepal\"))\n</pre> iris &gt;&gt; nest(petal = starts_with(\"Petal\"), sepal = starts_with(\"Sepal\")) Out[7]: Species petal sepal &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 setosa &lt;DF 50x2&gt; &lt;DF 50x2&gt; 1 versicolor &lt;DF 50x2&gt; &lt;DF 50x2&gt; 2 virginica &lt;DF 50x2&gt; &lt;DF 50x2&gt; In\u00a0[8]: Copied! <pre>iris &gt;&gt; nest(width = contains(\"Width\"), length = contains(\"Length\"))\n</pre> iris &gt;&gt; nest(width = contains(\"Width\"), length = contains(\"Length\")) Out[8]: Species width length &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 setosa &lt;DF 50x2&gt; &lt;DF 50x2&gt; 1 versicolor &lt;DF 50x2&gt; &lt;DF 50x2&gt; 2 virginica &lt;DF 50x2&gt; &lt;DF 50x2&gt; In\u00a0[9]: Copied! <pre>fish_encounters &gt;&gt; group_by(f.fish) &gt;&gt; nest()\n</pre> fish_encounters &gt;&gt; group_by(f.fish) &gt;&gt; nest() Out[9]: fish data &lt;int64&gt; &lt;object&gt; 0 4842 &lt;DF 11x2&gt; 1 4843 &lt;DF 11x2&gt; 2 4844 &lt;DF 11x2&gt; 3 4845 &lt;DF 5x2&gt; 4 4847 &lt;DF 3x2&gt; 5 4848 &lt;DF 4x2&gt; 6 4849 &lt;DF 2x2&gt; 7 4850 &lt;DF 6x2&gt; 8 4851 &lt;DF 2x2&gt; 9 4854 &lt;DF 2x2&gt; 10 4855 &lt;DF 5x2&gt; 11 4857 &lt;DF 9x2&gt; 12 4858 &lt;DF 11x2&gt; 13 4859 &lt;DF 5x2&gt; 14 4861 &lt;DF 11x2&gt; 15 4862 &lt;DF 9x2&gt; 16 4863 &lt;DF 2x2&gt; 17 4864 &lt;DF 2x2&gt; 18 4865 &lt;DF 3x2&gt; <p>TibbleGrouped: fish (n=19) </p> In\u00a0[11]: Copied! <pre>from pipda import register_func\n@register_func()\ndef get_models(dfs):\n    # do whatever with the dfs\n    \n    return dfs.transform(lambda df: f\"&lt;df {df.values[0].shape[0]}x{df.values[0].shape[1]}&gt;\")\n\nmtcars &gt;&gt; group_by(f.cyl) &gt;&gt; nest() &gt;&gt; mutate(\n    models=get_models(f.data)\n)\n</pre> from pipda import register_func @register_func() def get_models(dfs):     # do whatever with the dfs          return dfs.transform(lambda df: f\"\")  mtcars &gt;&gt; group_by(f.cyl) &gt;&gt; nest() &gt;&gt; mutate(     models=get_models(f.data) ) Out[11]: cyl data models &lt;int64&gt; &lt;object&gt; &lt;object&gt; 0 6 &lt;DF 7x10&gt; &lt;df 7x10&gt; 1 4 &lt;DF 11x10&gt; &lt;df 11x10&gt; 2 8 &lt;DF 14x10&gt; &lt;df 14x10&gt; <p>TibbleGrouped: cyl (n=3) </p> In\u00a0[12]: Copied! <pre>df = tibble(\n  x = c[1:4],\n  y = [\n    NULL,\n    tibble(a = 1, b = 2),\n    tibble(a = c[1:4], b = c[4:1])\n  ]\n)\ndf &gt;&gt; unnest(f.y, dtypes=int)\n</pre> df = tibble(   x = c[1:4],   y = [     NULL,     tibble(a = 1, b = 2),     tibble(a = c[1:4], b = c[4:1])   ] ) df &gt;&gt; unnest(f.y, dtypes=int) Out[12]: x a b &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 2 1 2 1 3 1 4 2 3 2 3 3 3 3 2 In\u00a0[13]: Copied! <pre>df &gt;&gt; unnest(f.y, keep_empty=True)\n</pre> df &gt;&gt; unnest(f.y, keep_empty=True) Out[13]: x a b &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; 0 1 NaN NaN 1 2 1.0 2.0 2 3 1.0 4.0 3 3 2.0 3.0 4 3 3.0 2.0 In\u00a0[14]: Copied! <pre>df = tibble(\n a = [c(\"a\", \"b\"), \"c\"],\n b = [[1,2], 3],\n c = c(11, 22)\n)\ndf &gt;&gt; unnest(c(f.a, f.b))\n</pre> df = tibble(  a = [c(\"a\", \"b\"), \"c\"],  b = [[1,2], 3],  c = c(11, 22) ) df &gt;&gt; unnest(c(f.a, f.b)) Out[14]: a b c &lt;object&gt; &lt;int64&gt; &lt;int64&gt; 0 a 1 11 1 b 2 11 2 c 3 22 In\u00a0[15]: Copied! <pre>df &gt;&gt; unnest(f.a) &gt;&gt; unnest(f.b)\n</pre> df &gt;&gt; unnest(f.a) &gt;&gt; unnest(f.b) Out[15]: a b c &lt;object&gt; &lt;int64&gt; &lt;int64&gt; 0 a 1 11 1 a 2 11 2 b 1 11 3 b 2 11 4 c 3 22"},{"location":"notebooks/nest/#nest","title":"\u2605 nest\u00b6","text":""},{"location":"notebooks/nest/#nesting-creates-a-list-column-of-data-frames","title":"Nesting creates a list-column of data frames\u00b6","text":""},{"location":"notebooks/nest/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>**cols</code>: Columns to nest <code>_names_sep</code>: If <code>None</code>, the default, the names will be left as is. \u2003\u2003\u2003\u2003Inner names will come from the former outer names \u2003\u2003\u2003\u2003If a string, the inner and outer names will be used together. \u2003\u2003\u2003\u2003The names of the new outer columns will be formed by pasting \u2003\u2003\u2003\u2003together the outer and the inner column names, separated by <code>_names_sep</code>.</p>"},{"location":"notebooks/nest/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003Nested data frame.</p>"},{"location":"notebooks/nest/#unnest","title":"\u2605 unnest\u00b6","text":""},{"location":"notebooks/nest/#flattens-list-column-of-data-frames-back-out-into-regular-columns","title":"Flattens list-column of data frames back out into regular columns.\u00b6","text":""},{"location":"notebooks/nest/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: A data frame to flatten. <code>*cols</code>: Columns to unnest. <code>keep_empty</code>: By default, you get one row of output for each element \u2003\u2003\u2003\u2003of the list your unchopping/unnesting. \u2003\u2003\u2003\u2003This means that if there's a size-0 element \u2003\u2003\u2003\u2003(like NULL or an empty data frame), that entire row will be \u2003\u2003\u2003\u2003dropped from the output. \u2003\u2003\u2003\u2003If you want to preserve all rows, use <code>keep_empty</code> = <code>True</code> to \u2003\u2003\u2003\u2003replace size-0 elements with a single row of missing values.</p> <p> <code>dtypes</code>: Providing the dtypes for the output columns. \u2003\u2003\u2003\u2003Could be a single dtype, which will be applied to all columns, or \u2003\u2003\u2003\u2003a dictionary of dtypes with keys for the columns and values the \u2003\u2003\u2003\u2003dtypes.</p> <p> <code>names_sep</code>: If <code>None</code>, the default, the names will be left as is. \u2003\u2003\u2003\u2003Inner names will come from the former outer names \u2003\u2003\u2003\u2003If a string, the inner and outer names will be used together. \u2003\u2003\u2003\u2003The names of the new outer columns will be formed by pasting \u2003\u2003\u2003\u2003together the outer and the inner column names, separated by <code>names_sep</code>.</p> <p> <code>names_repair</code>: treatment of problematic column names: \u2003\u2003\u2003\u2003- \"minimal\": No name repair or checks, beyond basic existence,</p> <p>\u2003\u2003\u2003\u2003- \"unique\": Make sure names are unique and not empty,</p> <p>\u2003\u2003\u2003\u2003- \"check_unique\": (default value), no name repair, \u2003\u2003\u2003\u2003\u2003\u2003but check they are unique,</p> <p>\u2003\u2003\u2003\u2003- \"universal\": Make the names unique and syntactic</p> <p>\u2003\u2003\u2003\u2003- a function: apply custom name repair</p>"},{"location":"notebooks/nest/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003Data frame with selected columns unnested.</p>"},{"location":"notebooks/nth/","title":"nth","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/nth.html\n%run nb_helpers.py\n\nfrom datar.all import nth, first, last\n\nnb_header(nth, first, last)\n</pre> # https://dplyr.tidyverse.org/reference/nth.html %run nb_helpers.py  from datar.all import nth, first, last  nb_header(nth, first, last) Try this notebook on binder. In\u00a0[2]: Copied! <pre>x = range(10)\ny = range(9, -1, -1)\n\nfirst(x)\n</pre> x = range(10) y = range(9, -1, -1)  first(x) Out[2]: <pre>0</pre> In\u00a0[3]: Copied! <pre>last(y)\n</pre> last(y) Out[3]: <pre>0</pre> In\u00a0[4]: Copied! <pre>nth(x, 1)\n</pre> nth(x, 1) Out[4]: <pre>1</pre> In\u00a0[5]: Copied! <pre>nth(x, 5)\n</pre> nth(x, 5) Out[5]: <pre>5</pre> In\u00a0[6]: Copied! <pre>nth(x, -2)\n</pre> nth(x, -2) Out[6]: <pre>8</pre> In\u00a0[7]: Copied! <pre>nth(x, 11)\n</pre> nth(x, 11) Out[7]: <pre>nan</pre> In\u00a0[8]: Copied! <pre>last(x)\n</pre> last(x) Out[8]: <pre>9</pre> In\u00a0[9]: Copied! <pre>last(x, y)\n</pre> last(x, y) Out[9]: <pre>0</pre> In\u00a0[11]: Copied! <pre>with try_catch():\n    first()\n</pre> with try_catch():     first() <pre>[TypeError] _first_obj() missing 1 required positional argument: 'x'\n</pre>"},{"location":"notebooks/nth/#nth","title":"\u2605 nth\u00b6","text":""},{"location":"notebooks/nth/#extract-the-nth-element-of-a-vector","title":"Extract the nth element of a vector\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/nth.html</p>"},{"location":"notebooks/nth/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A vector <code>n</code>: The index of the element to extract. <code>order_by</code>: A variable or function of variables to order by. <code>default</code>: A default value to return if <code>n</code> is out of bounds.</p>"},{"location":"notebooks/nth/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A value</p>"},{"location":"notebooks/nth/#first","title":"\u2605 first\u00b6","text":""},{"location":"notebooks/nth/#extract-the-first-element-of-a-vector","title":"Extract the first element of a vector\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/nth.html</p>"},{"location":"notebooks/nth/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A vector <code>order_by</code>: A variable or function of variables to order by. <code>default</code>: A default value to return if <code>x</code> is empty.</p>"},{"location":"notebooks/nth/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A value</p>"},{"location":"notebooks/nth/#last","title":"\u2605 last\u00b6","text":""},{"location":"notebooks/nth/#extract-the-last-element-of-a-vector","title":"Extract the last element of a vector\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/nth.html</p>"},{"location":"notebooks/nth/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A vector <code>order_by</code>: A variable or function of variables to order by. <code>default</code>: A default value to return if <code>x</code> is empty.</p>"},{"location":"notebooks/nth/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A value</p>"},{"location":"notebooks/other/","title":"other","text":"In\u00a0[2]: Copied! <pre># datar specific\n\nimport numpy\nfrom datar import f\nfrom datar.data import iris\nfrom datar.base import as_date, factor, c\nfrom datar.other import *\nfrom datar.dplyr import mutate, group_by\nfrom datar.tibble import tibble\n\n%run nb_helpers.py\nnb_header(\n    # get, \n    # flatten, \n    itemgetter, \n    attrgetter, \n    pd_str, \n    pd_cat, \n    pd_dt, \n    book='datar',\n)\n</pre> # datar specific  import numpy from datar import f from datar.data import iris from datar.base import as_date, factor, c from datar.other import * from datar.dplyr import mutate, group_by from datar.tibble import tibble  %run nb_helpers.py nb_header(     # get,      # flatten,      itemgetter,      attrgetter,      pd_str,      pd_cat,      pd_dt,      book='datar', ) Try this notebook on binder. In\u00a0[3]: Copied! <pre># iris &gt;&gt; get(c[:5])\n</pre> # iris &gt;&gt; get(c[:5]) In\u00a0[4]: Copied! <pre># iris &gt;&gt; get(cols=f.Species)\n</pre> # iris &gt;&gt; get(cols=f.Species) In\u00a0[5]: Copied! <pre># select single element\n# iris &gt;&gt; get(1, f.Species)\n</pre> # select single element # iris &gt;&gt; get(1, f.Species) In\u00a0[6]: Copied! <pre># get it as a single-element dataframe\n# iris &gt;&gt; get([1], f.Species)\n</pre> # get it as a single-element dataframe # iris &gt;&gt; get([1], f.Species) In\u00a0[7]: Copied! <pre># or \n# iris &gt;&gt; get(1, [f.Species])\n</pre> # or  # iris &gt;&gt; get(1, [f.Species]) In\u00a0[8]: Copied! <pre>df = tibble(x=c[1:3], y=c[3:5])\n# df &gt;&gt; flatten()\n</pre> df = tibble(x=c[1:3], y=c[3:5]) # df &gt;&gt; flatten() In\u00a0[12]: Copied! <pre>arr = numpy.array(['a', 'b', 'c', 'd', 'e'])\n# df &gt;&gt; mutate(a=arr[f.x], b=arr[f.y])  # Error\ndf &gt;&gt; mutate(a=itemgetter(arr, f.x.values), b=itemgetter(arr, f.y.values))\n</pre> arr = numpy.array(['a', 'b', 'c', 'd', 'e']) # df &gt;&gt; mutate(a=arr[f.x], b=arr[f.y])  # Error df &gt;&gt; mutate(a=itemgetter(arr, f.x.values), b=itemgetter(arr, f.y.values)) Out[12]: x y a b &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;object&gt; 0 1 3 b d 1 2 4 c e In\u00a0[13]: Copied! <pre>df = tibble(x=[\"abc\", \"def\"])\ndf &gt;&gt; mutate(a=attrgetter(f.x, 'str').upper())\n</pre> df = tibble(x=[\"abc\", \"def\"]) df &gt;&gt; mutate(a=attrgetter(f.x, 'str').upper()) Out[13]: x a &lt;object&gt; &lt;object&gt; 0 abc ABC 1 def DEF In\u00a0[14]: Copied! <pre># or\n# df &gt;&gt; mutate(a=pd_str(f.x).upper())\n# or\ndf &gt;&gt; mutate(a=f.x.str.upper())\n</pre> # or # df &gt;&gt; mutate(a=pd_str(f.x).upper()) # or df &gt;&gt; mutate(a=f.x.str.upper()) Out[14]: x a &lt;object&gt; &lt;object&gt; 0 abc ABC 1 def DEF In\u00a0[15]: Copied! <pre># but when df is grouped\ngf = df &gt;&gt; group_by(g=[1, 2])\n# pd_str(gf.x)[:2].obj\ngf &gt;&gt; mutate(a=pd_str(gf.x)[:2])\n</pre> # but when df is grouped gf = df &gt;&gt; group_by(g=[1, 2]) # pd_str(gf.x)[:2].obj gf &gt;&gt; mutate(a=pd_str(gf.x)[:2]) Out[15]: x g a &lt;object&gt; &lt;int64&gt; &lt;object&gt; 0 abc 1 ab 1 def 2 de <p>TibbleGrouped: g (n=2) </p> In\u00a0[16]: Copied! <pre>gf = (\n    tibble(x=[\"2022-01-01\", \"2022-12-02\"])\n    &gt;&gt; mutate(x=as_date(f.x, format=\"%Y-%m-%d\"))\n    &gt;&gt; group_by(g=[1, 2])\n)\ngf &gt;&gt; mutate(month=pd_dt(gf.x).month)\n</pre> gf = (     tibble(x=[\"2022-01-01\", \"2022-12-02\"])     &gt;&gt; mutate(x=as_date(f.x, format=\"%Y-%m-%d\"))     &gt;&gt; group_by(g=[1, 2]) ) gf &gt;&gt; mutate(month=pd_dt(gf.x).month) Out[16]: x g month &lt;datetime64[ns]&gt; &lt;int64&gt; &lt;int64&gt; 0 2022-01-01 1 1 1 2022-12-02 2 12 <p>TibbleGrouped: g (n=2) </p> In\u00a0[17]: Copied! <pre>gf = (\n    tibble(x=factor([1, 2], levels=[1, 2, 3]))\n    &gt;&gt; group_by(g=[1, 2])\n)\ngf &gt;&gt; mutate(codes=pd_cat(gf.x).codes)\n</pre> gf = (     tibble(x=factor([1, 2], levels=[1, 2, 3]))     &gt;&gt; group_by(g=[1, 2]) ) gf &gt;&gt; mutate(codes=pd_cat(gf.x).codes) Out[17]: x g codes &lt;category&gt; &lt;int64&gt; &lt;int8&gt; 0 1 1 0 1 2 2 1 <p>TibbleGrouped: g (n=2) </p>"},{"location":"notebooks/other/#itemgetter","title":"\u2605 itemgetter\u00b6","text":""},{"location":"notebooks/other/#itemgetter-as-a-function-for-verb","title":"Itemgetter as a function for verb\u00b6","text":"<p>In datar expression, we can do:</p> <p>arr = [1,2,3] tibble(x=2) &gt;&gt; mutate(y=arr[f.x])</p> <p>Since <code>arr[f.x]</code> won't compile. We need to use the <code>itemgetter</code> operator:</p> <p>tibble(x=2) &gt;&gt; mutate(y=itemgetter(arr, f.x))</p>"},{"location":"notebooks/other/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: The data to be get items from <code>subscr</code>: The subscripts</p>"},{"location":"notebooks/other/#attrgetter","title":"\u2605 attrgetter\u00b6","text":""},{"location":"notebooks/other/#attrgetter-as-a-function-for-verb","title":"Attrgetter as a function for verb\u00b6","text":"<p>This is helpful when we want to access to an accessor (ie. CategoricalAccessor) from a SeriesGroupBy object</p>"},{"location":"notebooks/other/#pd_str","title":"\u2605 pd_str\u00b6","text":""},{"location":"notebooks/other/#pandas-str-accessor-for-a-series-xstr","title":"Pandas' str accessor for a Series (x.str)\u00b6","text":"<p>This is helpful when x is a SeriesGroupBy object</p>"},{"location":"notebooks/other/#pd_cat","title":"\u2605 pd_cat\u00b6","text":""},{"location":"notebooks/other/#pandas-cat-accessor-for-a-series-xcat","title":"Pandas' cat accessor for a Series (x.cat)\u00b6","text":"<p>This is helpful when x is a SeriesGroupBy object</p>"},{"location":"notebooks/other/#pd_dt","title":"\u2605 pd_dt\u00b6","text":""},{"location":"notebooks/other/#pandas-dt-accessor-for-a-series-xdt","title":"Pandas' dt accessor for a Series (x.dt)\u00b6","text":"<p>This is helpful when x is a SeriesGroupBy object</p>"},{"location":"notebooks/pack/","title":"pack","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\n\nfrom datar.data import iris\nfrom datar.all import *\n\nnb_header(pack, unpack)\n</pre> %run nb_helpers.py  from datar.data import iris from datar.all import *  nb_header(pack, unpack) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x1 = c[1:3], x2 = c[4:6], x3 = c[7:9], y = c[1:3])\ndf\n</pre> df = tibble(x1 = c[1:3], x2 = c[4:6], x3 = c[7:9], y = c[1:3]) df Out[2]: x1 x2 x3 y &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 1 4 7 1 1 2 5 8 2 In\u00a0[3]: Copied! <pre>df &gt;&gt; pack(x=starts_with('x'))\n</pre> df &gt;&gt; pack(x=starts_with('x')) Out[3]: y x$x1 x$x2 x$x3 &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 1 1 4 7 1 2 2 5 8 In\u00a0[4]: Copied! <pre>df &gt;&gt; pack(x=c(f.x1, f.x2, f.x3), y=f.y)\n</pre> df &gt;&gt; pack(x=c(f.x1, f.x2, f.x3), y=f.y) Out[4]: x$x1 x$x2 x$x3 y$y &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 1 4 7 1 1 2 5 8 2 In\u00a0[5]: Copied! <pre>iris &gt;&gt; pack(\n    Sepal=starts_with(\"Sepal\"),\n    Petal=starts_with(\"Petal\"),\n    _names_sep=\"_\"\n)\n</pre> iris &gt;&gt; pack(     Sepal=starts_with(\"Sepal\"),     Petal=starts_with(\"Petal\"),     _names_sep=\"_\" ) Out[5]: Species Sepal$Length Sepal$Width Petal$Length Petal$Width &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 setosa 5.1 3.5 1.4 0.2 1 setosa 4.9 3.0 1.4 0.2 2 setosa 4.7 3.2 1.3 0.2 3 setosa 4.6 3.1 1.5 0.2 ... ... ... ... ... ... 4 setosa 5.0 3.6 1.4 0.2 145 virginica 6.7 3.0 5.2 2.3 146 virginica 6.3 2.5 5.0 1.9 147 virginica 6.5 3.0 5.2 2.0 148 virginica 6.2 3.4 5.4 2.3 149 virginica 5.9 3.0 5.1 1.8 <p>150 rows \u00d7 5 columns</p> In\u00a0[6]: Copied! <pre># Unpacking ===========================================================\n\ndf = tibble(\n  x = c[1:4],\n  y = tibble(a = c[1:4], b = c[4:1]),\n  z = tibble(X = c(\"a\", \"b\", \"c\"), Y = runif(3), Z = c(TRUE, FALSE, NA))\n)\ndf\n</pre> # Unpacking ===========================================================  df = tibble(   x = c[1:4],   y = tibble(a = c[1:4], b = c[4:1]),   z = tibble(X = c(\"a\", \"b\", \"c\"), Y = runif(3), Z = c(TRUE, FALSE, NA)) ) df Out[6]: x y$a y$b z$X z$Y z$Z &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; 0 1 1 4 a 0.286761 True 1 2 2 3 b 0.532775 False 2 3 3 2 c 0.497844 NaN In\u00a0[7]: Copied! <pre>df &gt;&gt; unpack(f.y)\n</pre> df &gt;&gt; unpack(f.y) Out[7]: x a b z$X z$Y z$Z &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; 0 1 1 4 a 0.286761 True 1 2 2 3 b 0.532775 False 2 3 3 2 c 0.497844 NaN In\u00a0[8]: Copied! <pre>df &gt;&gt; unpack(c(f.y, f.z))\n</pre> df &gt;&gt; unpack(c(f.y, f.z)) Out[8]: x a b X Y Z &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; 0 1 1 4 a 0.286761 True 1 2 2 3 b 0.532775 False 2 3 3 2 c 0.497844 NaN In\u00a0[9]: Copied! <pre>df &gt;&gt; unpack(c(f.y, f.z), names_sep=\"_\")\n</pre> df &gt;&gt; unpack(c(f.y, f.z), names_sep=\"_\")  Out[9]: x y_a y_b z_X z_Y z_Z &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; 0 1 1 4 a 0.286761 True 1 2 2 3 b 0.532775 False 2 3 3 2 c 0.497844 NaN In\u00a0[10]: Copied! <pre>with try_catch():\n    # indexes from inner data frame counts\n    df &gt;&gt; unpack(c(2,3))\n</pre> with try_catch():     # indexes from inner data frame counts     df &gt;&gt; unpack(c(2,3)) Out[10]: x a b X Y Z &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; 0 1 1 4 a 0.286761 True 1 2 2 3 b 0.532775 False 2 3 3 2 c 0.497844 NaN In\u00a0[11]: Copied! <pre>df &gt;&gt; unpack(c(2,4))\n</pre> df &gt;&gt; unpack(c(2,4)) Out[11]: x a b X Y Z &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; 0 1 1 4 a 0.286761 True 1 2 2 3 b 0.532775 False 2 3 3 2 c 0.497844 NaN"},{"location":"notebooks/pack/#pack","title":"\u2605 pack\u00b6","text":""},{"location":"notebooks/pack/#makes-df-narrow-by-collapsing-a-set-of-columns-into-a-single-df-column","title":"Makes df narrow by collapsing a set of columns into a single df-column.\u00b6","text":""},{"location":"notebooks/pack/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>**cols</code>: Columns to pack <code>_names_sep</code>: If <code>None</code>, the default, the names will be left as is. \u2003\u2003\u2003\u2003Inner names will come from the former outer names \u2003\u2003\u2003\u2003If a string, the inner and outer names will be used together. \u2003\u2003\u2003\u2003The names of the new outer columns will be formed by pasting \u2003\u2003\u2003\u2003together the outer and the inner column names, separated by <code>_names_sep</code>.</p>"},{"location":"notebooks/pack/#unpack","title":"\u2605 unpack\u00b6","text":""},{"location":"notebooks/pack/#makes-df-wider-by-expanding-df-columns-back-out-into-individual-columns","title":"Makes df wider by expanding df-columns back out into individual columns.\u00b6","text":"<p>For empty columns, the column is kept asis, instead of removing it.</p>"},{"location":"notebooks/pack/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: A data frame <code>cols</code>: Columns to unpack <code>names_sep</code>: If <code>None</code>, the default, the names will be left as is. \u2003\u2003\u2003\u2003Inner names will come from the former outer names \u2003\u2003\u2003\u2003If a string, the inner and outer names will be used together. \u2003\u2003\u2003\u2003The names of the new outer columns will be formed by pasting \u2003\u2003\u2003\u2003together the outer and the inner column names, separated by <code>_names_sep</code>.</p> <p> <code>name_repair</code>: treatment of problematic column names: \u2003\u2003\u2003\u2003- \"minimal\": No name repair or checks, beyond basic existence,</p> <p>\u2003\u2003\u2003\u2003- \"unique\": Make sure names are unique and not empty,</p> <p>\u2003\u2003\u2003\u2003- \"check_unique\": (default value), no name repair, \u2003\u2003\u2003\u2003\u2003\u2003but check they are unique,</p> <p>\u2003\u2003\u2003\u2003- \"universal\": Make the names unique and syntactic</p> <p>\u2003\u2003\u2003\u2003- a function: apply custom name repair</p>"},{"location":"notebooks/pack/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003Data frame with given columns unpacked.</p>"},{"location":"notebooks/pivot_longer/","title":"pivot_longer","text":"In\u00a0[1]: Copied! <pre># https://tidyr.tidyverse.org/reference/pivot_longer.html\n%run nb_helpers.py\n\nfrom datar.data import relig_income, billboard, who, anscombe\nfrom datar.all import *\n\nnb_header(pivot_longer)\n</pre> # https://tidyr.tidyverse.org/reference/pivot_longer.html %run nb_helpers.py  from datar.data import relig_income, billboard, who, anscombe from datar.all import *  nb_header(pivot_longer) Try this notebook on binder. <p>\"lengthens\" data, increasing the number of rows and decreasing the number of columns.</p> <pre><code>The row order is a bit different from `tidyr` and `pandas.DataFrame.melt`.\n    &gt;&gt;&gt; df = tibble(x=c[1:2], y=c[3:4])\n    &gt;&gt;&gt; pivot_longer(df, f[f.x:f.y])\n    &gt;&gt;&gt; #    name   value\n    &gt;&gt;&gt; # 0  x      1\n    &gt;&gt;&gt; # 1  x      2\n    &gt;&gt;&gt; # 2  y      3\n    &gt;&gt;&gt; # 3  y      4\nBut with `tidyr::pivot_longer`, the output will be:\n    &gt;&gt;&gt; # # A tibble: 4 x 2\n    &gt;&gt;&gt; # name  value\n    &gt;&gt;&gt; # &lt;chr&gt; &lt;int&gt;\n    &gt;&gt;&gt; # 1 x   1\n    &gt;&gt;&gt; # 2 y   3\n    &gt;&gt;&gt; # 3 x   2\n    &gt;&gt;&gt; # 4 y   4\n\nArgs:\n    _data: A data frame to pivot.\n    cols: Columns to pivot into longer format.\n    names_to: A string specifying the name of the column to create from\n        the data stored in the column names of data.\n        Can be a character vector, creating multiple columns, if names_sep\n        or names_pattern is provided. In this case, there are two special\n        values you can take advantage of:\n        - `None`/`NA`/`NULL` will discard that component of the name.\n        - `.value`/`_value` indicates that component of the name defines\n            the name of the column containing the cell values,\n            overriding values_to.\n        - Different as `tidyr`: With `.value`/`_value`, if there are other\n          parts of the names to distinguish the groups, they must be\n          captured. For example, use `r'(\\w)_(\\d)'` to match `'a_1'` and\n          `['.value', NA]` to discard the suffix, instead of use\n          `r'(\\w)_\\d'` to match.\n    names_prefix: A regular expression used to remove matching text from\n        the start of each variable name.\n    names_sep: and\n    names_pattern: If names_to contains multiple values,\n        these arguments control how the column name is broken up.\n        names_sep takes the same specification as separate(), and\n        can either be a numeric vector (specifying positions to break on),\n        or a single string (specifying a regular expression to split on).\n    names_pattern: takes the same specification as extract(),\n        a regular expression containing matching groups (()).\n    names_dtypes: and\n    values_dtypes: A list of column name-prototype pairs.\n        A prototype (or dtypes for short) is a zero-length vector\n        (like integer() or numeric()) that defines the type, class, and\n        attributes of a vector. Use these arguments if you want to confirm\n        that the created columns are the types that you expect.\n        Note that if you want to change (instead of confirm) the types\n        of specific columns, you should use names_transform or\n        values_transform instead.\n    names_transform: and\n    values_transform: A list of column name-function pairs.\n        Use these arguments if you need to change the types of\n        specific columns. For example,\n        names_transform = dict(week = as.integer) would convert a\n        character variable called week to an integer.\n        If not specified, the type of the columns generated from names_to\n        will be character, and the type of the variables generated from\n        values_to will be the common type of the input columns used to\n        generate them.\n    names_repair: Not supported yet.\n    values_to: A string specifying the name of the column to create from\n        the data stored in cell values. If names_to is a character\n        containing the special `.value`/`_value` sentinel, this value\n        will be ignored, and the name of the value column will be derived\n        from part of the existing column names.\n    values_drop_na: If TRUE, will drop rows that contain only NAs in\n        the value_to column. This effectively converts explicit missing\n        values to implicit missing values, and should generally be used\n        only when missing values in data were created by its structure.\n    names_repair: treatment of problematic column names:\n        - \"minimal\": No name repair or checks, beyond basic existence,\n        - \"unique\": Make sure names are unique and not empty,\n        - \"check_unique\": (default value), no name repair,\n            but check they are unique,\n        - \"universal\": Make the names unique and syntactic\n        - a function: apply custom name repair\n\nReturns:\n    The pivoted dataframe.</code></pre> In\u00a0[2]: Copied! <pre>relig_income\n</pre> relig_income Out[2]: religion &lt;$10k $10-20k $20-30k $30-40k $40-50k $50-75k $75-100k $100-150k &gt;150k Don't know/refused &lt;object&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 Agnostic 27 34 60 81 76 137 122 109 84 96 1 Atheist 12 27 37 52 35 70 73 59 74 76 2 Buddhist 27 21 30 34 33 58 62 39 53 54 3 Catholic 418 617 732 670 638 1116 949 792 633 1489 4 Don\u2019t know/refused 15 14 15 11 10 35 21 17 18 116 5 Evangelical Prot 575 869 1064 982 881 1486 949 723 414 1529 6 Hindu 1 9 7 9 11 34 47 48 54 37 7 Historically Black Prot 228 244 236 238 197 223 131 81 78 339 8 Jehovah's Witness 20 27 24 24 21 30 15 11 6 37 9 Jewish 19 19 25 25 30 95 69 87 151 162 10 Mainline Prot 289 495 619 655 651 1107 939 753 634 1328 11 Mormon 29 40 48 51 56 112 85 49 42 69 12 Muslim 6 7 9 10 9 23 16 8 6 22 13 Orthodox 13 17 23 32 32 47 38 42 46 73 14 Other Christian 9 7 11 13 13 14 18 14 12 18 15 Other Faiths 20 33 40 46 49 63 46 40 41 71 16 Other World Religions 5 2 3 4 2 7 3 4 4 8 17 Unaffiliated 217 299 374 365 341 528 407 321 258 597 In\u00a0[3]: Copied! <pre>relig_income &gt;&gt; \\\n  pivot_longer(~f.religion, names_to=\"income\", values_to=\"count\")\n</pre> relig_income &gt;&gt; \\   pivot_longer(~f.religion, names_to=\"income\", values_to=\"count\") Out[3]: religion income count &lt;object&gt; &lt;object&gt; &lt;int64&gt; 0 Agnostic &lt;$10k 27 1 Atheist &lt;$10k 12 2 Buddhist &lt;$10k 27 3 Catholic &lt;$10k 418 ... ... ... ... 4 Don\u2019t know/refused &lt;$10k 15 175 Orthodox Don't know/refused 73 176 Other Christian Don't know/refused 18 177 Other Faiths Don't know/refused 71 178 Other World Religions Don't know/refused 8 179 Unaffiliated Don't know/refused 597 <p>180 rows \u00d7 3 columns</p> In\u00a0[4]: Copied! <pre>billboard\n</pre> billboard Out[4]: artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 ... wk67 wk68 wk69 wk70 wk71 wk72 wk73 wk74 wk75 wk76 &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; ... &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 2 Pac Baby Don't Cry (Keep... 2000-02-26 87 82.0 72.0 77.0 87.0 94.0 99.0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 1 2Ge+her The Hardest Part Of ... 2000-09-02 91 87.0 92.0 NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 2 3 Doors Down Kryptonite 2000-04-08 81 70.0 68.0 67.0 66.0 57.0 54.0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 3 3 Doors Down Loser 2000-10-21 76 76.0 72.0 69.0 67.0 65.0 55.0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 4 504 Boyz Wobble Wobble 2000-04-15 57 34.0 25.0 17.0 17.0 31.0 36.0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 312 Yankee Grey Another Nine Minutes 2000-04-29 86 83.0 77.0 74.0 83.0 79.0 88.0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 313 Yearwood, Trisha Real Live Woman 2000-04-01 85 83.0 83.0 82.0 81.0 91.0 NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 314 Ying Yang Twins Whistle While You Tw... 2000-03-18 95 94.0 91.0 85.0 84.0 78.0 74.0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 315 Zombie Nation Kernkraft 400 2000-09-02 99 99.0 NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 316 matchbox twenty Bent 2000-04-29 60 37.0 29.0 24.0 22.0 21.0 18.0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN <p>317 rows \u00d7 79 columns</p> In\u00a0[5]: Copied! <pre>billboard &gt;&gt; \\\n pivot_longer(\n   cols = starts_with(\"wk\"),\n   names_to = \"week\",\n   names_prefix = \"wk\",\n   values_to = \"rank\",\n   values_drop_na = TRUE\n )\n</pre> billboard &gt;&gt; \\  pivot_longer(    cols = starts_with(\"wk\"),    names_to = \"week\",    names_prefix = \"wk\",    values_to = \"rank\",    values_drop_na = TRUE  ) Out[5]: artist date.entered track week rank &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; 0 2 Pac 2000-02-26 Baby Don't Cry (Keep... 1 87.0 1 2Ge+her 2000-09-02 The Hardest Part Of ... 1 91.0 2 3 Doors Down 2000-04-08 Kryptonite 1 81.0 3 3 Doors Down 2000-10-21 Loser 1 76.0 ... ... ... ... ... ... 4 504 Boyz 2000-04-15 Wobble Wobble 1 57.0 19716 Creed 1999-09-11 Higher 63 50.0 19833 Lonestar 1999-06-05 Amazed 63 45.0 20033 Creed 1999-09-11 Higher 64 50.0 20150 Lonestar 1999-06-05 Amazed 64 50.0 20350 Creed 1999-09-11 Higher 65 49.0 <p>5307 rows \u00d7 5 columns</p> In\u00a0[6]: Copied! <pre>who &gt;&gt; pivot_longer(\n  cols = f[f.new_sp_m014:f.newrel_f65],\n  names_to = c(\"diagnosis\", \"gender\", \"age\"),\n  names_pattern = r\"new_?(.*)_(.)(.*)\",\n  values_to = \"count\"\n)\n</pre> who &gt;&gt; pivot_longer(   cols = f[f.new_sp_m014:f.newrel_f65],   names_to = c(\"diagnosis\", \"gender\", \"age\"),   names_pattern = r\"new_?(.*)_(.)(.*)\",   values_to = \"count\" ) Out[6]: country iso2 iso3 newrel_f65 year diagnosis gender age count &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;int64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; 0 Afghanistan AF AFG NaN 1980 sp m 014 NaN 1 Afghanistan AF AFG NaN 1981 sp m 014 NaN 2 Afghanistan AF AFG NaN 1982 sp m 014 NaN 3 Afghanistan AF AFG NaN 1983 sp m 014 NaN ... ... ... ... ... ... ... ... ... ... 4 Afghanistan AF AFG NaN 1984 sp m 014 NaN 398195 Zimbabwe ZW ZWE NaN 2009 rel f 5564 NaN 398196 Zimbabwe ZW ZWE NaN 2010 rel f 5564 NaN 398197 Zimbabwe ZW ZWE NaN 2011 rel f 5564 NaN 398198 Zimbabwe ZW ZWE NaN 2012 rel f 5564 NaN 398199 Zimbabwe ZW ZWE 725.0 2013 rel f 5564 811.0 <p>398200 rows \u00d7 9 columns</p> In\u00a0[7]: Copied! <pre>anscombe\n</pre> anscombe Out[7]: x1 x2 x3 x4 y1 y2 y3 y4 &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 10 10 10 8 8.04 9.14 7.46 6.58 1 8 8 8 8 6.95 8.14 6.77 5.76 2 13 13 13 8 7.58 8.74 12.74 7.71 3 9 9 9 8 8.81 8.77 7.11 8.84 4 11 11 11 8 8.33 9.26 7.81 8.47 5 14 14 14 8 9.96 8.10 8.84 7.04 6 6 6 6 8 7.24 6.13 6.08 5.25 7 4 4 4 19 4.26 3.10 5.39 12.50 8 12 12 12 8 10.84 9.13 8.15 5.56 9 7 7 7 8 4.82 7.26 6.42 7.91 10 5 5 5 8 5.68 4.74 5.73 6.89 In\u00a0[8]: Copied! <pre>anscombe &gt;&gt; \\\n pivot_longer(everything(),\n   names_to = c(\".value\", \"set\"),\n   names_pattern = r\"(.)(.)\"\n )\n</pre> anscombe &gt;&gt; \\  pivot_longer(everything(),    names_to = c(\".value\", \"set\"),    names_pattern = r\"(.)(.)\"  ) Out[8]: set x y &lt;object&gt; &lt;float64&gt; &lt;float64&gt; 0 1 10.0 8.04 1 2 10.0 9.14 2 3 10.0 7.46 3 4 8.0 6.58 4 1 8.0 6.95 5 2 8.0 8.14 6 3 8.0 6.77 7 4 8.0 5.76 8 1 13.0 7.58 9 2 13.0 8.74 10 3 13.0 12.74 11 4 8.0 7.71 12 1 9.0 8.81 13 2 9.0 8.77 14 3 9.0 7.11 15 4 8.0 8.84 16 1 11.0 8.33 17 2 11.0 9.26 18 3 11.0 7.81 19 4 8.0 8.47 20 1 14.0 9.96 21 2 14.0 8.10 22 3 14.0 8.84 23 4 8.0 7.04 24 1 6.0 7.24 25 2 6.0 6.13 26 3 6.0 6.08 27 4 8.0 5.25 28 1 4.0 4.26 29 2 4.0 3.10 30 3 4.0 5.39 31 4 19.0 12.50 32 1 12.0 10.84 33 2 12.0 9.13 34 3 12.0 8.15 35 4 8.0 5.56 36 1 7.0 4.82 37 2 7.0 7.26 38 3 7.0 6.42 39 4 8.0 7.91 40 1 5.0 5.68 41 2 5.0 4.74 42 3 5.0 5.73 43 4 8.0 6.89 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/pivot_longer/#pivot_longer","title":"\u2605 pivot_longer\u00b6","text":""},{"location":"notebooks/pivot_wider/","title":"pivot_wider","text":"In\u00a0[1]: Copied! <pre># https://tidyr.tidyverse.org/reference/pivot_wider.html\n%run nb_helpers.py\n\nfrom datar.data import fish_encounters, us_rent_income, warpbreaks \nfrom datar.all import *\n\nnb_header(pivot_wider)\n</pre> # https://tidyr.tidyverse.org/reference/pivot_wider.html %run nb_helpers.py  from datar.data import fish_encounters, us_rent_income, warpbreaks  from datar.all import *  nb_header(pivot_wider) Try this notebook on binder. <p>\"widens\" data, increasing the number of columns and decreasing the number of rows.</p> <pre><code>Args:\n    _data: A data frame to pivot.\n    id_cols: A set of columns that uniquely identifies each observation.\n        Defaults to all columns in data except for the columns specified\n        in names_from and values_from.\n    names_from: and\n    values_from: A pair of arguments describing which column\n        (or columns) to get the name of the output column (names_from),\n        and which column (or columns) to get the cell values from\n        (values_from).\n    names_prefix: String added to the start of every variable name.\n    names_sep: If names_from or values_from contains multiple variables,\n        this will be used to join their values together into a single\n        string to use as a column name.\n    names_glue: Instead of names_sep and names_prefix, you can supply\n        a glue specification that uses the names_from columns\n        (and special _value) to create custom column names.\n    names_sort: Should the column names be sorted? If FALSE, the default,\n        column names are ordered by first appearance.\n    names_repair: todo\n    values_fill: Optionally, a (scalar) value that specifies what\n        each value should be filled in with when missing.\n    values_fn: Optionally, a function applied to the value in each cell\n        in the output. You will typically use this when the combination\n        of `id_cols` and value column does not uniquely identify\n        an observation.\n        This can be a dict you want to apply different aggregations to\n        different value columns.\n        If not specified, will be `numpy.mean`\n\nReturns:\n    The pivoted dataframe.</code></pre> In\u00a0[2]: Copied! <pre>fish_encounters\n</pre> fish_encounters Out[2]: fish station seen &lt;int64&gt; &lt;object&gt; &lt;int64&gt; 0 4842 Release 1 1 4842 I80_1 1 2 4842 Lisbon 1 3 4842 Rstr 1 ... ... ... ... 4 4842 Base_TD 1 109 4864 Release 1 110 4864 I80_1 1 111 4865 Release 1 112 4865 I80_1 1 113 4865 Lisbon 1 <p>114 rows \u00d7 3 columns</p> In\u00a0[3]: Copied! <pre>fish_encounters &gt;&gt; \\\n  pivot_wider(names_from=f.station, values_from=f.seen)\n</pre> fish_encounters &gt;&gt; \\   pivot_wider(names_from=f.station, values_from=f.seen) Out[3]: fish BCE BCE2 BCW BCW2 Base_TD I80_1 Lisbon MAE MAW Release Rstr &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 4842 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1 4843 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 2 4844 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 3 4845 NaN NaN NaN NaN 1.0 1.0 1.0 NaN NaN 1.0 1.0 4 4847 NaN NaN NaN NaN NaN 1.0 1.0 NaN NaN 1.0 NaN 5 4848 NaN NaN NaN NaN NaN 1.0 1.0 NaN NaN 1.0 1.0 6 4849 NaN NaN NaN NaN NaN 1.0 NaN NaN NaN 1.0 NaN 7 4850 1.0 NaN 1.0 NaN 1.0 1.0 NaN NaN NaN 1.0 1.0 8 4851 NaN NaN NaN NaN NaN 1.0 NaN NaN NaN 1.0 NaN 9 4854 NaN NaN NaN NaN NaN 1.0 NaN NaN NaN 1.0 NaN 10 4855 NaN NaN NaN NaN 1.0 1.0 1.0 NaN NaN 1.0 1.0 11 4857 1.0 1.0 1.0 1.0 1.0 1.0 1.0 NaN NaN 1.0 1.0 12 4858 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 13 4859 NaN NaN NaN NaN 1.0 1.0 1.0 NaN NaN 1.0 1.0 14 4861 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 15 4862 1.0 1.0 1.0 1.0 1.0 1.0 1.0 NaN NaN 1.0 1.0 16 4863 NaN NaN NaN NaN NaN 1.0 NaN NaN NaN 1.0 NaN 17 4864 NaN NaN NaN NaN NaN 1.0 NaN NaN NaN 1.0 NaN 18 4865 NaN NaN NaN NaN NaN 1.0 1.0 NaN NaN 1.0 NaN In\u00a0[4]: Copied! <pre>fish_encounters &gt;&gt; \\\n  pivot_wider(names_from=f.station, values_from=f.seen, values_fill=0)\n</pre> fish_encounters &gt;&gt; \\   pivot_wider(names_from=f.station, values_from=f.seen, values_fill=0) Out[4]: fish BCE BCE2 BCW BCW2 Base_TD I80_1 Lisbon MAE MAW Release Rstr &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 4842 1 1 1 1 1 1 1 1 1 1 1 1 4843 1 1 1 1 1 1 1 1 1 1 1 2 4844 1 1 1 1 1 1 1 1 1 1 1 3 4845 0 0 0 0 1 1 1 0 0 1 1 4 4847 0 0 0 0 0 1 1 0 0 1 0 5 4848 0 0 0 0 0 1 1 0 0 1 1 6 4849 0 0 0 0 0 1 0 0 0 1 0 7 4850 1 0 1 0 1 1 0 0 0 1 1 8 4851 0 0 0 0 0 1 0 0 0 1 0 9 4854 0 0 0 0 0 1 0 0 0 1 0 10 4855 0 0 0 0 1 1 1 0 0 1 1 11 4857 1 1 1 1 1 1 1 0 0 1 1 12 4858 1 1 1 1 1 1 1 1 1 1 1 13 4859 0 0 0 0 1 1 1 0 0 1 1 14 4861 1 1 1 1 1 1 1 1 1 1 1 15 4862 1 1 1 1 1 1 1 0 0 1 1 16 4863 0 0 0 0 0 1 0 0 0 1 0 17 4864 0 0 0 0 0 1 0 0 0 1 0 18 4865 0 0 0 0 0 1 1 0 0 1 0 In\u00a0[5]: Copied! <pre>us_rent_income\n</pre> us_rent_income Out[5]: GEOID NAME variable estimate moe &lt;int64&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;float64&gt; 0 1 Alabama income 24476.0 136.0 1 1 Alabama rent 747.0 3.0 2 2 Alaska income 32940.0 508.0 3 2 Alaska rent 1200.0 13.0 ... ... ... ... ... ... 4 4 Arizona income 27517.0 148.0 99 55 Wisconsin rent 813.0 3.0 100 56 Wyoming income 30854.0 342.0 101 56 Wyoming rent 828.0 11.0 102 72 Puerto Rico income NaN NaN 103 72 Puerto Rico rent 464.0 6.0 <p>104 rows \u00d7 5 columns</p> In\u00a0[6]: Copied! <pre>us_rent_income &gt;&gt; \\\n  pivot_wider(names_from=f.variable, values_from=c(f.estimate, f.moe))\n</pre> us_rent_income &gt;&gt; \\   pivot_wider(names_from=f.variable, values_from=c(f.estimate, f.moe)) Out[6]: GEOID NAME estimate_income estimate_rent moe_income moe_rent &lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 1 Alabama 24476.0 747.0 136.0 3.0 1 2 Alaska 32940.0 1200.0 508.0 13.0 2 4 Arizona 27517.0 972.0 148.0 4.0 3 5 Arkansas 23789.0 709.0 165.0 5.0 4 6 California 29454.0 1358.0 109.0 3.0 5 8 Colorado 32401.0 1125.0 109.0 5.0 6 9 Connecticut 35326.0 1123.0 195.0 5.0 7 10 Delaware 31560.0 1076.0 247.0 10.0 8 11 District of Columbia 43198.0 1424.0 681.0 17.0 9 12 Florida 25952.0 1077.0 70.0 3.0 10 13 Georgia 27024.0 927.0 106.0 3.0 11 15 Hawaii 32453.0 1507.0 218.0 18.0 12 16 Idaho 25298.0 792.0 208.0 7.0 13 17 Illinois 30684.0 952.0 83.0 3.0 14 18 Indiana 27247.0 782.0 117.0 3.0 15 19 Iowa 30002.0 740.0 143.0 4.0 16 20 Kansas 29126.0 801.0 208.0 5.0 17 21 Kentucky 24702.0 713.0 159.0 4.0 18 22 Louisiana 25086.0 825.0 155.0 4.0 19 23 Maine 26841.0 808.0 187.0 7.0 20 24 Maryland 37147.0 1311.0 152.0 5.0 21 25 Massachusetts 34498.0 1173.0 199.0 5.0 22 26 Michigan 26987.0 824.0 82.0 3.0 23 27 Minnesota 32734.0 906.0 189.0 4.0 24 28 Mississippi 22766.0 740.0 194.0 5.0 25 29 Missouri 26999.0 784.0 113.0 4.0 26 30 Montana 26249.0 751.0 206.0 9.0 27 31 Nebraska 30020.0 773.0 146.0 4.0 28 32 Nevada 29019.0 1017.0 213.0 6.0 29 33 New Hampshire 33172.0 1052.0 387.0 9.0 30 34 New Jersey 35075.0 1249.0 148.0 4.0 31 35 New Mexico 24457.0 809.0 214.0 6.0 32 36 New York 31057.0 1194.0 69.0 3.0 33 37 North Carolina 26482.0 844.0 111.0 3.0 34 38 North Dakota 32336.0 775.0 245.0 9.0 35 39 Ohio 27435.0 764.0 94.0 2.0 36 40 Oklahoma 26207.0 766.0 101.0 3.0 37 41 Oregon 27389.0 988.0 146.0 4.0 38 42 Pennsylvania 28923.0 885.0 119.0 3.0 39 44 Rhode Island 30210.0 957.0 259.0 6.0 40 45 South Carolina 25454.0 836.0 123.0 4.0 41 46 South Dakota 28821.0 696.0 276.0 7.0 42 47 Tennessee 25453.0 808.0 102.0 4.0 43 48 Texas 28063.0 952.0 110.0 2.0 44 49 Utah 27928.0 948.0 239.0 6.0 45 50 Vermont 29351.0 945.0 361.0 11.0 46 51 Virginia 32545.0 1166.0 202.0 5.0 47 53 Washington 32318.0 1120.0 113.0 4.0 48 54 West Virginia 23707.0 681.0 203.0 6.0 49 55 Wisconsin 29868.0 813.0 135.0 3.0 50 56 Wyoming 30854.0 828.0 342.0 11.0 51 72 Puerto Rico NaN 464.0 NaN 6.0 In\u00a0[7]: Copied! <pre>us_rent_income &gt;&gt; \\\n  pivot_wider(\n    names_from=f.variable,\n    names_sep=\".\",\n    values_from=c(f.estimate, f.moe)\n  )\n</pre> us_rent_income &gt;&gt; \\   pivot_wider(     names_from=f.variable,     names_sep=\".\",     values_from=c(f.estimate, f.moe)   ) Out[7]: GEOID NAME estimate.income estimate.rent moe.income moe.rent &lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 1 Alabama 24476.0 747.0 136.0 3.0 1 2 Alaska 32940.0 1200.0 508.0 13.0 2 4 Arizona 27517.0 972.0 148.0 4.0 3 5 Arkansas 23789.0 709.0 165.0 5.0 4 6 California 29454.0 1358.0 109.0 3.0 5 8 Colorado 32401.0 1125.0 109.0 5.0 6 9 Connecticut 35326.0 1123.0 195.0 5.0 7 10 Delaware 31560.0 1076.0 247.0 10.0 8 11 District of Columbia 43198.0 1424.0 681.0 17.0 9 12 Florida 25952.0 1077.0 70.0 3.0 10 13 Georgia 27024.0 927.0 106.0 3.0 11 15 Hawaii 32453.0 1507.0 218.0 18.0 12 16 Idaho 25298.0 792.0 208.0 7.0 13 17 Illinois 30684.0 952.0 83.0 3.0 14 18 Indiana 27247.0 782.0 117.0 3.0 15 19 Iowa 30002.0 740.0 143.0 4.0 16 20 Kansas 29126.0 801.0 208.0 5.0 17 21 Kentucky 24702.0 713.0 159.0 4.0 18 22 Louisiana 25086.0 825.0 155.0 4.0 19 23 Maine 26841.0 808.0 187.0 7.0 20 24 Maryland 37147.0 1311.0 152.0 5.0 21 25 Massachusetts 34498.0 1173.0 199.0 5.0 22 26 Michigan 26987.0 824.0 82.0 3.0 23 27 Minnesota 32734.0 906.0 189.0 4.0 24 28 Mississippi 22766.0 740.0 194.0 5.0 25 29 Missouri 26999.0 784.0 113.0 4.0 26 30 Montana 26249.0 751.0 206.0 9.0 27 31 Nebraska 30020.0 773.0 146.0 4.0 28 32 Nevada 29019.0 1017.0 213.0 6.0 29 33 New Hampshire 33172.0 1052.0 387.0 9.0 30 34 New Jersey 35075.0 1249.0 148.0 4.0 31 35 New Mexico 24457.0 809.0 214.0 6.0 32 36 New York 31057.0 1194.0 69.0 3.0 33 37 North Carolina 26482.0 844.0 111.0 3.0 34 38 North Dakota 32336.0 775.0 245.0 9.0 35 39 Ohio 27435.0 764.0 94.0 2.0 36 40 Oklahoma 26207.0 766.0 101.0 3.0 37 41 Oregon 27389.0 988.0 146.0 4.0 38 42 Pennsylvania 28923.0 885.0 119.0 3.0 39 44 Rhode Island 30210.0 957.0 259.0 6.0 40 45 South Carolina 25454.0 836.0 123.0 4.0 41 46 South Dakota 28821.0 696.0 276.0 7.0 42 47 Tennessee 25453.0 808.0 102.0 4.0 43 48 Texas 28063.0 952.0 110.0 2.0 44 49 Utah 27928.0 948.0 239.0 6.0 45 50 Vermont 29351.0 945.0 361.0 11.0 46 51 Virginia 32545.0 1166.0 202.0 5.0 47 53 Washington 32318.0 1120.0 113.0 4.0 48 54 West Virginia 23707.0 681.0 203.0 6.0 49 55 Wisconsin 29868.0 813.0 135.0 3.0 50 56 Wyoming 30854.0 828.0 342.0 11.0 51 72 Puerto Rico NaN 464.0 NaN 6.0 In\u00a0[8]: Copied! <pre>us_rent_income &gt;&gt; \\\n  pivot_wider(\n    names_from=f.variable,\n    names_glue=\"{variable}_{_value}\",\n    values_from=c(f.estimate, f.moe)\n  )\n</pre> us_rent_income &gt;&gt; \\   pivot_wider(     names_from=f.variable,     names_glue=\"{variable}_{_value}\",     values_from=c(f.estimate, f.moe)   ) Out[8]: GEOID NAME income_estimate rent_estimate income_moe rent_moe &lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 1 Alabama 24476.0 747.0 136.0 3.0 1 2 Alaska 32940.0 1200.0 508.0 13.0 2 4 Arizona 27517.0 972.0 148.0 4.0 3 5 Arkansas 23789.0 709.0 165.0 5.0 4 6 California 29454.0 1358.0 109.0 3.0 5 8 Colorado 32401.0 1125.0 109.0 5.0 6 9 Connecticut 35326.0 1123.0 195.0 5.0 7 10 Delaware 31560.0 1076.0 247.0 10.0 8 11 District of Columbia 43198.0 1424.0 681.0 17.0 9 12 Florida 25952.0 1077.0 70.0 3.0 10 13 Georgia 27024.0 927.0 106.0 3.0 11 15 Hawaii 32453.0 1507.0 218.0 18.0 12 16 Idaho 25298.0 792.0 208.0 7.0 13 17 Illinois 30684.0 952.0 83.0 3.0 14 18 Indiana 27247.0 782.0 117.0 3.0 15 19 Iowa 30002.0 740.0 143.0 4.0 16 20 Kansas 29126.0 801.0 208.0 5.0 17 21 Kentucky 24702.0 713.0 159.0 4.0 18 22 Louisiana 25086.0 825.0 155.0 4.0 19 23 Maine 26841.0 808.0 187.0 7.0 20 24 Maryland 37147.0 1311.0 152.0 5.0 21 25 Massachusetts 34498.0 1173.0 199.0 5.0 22 26 Michigan 26987.0 824.0 82.0 3.0 23 27 Minnesota 32734.0 906.0 189.0 4.0 24 28 Mississippi 22766.0 740.0 194.0 5.0 25 29 Missouri 26999.0 784.0 113.0 4.0 26 30 Montana 26249.0 751.0 206.0 9.0 27 31 Nebraska 30020.0 773.0 146.0 4.0 28 32 Nevada 29019.0 1017.0 213.0 6.0 29 33 New Hampshire 33172.0 1052.0 387.0 9.0 30 34 New Jersey 35075.0 1249.0 148.0 4.0 31 35 New Mexico 24457.0 809.0 214.0 6.0 32 36 New York 31057.0 1194.0 69.0 3.0 33 37 North Carolina 26482.0 844.0 111.0 3.0 34 38 North Dakota 32336.0 775.0 245.0 9.0 35 39 Ohio 27435.0 764.0 94.0 2.0 36 40 Oklahoma 26207.0 766.0 101.0 3.0 37 41 Oregon 27389.0 988.0 146.0 4.0 38 42 Pennsylvania 28923.0 885.0 119.0 3.0 39 44 Rhode Island 30210.0 957.0 259.0 6.0 40 45 South Carolina 25454.0 836.0 123.0 4.0 41 46 South Dakota 28821.0 696.0 276.0 7.0 42 47 Tennessee 25453.0 808.0 102.0 4.0 43 48 Texas 28063.0 952.0 110.0 2.0 44 49 Utah 27928.0 948.0 239.0 6.0 45 50 Vermont 29351.0 945.0 361.0 11.0 46 51 Virginia 32545.0 1166.0 202.0 5.0 47 53 Washington 32318.0 1120.0 113.0 4.0 48 54 West Virginia 23707.0 681.0 203.0 6.0 49 55 Wisconsin 29868.0 813.0 135.0 3.0 50 56 Wyoming 30854.0 828.0 342.0 11.0 51 72 Puerto Rico NaN 464.0 NaN 6.0 In\u00a0[9]: Copied! <pre>warpbreaks\n</pre> warpbreaks Out[9]: breaks wool tension &lt;int64&gt; &lt;object&gt; &lt;object&gt; 0 26 A L 1 30 A L 2 54 A L 3 25 A L 4 70 A L 5 52 A L 6 51 A L 7 26 A L 8 67 A L 9 18 A M 10 21 A M 11 29 A M 12 17 A M 13 12 A M 14 18 A M 15 35 A M 16 30 A M 17 36 A M 18 36 A H 19 21 A H 20 24 A H 21 18 A H 22 10 A H 23 43 A H 24 28 A H 25 15 A H 26 26 A H 27 27 B L 28 14 B L 29 29 B L 30 19 B L 31 29 B L 32 31 B L 33 41 B L 34 20 B L 35 44 B L 36 42 B M 37 26 B M 38 19 B M 39 16 B M 40 39 B M 41 28 B M 42 21 B M 43 39 B M 44 29 B M 45 20 B H 46 21 B H 47 24 B H 48 17 B H 49 13 B H 50 15 B H 51 15 B H 52 16 B H 53 28 B H In\u00a0[10]: Copied! <pre>warpbreaks &gt;&gt; \\\n  pivot_wider(\n    names_from=f.wool,\n    values_from=f.breaks,\n    values_fn = mean\n  )\n</pre> warpbreaks &gt;&gt; \\   pivot_wider(     names_from=f.wool,     values_from=f.breaks,     values_fn = mean   ) Out[10]: tension A B &lt;object&gt; &lt;float64&gt; &lt;float64&gt; 0 H 24.555556 18.777778 1 L 44.555556 28.222222 2 M 24.000000 28.777778 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/pivot_wider/#pivot_wider","title":"\u2605 pivot_wider\u00b6","text":""},{"location":"notebooks/pull/","title":"pull","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/pull.html\n%run nb_helpers.py\n\nfrom datar.data import starwars, mtcars\nfrom datar.all import *\n\nnb_header(pull)\n</pre> # https://dplyr.tidyverse.org/reference/pull.html %run nb_helpers.py  from datar.data import starwars, mtcars from datar.all import *  nb_header(pull) Try this notebook on binder. In\u00a0[2]: Copied! <pre>mtcars &gt;&gt; pull(-1)\n</pre> mtcars &gt;&gt; pull(-1) Out[2]: <pre>Mazda RX4              4\nMazda RX4 Wag          4\nDatsun 710             1\nHornet 4 Drive         1\nHornet Sportabout      2\nValiant                1\nDuster 360             4\nMerc 240D              2\nMerc 230               2\nMerc 280               4\nMerc 280C              4\nMerc 450SE             3\nMerc 450SL             3\nMerc 450SLC            3\nCadillac Fleetwood     4\nLincoln Continental    4\nChrysler Imperial      4\nFiat 128               1\nHonda Civic            2\nToyota Corolla         1\nToyota Corona          1\nDodge Challenger       2\nAMC Javelin            2\nCamaro Z28             4\nPontiac Firebird       2\nFiat X1-9              1\nPorsche 914-2          2\nLotus Europa           2\nFord Pantera L         4\nFerrari Dino           6\nMaserati Bora          8\nVolvo 142E             2\nName: carb, dtype: int64</pre> In\u00a0[3]: Copied! <pre>mtcars &gt;&gt; pull(-1, to='list')\n</pre> mtcars &gt;&gt; pull(-1, to='list') Out[3]: <pre>[4,\n 4,\n 1,\n 1,\n 2,\n 1,\n 4,\n 2,\n 2,\n 4,\n 4,\n 3,\n 3,\n 3,\n 4,\n 4,\n 4,\n 1,\n 2,\n 1,\n 1,\n 2,\n 2,\n 4,\n 2,\n 1,\n 2,\n 2,\n 4,\n 6,\n 8,\n 2]</pre> In\u00a0[4]: Copied! <pre>mtcars &gt;&gt; pull(1)\n</pre> mtcars &gt;&gt; pull(1) Out[4]: <pre>Mazda RX4              6\nMazda RX4 Wag          6\nDatsun 710             4\nHornet 4 Drive         6\nHornet Sportabout      8\nValiant                6\nDuster 360             8\nMerc 240D              4\nMerc 230               4\nMerc 280               6\nMerc 280C              6\nMerc 450SE             8\nMerc 450SL             8\nMerc 450SLC            8\nCadillac Fleetwood     8\nLincoln Continental    8\nChrysler Imperial      8\nFiat 128               4\nHonda Civic            4\nToyota Corolla         4\nToyota Corona          4\nDodge Challenger       8\nAMC Javelin            8\nCamaro Z28             8\nPontiac Firebird       8\nFiat X1-9              4\nPorsche 914-2          4\nLotus Europa           4\nFord Pantera L         8\nFerrari Dino           6\nMaserati Bora          8\nVolvo 142E             4\nName: cyl, dtype: int64</pre> In\u00a0[5]: Copied! <pre>mtcars &gt;&gt; pull(f.cyl)\n</pre> mtcars &gt;&gt; pull(f.cyl) Out[5]: <pre>Mazda RX4              6\nMazda RX4 Wag          6\nDatsun 710             4\nHornet 4 Drive         6\nHornet Sportabout      8\nValiant                6\nDuster 360             8\nMerc 240D              4\nMerc 230               4\nMerc 280               6\nMerc 280C              6\nMerc 450SE             8\nMerc 450SL             8\nMerc 450SLC            8\nCadillac Fleetwood     8\nLincoln Continental    8\nChrysler Imperial      8\nFiat 128               4\nHonda Civic            4\nToyota Corolla         4\nToyota Corona          4\nDodge Challenger       8\nAMC Javelin            8\nCamaro Z28             8\nPontiac Firebird       8\nFiat X1-9              4\nPorsche 914-2          4\nLotus Europa           4\nFord Pantera L         8\nFerrari Dino           6\nMaserati Bora          8\nVolvo 142E             4\nName: cyl, dtype: int64</pre> In\u00a0[6]: Copied! <pre>df = tibble(x=range(1, 11), y=range(10, 0, -1))\ndf &gt;&gt; mutate(z=f.x*f.y) &gt;&gt; pull()\n</pre> df = tibble(x=range(1, 11), y=range(10, 0, -1)) df &gt;&gt; mutate(z=f.x*f.y) &gt;&gt; pull() Out[6]: <pre>0    10\n1    18\n2    24\n3    28\n4    30\n5    30\n6    28\n7    24\n8    18\n9    10\nName: z, dtype: int64</pre> In\u00a0[8]: Copied! <pre>starwars &gt;&gt; pull(f.height, name=f.name)\n</pre> starwars &gt;&gt; pull(f.height, name=f.name) Out[8]: <pre>{'Luke Skywalker': 172.0,\n 'C-3PO': 167.0,\n 'R2-D2': 96.0,\n 'Darth Vader': 202.0,\n 'Leia Organa': 150.0,\n 'Owen Lars': 178.0,\n 'Beru Whitesun lars': 165.0,\n 'R5-D4': 97.0,\n 'Biggs Darklighter': 183.0,\n 'Obi-Wan Kenobi': 182.0,\n 'Anakin Skywalker': 188.0,\n 'Wilhuff Tarkin': 180.0,\n 'Chewbacca': 228.0,\n 'Han Solo': 180.0,\n 'Greedo': 173.0,\n 'Jabba Desilijic Tiure': 175.0,\n 'Wedge Antilles': 170.0,\n 'Jek Tono Porkins': 180.0,\n 'Yoda': 66.0,\n 'Palpatine': 170.0,\n 'Boba Fett': 183.0,\n 'IG-88': 200.0,\n 'Bossk': 190.0,\n 'Lando Calrissian': 177.0,\n 'Lobot': 175.0,\n 'Ackbar': 180.0,\n 'Mon Mothma': 150.0,\n 'Arvel Crynyd': nan,\n 'Wicket Systri Warrick': 88.0,\n 'Nien Nunb': 160.0,\n 'Qui-Gon Jinn': 193.0,\n 'Nute Gunray': 191.0,\n 'Finis Valorum': 170.0,\n 'Jar Jar Binks': 196.0,\n 'Roos Tarpals': 224.0,\n 'Rugor Nass': 206.0,\n 'Ric Oli\u00e9': 183.0,\n 'Watto': 137.0,\n 'Sebulba': 112.0,\n 'Quarsh Panaka': 183.0,\n 'Shmi Skywalker': 163.0,\n 'Darth Maul': 175.0,\n 'Bib Fortuna': 180.0,\n 'Ayla Secura': 178.0,\n 'Dud Bolt': 94.0,\n 'Gasgano': 122.0,\n 'Ben Quadinaros': 163.0,\n 'Mace Windu': 188.0,\n 'Ki-Adi-Mundi': 198.0,\n 'Kit Fisto': 196.0,\n 'Eeth Koth': 171.0,\n 'Adi Gallia': 184.0,\n 'Saesee Tiin': 188.0,\n 'Yarael Poof': 264.0,\n 'Plo Koon': 188.0,\n 'Mas Amedda': 196.0,\n 'Gregar Typho': 185.0,\n 'Cord\u00e9': 157.0,\n 'Cliegg Lars': 183.0,\n 'Poggle the Lesser': 183.0,\n 'Luminara Unduli': 170.0,\n 'Barriss Offee': 166.0,\n 'Dorm\u00e9': 165.0,\n 'Dooku': 193.0,\n 'Bail Prestor Organa': 191.0,\n 'Jango Fett': 183.0,\n 'Zam Wesell': 168.0,\n 'Dexter Jettster': 198.0,\n 'Lama Su': 229.0,\n 'Taun We': 213.0,\n 'Jocasta Nu': 167.0,\n 'Ratts Tyerell': 79.0,\n 'R4-P17': 96.0,\n 'Wat Tambor': 193.0,\n 'San Hill': 191.0,\n 'Shaak Ti': 178.0,\n 'Grievous': 216.0,\n 'Tarfful': 234.0,\n 'Raymus Antilles': 188.0,\n 'Sly Moore': 178.0,\n 'Tion Medon': 206.0,\n 'Finn': nan,\n 'Rey': nan,\n 'Poe Dameron': nan,\n 'BB8': nan,\n 'Captain Phasma': nan,\n 'Padm\u00e9 Amidala': 165.0}</pre>"},{"location":"notebooks/pull/#pull","title":"\u2605 pull\u00b6","text":""},{"location":"notebooks/pull/#pull-a-series-or-a-dataframe-from-a-dataframe","title":"Pull a series or a dataframe from a dataframe\u00b6","text":""},{"location":"notebooks/pull/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: The dataframe <code>var</code>: The column to pull, either the name or the index <code>name</code>: The name of the pulled value \u2003\u2003\u2003\u2003- If <code>to</code> is frame, or the value pulled is data frame, it will be \u2003\u2003\u2003\u2003\u2003\u2003the column names</p> <p>\u2003\u2003\u2003\u2003- If <code>to</code> is series, it will be the series name. If multiple names \u2003\u2003\u2003\u2003\u2003\u2003are given, only the first name will be used.</p> <p>\u2003\u2003\u2003\u2003- If <code>to</code> is series, but value pulled is a data frame, then a \u2003\u2003\u2003\u2003\u2003\u2003dictionary of series with the series names as keys or given <code>name</code> \u2003\u2003\u2003\u2003\u2003\u2003as keys.</p> <p> <code>to</code>: Type of data to return. \u2003\u2003\u2003\u2003Only works when pulling <code>a</code> for name <code>a$b</code></p> <p>\u2003\u2003\u2003\u2003- series: Return a pandas Series object \u2003\u2003\u2003\u2003\u2003\u2003Group information will be lost \u2003\u2003\u2003\u2003\u2003\u2003If pulled value is a dataframe, it will return a dict of series, \u2003\u2003\u2003\u2003\u2003\u2003with the series names or the <code>name</code> provided.</p> <p>\u2003\u2003\u2003\u2003- array: Return a numpy.ndarray object</p> <p>\u2003\u2003\u2003\u2003- frame: Return a DataFrame with that column</p> <p>\u2003\u2003\u2003\u2003- list: Return a python list</p> <p>\u2003\u2003\u2003\u2003- dict: Return a dict with <code>name</code> as keys and pulled value as values \u2003\u2003\u2003\u2003\u2003\u2003Only a single column is allowed to pull</p> <p>\u2003\u2003\u2003\u2003- If not provided: <code>series</code> when pulled data has only one columns. \u2003\u2003\u2003\u2003\u2003\u2003<code>dict</code> if <code>name</code> provided and has the same length as the pulled \u2003\u2003\u2003\u2003\u2003\u2003single column. Otherwise <code>frame</code>.</p>"},{"location":"notebooks/pull/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The data according to <code>to</code></p>"},{"location":"notebooks/ranking/","title":"ranking","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/ranking.html\n%run nb_helpers.py\n\nimport numpy\n\nfrom datar.data import mtcars\nfrom datar.all import *\n\nnb_header(row_number, min_rank, dense_rank, percent_rank, cume_dist, ntile)\n</pre> # https://dplyr.tidyverse.org/reference/ranking.html %run nb_helpers.py  import numpy  from datar.data import mtcars from datar.all import *  nb_header(row_number, min_rank, dense_rank, percent_rank, cume_dist, ntile) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x=c(5, 1, 3, 2, 2, numpy.nan))\ndf &gt;&gt; mutate(\n    row_number=row_number(),\n    min_rank=min_rank(f.x), \n    dense_rank=dense_rank(f.x),\n    percent_rank=percent_rank(f.x),\n    cume_dist=cume_dist(f.x),\n    ntile=ntile(f.x, n=2)\n)\n</pre> df = tibble(x=c(5, 1, 3, 2, 2, numpy.nan)) df &gt;&gt; mutate(     row_number=row_number(),     min_rank=min_rank(f.x),      dense_rank=dense_rank(f.x),     percent_rank=percent_rank(f.x),     cume_dist=cume_dist(f.x),     ntile=ntile(f.x, n=2) ) Out[2]: x row_number min_rank dense_rank percent_rank cume_dist ntile &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;category&gt; 0 5.0 1.0 5.0 4.0 1.00 1.0 2 1 1.0 2.0 1.0 1.0 0.00 0.2 1 2 3.0 3.0 4.0 3.0 0.75 0.8 1 3 2.0 4.0 2.0 2.0 0.25 0.6 1 4 2.0 5.0 2.0 2.0 0.25 0.6 1 5 NaN 6.0 NaN NaN NaN NaN NaN In\u00a0[3]: Copied! <pre>tibble(x=range(8)) &gt;&gt; mutate(ntile=ntile(f.x, n=3))\n</pre> tibble(x=range(8)) &gt;&gt; mutate(ntile=ntile(f.x, n=3)) Out[3]: x ntile &lt;int64&gt; &lt;category&gt; 0 0 1 1 1 1 2 2 1 3 3 2 4 4 2 5 5 3 6 6 3 7 7 3 In\u00a0[4]: Copied! <pre>mtcars &gt;&gt; mutate(n=row_number() == 0)\n</pre> mtcars &gt;&gt; mutate(n=row_number() == 0) Out[4]: mpg cyl disp hp drat wt qsec vs am gear carb n &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;bool&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 False Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 False Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 False Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 False Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 False Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 False Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 False Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 False Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 False Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 False Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 False Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 False Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 False Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 False Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 False Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 False Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 False Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 False Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 False Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 False Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 False Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 False AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 False Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 False Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 False Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 False Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 False Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 False Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 False Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 False Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 False Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 False In\u00a0[5]: Copied! <pre>mtcars &gt;&gt; filter(0 &lt;= row_number() &lt; 10)\n</pre> mtcars &gt;&gt; filter(0 &lt;= row_number() &lt; 10) Out[5]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2"},{"location":"notebooks/ranking/#row_number","title":"\u2605 row_number\u00b6","text":""},{"location":"notebooks/ranking/#get-the-row-number-of-x","title":"Get the row number of x\u00b6","text":"<p>Note that this function doesn't support piping.</p>"},{"location":"notebooks/ranking/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: The data to get row number \u2003\u2003\u2003\u2003Defaults to <code>Symbolic()</code> so the whole data is used by default \u2003\u2003\u2003\u2003when called <code>row_number()</code></p>"},{"location":"notebooks/ranking/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The row number</p>"},{"location":"notebooks/ranking/#min_rank","title":"\u2605 min_rank\u00b6","text":""},{"location":"notebooks/ranking/#get-the-min-rank-of-x","title":"Get the min rank of x\u00b6","text":"<p>Note that this function doesn't support piping.</p>"},{"location":"notebooks/ranking/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: The data to get row number \u2003\u2003\u2003\u2003Defaults to <code>Symbolic()</code> so the whole data is used by default \u2003\u2003\u2003\u2003when called <code>min_rank()</code></p> <p> <code>na_last</code>: How NA values are ranked \u2003\u2003\u2003\u2003- \"keep\": NA values are ranked at the end</p> <p>\u2003\u2003\u2003\u2003- \"top\": NA values are ranked at the top</p> <p>\u2003\u2003\u2003\u2003- \"bottom\": NA values are ranked at the bottom</p>"},{"location":"notebooks/ranking/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The row number</p>"},{"location":"notebooks/ranking/#dense_rank","title":"\u2605 dense_rank\u00b6","text":""},{"location":"notebooks/ranking/#get-the-dense-rank-of-x","title":"Get the dense rank of x\u00b6","text":"<p>Note that this function doesn't support piping.</p>"},{"location":"notebooks/ranking/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: The data to get row number \u2003\u2003\u2003\u2003Defaults to <code>Symbolic()</code> so the whole data is used by default \u2003\u2003\u2003\u2003when called <code>dense_rank()</code></p> <p> <code>na_last</code>: How NA values are ranked \u2003\u2003\u2003\u2003- \"keep\": NA values are ranked at the end</p> <p>\u2003\u2003\u2003\u2003- \"top\": NA values are ranked at the top</p> <p>\u2003\u2003\u2003\u2003- \"bottom\": NA values are ranked at the bottom</p>"},{"location":"notebooks/ranking/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The row number</p>"},{"location":"notebooks/ranking/#percent_rank","title":"\u2605 percent_rank\u00b6","text":""},{"location":"notebooks/ranking/#get-the-percent-rank-of-x","title":"Get the percent rank of x\u00b6","text":"<p>Note that this function doesn't support piping.</p>"},{"location":"notebooks/ranking/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: The data to get row number \u2003\u2003\u2003\u2003Defaults to <code>Symbolic()</code> so the whole data is used by default \u2003\u2003\u2003\u2003when called <code>percent_rank()</code></p> <p> <code>na_last</code>: How NA values are ranked \u2003\u2003\u2003\u2003- \"keep\": NA values are ranked at the end</p> <p>\u2003\u2003\u2003\u2003- \"top\": NA values are ranked at the top</p> <p>\u2003\u2003\u2003\u2003- \"bottom\": NA values are ranked at the bottom</p>"},{"location":"notebooks/ranking/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The row number</p>"},{"location":"notebooks/ranking/#cume_dist","title":"\u2605 cume_dist\u00b6","text":""},{"location":"notebooks/ranking/#get-the-cume_dist-of-x","title":"Get the cume_dist of x\u00b6","text":"<p>Note that this function doesn't support piping.</p>"},{"location":"notebooks/ranking/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: The data to get row number \u2003\u2003\u2003\u2003Defaults to <code>Symbolic()</code> so the whole data is used by default \u2003\u2003\u2003\u2003when called <code>cume_dist()</code></p> <p> <code>na_last</code>: How NA values are ranked \u2003\u2003\u2003\u2003- \"keep\": NA values are ranked at the end</p> <p>\u2003\u2003\u2003\u2003- \"top\": NA values are ranked at the top</p> <p>\u2003\u2003\u2003\u2003- \"bottom\": NA values are ranked at the bottom</p>"},{"location":"notebooks/ranking/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The row number</p>"},{"location":"notebooks/ranking/#ntile","title":"\u2605 ntile\u00b6","text":""},{"location":"notebooks/ranking/#a-rough-rank-which-breaks-the-input-vector-into-n-buckets","title":"a rough rank, which breaks the input vector into n buckets.\u00b6","text":"<p>The size of the buckets may differ by up to one, larger buckets have lower rank.</p> <p>Note that this function doesn't support piping.</p>"},{"location":"notebooks/ranking/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: The data to get  rownumber \u2003\u2003\u2003\u2003Defaults to <code>Symbolic()</code> so the whole data is used by default \u2003\u2003\u2003\u2003when called <code>ntile(n=...)</code></p> <p> <code>n</code>: The number of groups to divide the data into</p>"},{"location":"notebooks/ranking/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The row number</p>"},{"location":"notebooks/readme/","title":"readme","text":"In\u00a0[1]: Copied! <pre>from datar import f\nfrom datar.dplyr import mutate, filter, if_else\nfrom datar.tibble import tibble\n# or\n# from datar.all import f, mutate, filter, if_else, tibble\n</pre> from datar import f from datar.dplyr import mutate, filter, if_else from datar.tibble import tibble # or # from datar.all import f, mutate, filter, if_else, tibble <pre>[2022-12-02 14:18:09][datar][WARNING] Builtin name \"filter\" has been masked by datar.\n</pre> In\u00a0[2]: Copied! <pre>df = tibble(\n    x=range(4),\n    y=['zero', 'one', 'two', 'three']\n)\nprint(df &gt;&gt; mutate(z=f.x))\n</pre> df = tibble(     x=range(4),     y=['zero', 'one', 'two', 'three'] ) print(df &gt;&gt; mutate(z=f.x)) <pre>        x        y       z\n  &lt;int64&gt; &lt;object&gt; &lt;int64&gt;\n0       0     zero       0\n1       1      one       1\n2       2      two       2\n3       3    three       3\n</pre> In\u00a0[3]: Copied! <pre>print(df &gt;&gt; mutate(z=if_else(f.x&gt;1, 1, 0)))\n</pre> print(df &gt;&gt; mutate(z=if_else(f.x&gt;1, 1, 0))) <pre>        x        y         z\n  &lt;int64&gt; &lt;object&gt; &lt;float64&gt;\n0       0     zero       0.0\n1       1      one       0.0\n2       2      two       1.0\n3       3    three       1.0\n</pre> In\u00a0[4]: Copied! <pre>print(df &gt;&gt; filter(f.x&gt;1))\n</pre> print(df &gt;&gt; filter(f.x&gt;1)) <pre>        x        y\n  &lt;int64&gt; &lt;object&gt;\n2       2      two\n3       3    three\n</pre> In\u00a0[5]: Copied! <pre>print(df &gt;&gt; mutate(z=if_else(f.x&gt;1, 1, 0)) &gt;&gt; filter(f.z==1))\n</pre> print(df &gt;&gt; mutate(z=if_else(f.x&gt;1, 1, 0)) &gt;&gt; filter(f.z==1)) <pre>        x        y         z\n  &lt;int64&gt; &lt;object&gt; &lt;float64&gt;\n2       2      two       1.0\n3       3    three       1.0\n</pre> In\u00a0[8]: Copied! <pre># works with plotnine\nimport numpy\nfrom datar.base import sin, pi\nfrom datar.tibble import tibble\nfrom datar.dplyr import mutate, if_else\nfrom plotnine import ggplot, aes, geom_line, theme_classic\n\ndf = tibble(x=numpy.linspace(0, 2 * pi, 500))\n(\n    df\n    &gt;&gt; mutate(y=sin(f.x), sign=if_else(f.y &gt;= 0, \"positive\", \"negative\"))\n    &gt;&gt; ggplot(aes(x=\"x\", y=\"y\"))\n    + theme_classic()\n    + geom_line(aes(color=\"sign\"), size=1.2)\n)\n</pre> # works with plotnine import numpy from datar.base import sin, pi from datar.tibble import tibble from datar.dplyr import mutate, if_else from plotnine import ggplot, aes, geom_line, theme_classic  df = tibble(x=numpy.linspace(0, 2 * pi, 500)) (     df     &gt;&gt; mutate(y=sin(f.x), sign=if_else(f.y &gt;= 0, \"positive\", \"negative\"))     &gt;&gt; ggplot(aes(x=\"x\", y=\"y\"))     + theme_classic()     + geom_line(aes(color=\"sign\"), size=1.2) ) Out[8]: <pre>&lt;ggplot: (8749008935172)&gt;</pre> In\u00a0[9]: Copied! <pre># very easy to integrate with other libraries\n# for example: klib\nimport klib\nfrom pipda import register_verb\nfrom datar import f\nfrom datar.data import iris\nfrom datar.dplyr import pull\n\ndist_plot = register_verb(func=klib.dist_plot)\niris &gt;&gt; pull(f.Sepal_Length) &gt;&gt; dist_plot()\n</pre> # very easy to integrate with other libraries # for example: klib import klib from pipda import register_verb from datar import f from datar.data import iris from datar.dplyr import pull  dist_plot = register_verb(func=klib.dist_plot) iris &gt;&gt; pull(f.Sepal_Length) &gt;&gt; dist_plot() Out[9]: <pre>&lt;AxesSubplot:xlabel='Sepal_Length', ylabel='Density'&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/recode/","title":"recode","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/recode.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(recode)\n</pre> # https://dplyr.tidyverse.org/reference/recode.html %run nb_helpers.py  from datar.all import *  nb_header(recode) Try this notebook on binder. In\u00a0[2]: Copied! <pre>char_vec = sample(c(\"a\", \"b\", \"c\"), 10, replace=True)\nrecode(char_vec, a=\"Apple\")\n</pre> char_vec = sample(c(\"a\", \"b\", \"c\"), 10, replace=True) recode(char_vec, a=\"Apple\") Out[2]: <pre>0    Apple\n1        c\n2        c\n3    Apple\n4        b\n5    Apple\n6        b\n7        b\n8        b\n9        c\ndtype: object</pre> In\u00a0[3]: Copied! <pre>recode(char_vec, a=\"Apple\", b=\"Banana\")\n</pre> recode(char_vec, a=\"Apple\", b=\"Banana\") Out[3]: <pre>0     Apple\n1         c\n2         c\n3     Apple\n4    Banana\n5     Apple\n6    Banana\n7    Banana\n8    Banana\n9         c\ndtype: object</pre> In\u00a0[4]: Copied! <pre>recode(char_vec, a=\"Apple\", b=\"Banana\", _default = NA)\n</pre> recode(char_vec, a=\"Apple\", b=\"Banana\", _default = NA) Out[4]: <pre>0     Apple\n1       NaN\n2       NaN\n3     Apple\n4    Banana\n5     Apple\n6    Banana\n7    Banana\n8    Banana\n9       NaN\ndtype: object</pre> In\u00a0[5]: Copied! <pre>level_key = dict(a=\"apple\", b=\"banana\", c=\"carrot\")\nrecode(char_vec, **level_key)\n</pre> level_key = dict(a=\"apple\", b=\"banana\", c=\"carrot\") recode(char_vec, **level_key) Out[5]: <pre>0     apple\n1    carrot\n2    carrot\n3     apple\n4    banana\n5     apple\n6    banana\n7    banana\n8    banana\n9    carrot\ndtype: object</pre> In\u00a0[6]: Copied! <pre>num_vec = c(range(4), NA)\nrecode(num_vec, {1: 20, 3: 40})\n</pre> num_vec = c(range(4), NA) recode(num_vec, {1: 20, 3: 40}) <pre>[2022-12-02 14:19:25][datar][WARNING] Unreplaced values treated as NA as `_x` is not compatible. Please specify replacements exhaustively or supply `_default`\n</pre> Out[6]: <pre>0    NaN\n1     20\n2    NaN\n3     40\n4    NaN\ndtype: object</pre> In\u00a0[7]: Copied! <pre>recode(num_vec, \"a\", \"b\", \"c\", \"d\")\n</pre> recode(num_vec, \"a\", \"b\", \"c\", \"d\") Out[7]: <pre>0      a\n1      b\n2      c\n3      d\n4    NaN\ndtype: object</pre> In\u00a0[8]: Copied! <pre>recode(c(0,4,2), \"a\", \"b\", \"c\", \"d\", _default=\"nothing\")\n</pre> recode(c(0,4,2), \"a\", \"b\", \"c\", \"d\", _default=\"nothing\") Out[8]: <pre>0          a\n1    nothing\n2          c\ndtype: object</pre> In\u00a0[9]: Copied! <pre>recode(num_vec, {1: \"b\", 3: \"d\"})\n</pre> recode(num_vec, {1: \"b\", 3: \"d\"}) <pre>[2022-12-02 14:19:31][datar][WARNING] Unreplaced values treated as NA as `_x` is not compatible. Please specify replacements exhaustively or supply `_default`\n</pre> Out[9]: <pre>0    NaN\n1      b\n2    NaN\n3      d\n4    NaN\ndtype: object</pre> In\u00a0[10]: Copied! <pre>recode(num_vec, \"a\", \"b\", \"c\", _default=\"other\")\n</pre> recode(num_vec, \"a\", \"b\", \"c\", _default=\"other\") Out[10]: <pre>0        a\n1        b\n2        c\n3    other\n4      NaN\ndtype: object</pre> In\u00a0[11]: Copied! <pre>recode(num_vec, \"a\", \"b\", \"c\", _default=\"other\", _missing=\"missing\")\n</pre> recode(num_vec, \"a\", \"b\", \"c\", _default=\"other\", _missing=\"missing\") Out[11]: <pre>0          a\n1          b\n2          c\n3      other\n4    missing\ndtype: object</pre> In\u00a0[12]: Copied! <pre>factor_vec = factor(c(\"a\", \"b\", \"c\"))\nfactor_vec\n</pre> factor_vec = factor(c(\"a\", \"b\", \"c\")) factor_vec Out[12]: <pre>['a', 'b', 'c']\nCategories (3, object): ['a', 'b', 'c']</pre> In\u00a0[13]: Copied! <pre># categories lost\nrecode(factor_vec, a=\"Apple\")\n</pre> # categories lost recode(factor_vec, a=\"Apple\") Out[13]: <pre>0    Apple\n1        b\n2        c\ndtype: category\nCategories (3, object): ['Apple', 'b', 'c']</pre> In\u00a0[14]: Copied! <pre>recode_factor(factor_vec, a=\"Apple\")\n</pre> recode_factor(factor_vec, a=\"Apple\") Out[14]: <pre>0    Apple\n1        b\n2        c\ndtype: category\nCategories (3, object): ['Apple', 'b', 'c']</pre> In\u00a0[15]: Copied! <pre>recode_factor(num_vec, {0: \"z\", 1: \"y\", 2: \"x\"})\n</pre> recode_factor(num_vec, {0: \"z\", 1: \"y\", 2: \"x\"}) <pre>[2022-12-02 14:19:42][datar][WARNING] Unreplaced values treated as NA as `_x` is not compatible. Please specify replacements exhaustively or supply `_default`\n</pre> Out[15]: <pre>0      z\n1      y\n2      x\n3    NaN\n4    NaN\ndtype: category\nCategories (3, object): ['z', 'y', 'x']</pre> In\u00a0[16]: Copied! <pre>recode_factor(num_vec, {0: \"z\", 1: \"y\", 2: \"x\"}, _default=\"D\")\n</pre> recode_factor(num_vec, {0: \"z\", 1: \"y\", 2: \"x\"}, _default=\"D\") Out[16]: <pre>0      z\n1      y\n2      x\n3      D\n4    NaN\ndtype: category\nCategories (4, object): ['z', 'y', 'x', 'D']</pre> In\u00a0[17]: Copied! <pre>recode_factor(num_vec, {0: \"z\", 1: \"y\", 2: \"x\"}, _default=\"D\", _missing=\"M\")\n</pre> recode_factor(num_vec, {0: \"z\", 1: \"y\", 2: \"x\"}, _default=\"D\", _missing=\"M\") Out[17]: <pre>0    z\n1    y\n2    x\n3    D\n4    M\ndtype: category\nCategories (5, object): ['z', 'y', 'x', 'D', 'M']</pre> In\u00a0[18]: Copied! <pre>recode_factor(list(letters[:3]), b=\"z\", c=\"y\")\n</pre> recode_factor(list(letters[:3]), b=\"z\", c=\"y\") Out[18]: <pre>0    a\n1    z\n2    y\ndtype: category\nCategories (3, object): ['z', 'y', 'a']</pre> In\u00a0[19]: Copied! <pre>level_key = dict(a=\"apple\", b=\"banana\", c=\"carrot\")\nrecode_factor(char_vec, **level_key)\n</pre> level_key = dict(a=\"apple\", b=\"banana\", c=\"carrot\") recode_factor(char_vec, **level_key) Out[19]: <pre>0     apple\n1    carrot\n2    carrot\n3     apple\n4    banana\n5     apple\n6    banana\n7    banana\n8    banana\n9    carrot\ndtype: category\nCategories (3, object): ['apple', 'banana', 'carrot']</pre>"},{"location":"notebooks/recode/#recode","title":"\u2605 recode\u00b6","text":""},{"location":"notebooks/recode/#recode-a-vector-replacing-elements-in-it","title":"Recode a vector, replacing elements in it\u00b6","text":""},{"location":"notebooks/recode/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A vector to modify <code>*args</code>: and <code>**kwargs</code>: replacements <code>_default</code>: If supplied, all values not otherwise matched will be \u2003\u2003\u2003\u2003given this value. If not supplied and if the replacements are \u2003\u2003\u2003\u2003the same type as the original values in series, unmatched values \u2003\u2003\u2003\u2003are not changed. If not supplied and if the replacements are \u2003\u2003\u2003\u2003not compatible, unmatched values are replaced with np.nan.</p> <p> <code>_missing</code>: If supplied, any missing values in .x will be replaced \u2003\u2003\u2003\u2003by this value.</p>"},{"location":"notebooks/recode/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The vector with values replaced</p>"},{"location":"notebooks/relocate/","title":"relocate","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/relocate.html\n%run nb_helpers.py\nfrom datar.all import *\n\nnb_header(relocate)\n</pre> # https://dplyr.tidyverse.org/reference/relocate.html %run nb_helpers.py from datar.all import *  nb_header(relocate) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(a=1, b=1, c=1, d='a', e='a', f='a')\ndf\n</pre> df = tibble(a=1, b=1, c=1, d='a', e='a', f='a') df Out[2]: a b c d e f &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 1 1 1 a a a In\u00a0[3]: Copied! <pre>df &gt;&gt; relocate(f.f)\n</pre> df &gt;&gt; relocate(f.f) Out[3]: f a b c d e &lt;object&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;object&gt; 0 a 1 1 1 a a In\u00a0[4]: Copied! <pre>df &gt;&gt; relocate(f.a, _after = f.c)\n</pre> df &gt;&gt; relocate(f.a, _after = f.c) Out[4]: b c a d e f &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 1 1 1 a a a In\u00a0[5]: Copied! <pre>df &gt;&gt; relocate(f.f, _before = f.b)\n</pre> df &gt;&gt; relocate(f.f, _before = f.b) Out[5]: a f b c d e &lt;int64&gt; &lt;object&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;object&gt; 0 1 a 1 1 a a In\u00a0[6]: Copied! <pre>df &gt;&gt; relocate(f.a, _after = last_col())\n</pre> df &gt;&gt; relocate(f.a, _after = last_col()) Out[6]: b c d e f a &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;int64&gt; 0 1 1 a a a 1 In\u00a0[7]: Copied! <pre>df &gt;&gt; relocate(ff=f.f)\n</pre> df &gt;&gt; relocate(ff=f.f) Out[7]: ff a b c d e &lt;object&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;object&gt; 0 a 1 1 1 a a In\u00a0[8]: Copied! <pre>df &gt;&gt; relocate(where(is_character))\n</pre> df &gt;&gt; relocate(where(is_character)) Out[8]: d e f a b c &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 a a a 1 1 1 In\u00a0[9]: Copied! <pre>df &gt;&gt; relocate(where(is_numeric), _after = last_col())\n</pre> df &gt;&gt; relocate(where(is_numeric), _after = last_col()) Out[9]: d e f a b c &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 a a a 1 1 1 In\u00a0[10]: Copied! <pre>df &gt;&gt; relocate(any_of(c(\"a\", \"e\", \"i\", \"o\", \"u\")))\n</pre> df &gt;&gt; relocate(any_of(c(\"a\", \"e\", \"i\", \"o\", \"u\"))) Out[10]: a e b c d f &lt;int64&gt; &lt;object&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;object&gt; 0 1 a 1 1 a a In\u00a0[11]: Copied! <pre>df2 = tibble(a=1, b='a', c=1, d='a')\ndf2\n</pre> df2 = tibble(a=1, b='a', c=1, d='a') df2 Out[11]: a b c d &lt;int64&gt; &lt;object&gt; &lt;int64&gt; &lt;object&gt; 0 1 a 1 a In\u00a0[12]: Copied! <pre>df2 &gt;&gt; relocate(where(is_numeric), _after = where(is_character))\n</pre> df2 &gt;&gt; relocate(where(is_numeric), _after = where(is_character)) Out[12]: b d a c &lt;object&gt; &lt;object&gt; &lt;int64&gt; &lt;int64&gt; 0 a a 1 1 In\u00a0[13]: Copied! <pre>df2 &gt;&gt; relocate(where(is_numeric), _before = where(is_character))\n</pre> df2 &gt;&gt; relocate(where(is_numeric), _before = where(is_character)) Out[13]: a c b d &lt;int64&gt; &lt;int64&gt; &lt;object&gt; &lt;object&gt; 0 1 1 a a In\u00a0[14]: Copied! <pre>df2 &gt;&gt; relocate(f.d, _after=1)\n</pre> df2 &gt;&gt; relocate(f.d, _after=1) Out[14]: a b d c &lt;int64&gt; &lt;object&gt; &lt;object&gt; &lt;int64&gt; 0 1 a a 1"},{"location":"notebooks/relocate/#relocate","title":"\u2605 relocate\u00b6","text":""},{"location":"notebooks/relocate/#change-column-positions","title":"change column positions\u00b6","text":"<p>See original API https://dplyr.tidyverse.org/reference/relocate.html</p>"},{"location":"notebooks/relocate/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>*args</code>: and <code>**kwargs</code>: Columns to rename and move <code>_before</code>: and <code>_after</code>: Destination. Supplying neither will move columns to \u2003\u2003\u2003\u2003the left-hand side; specifying both is an error.</p>"},{"location":"notebooks/relocate/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003An object of the same type as .data. The output has the following \u2003\u2003properties: \u2003\u2003- Rows are not affected. \u2003\u2003- The same columns appear in the output, but (usually) in a \u2003\u2003\u2003\u2003different place.</p> <p>\u2003\u2003- Data frame attributes are preserved. \u2003\u2003- Groups are not affected</p>"},{"location":"notebooks/rename/","title":"rename","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/rename.html\n%run nb_helpers.py\n\nfrom datar.data import iris\nfrom datar.all import *\n\nnb_header(rename, rename_with)\n</pre> # https://dplyr.tidyverse.org/reference/rename.html %run nb_helpers.py  from datar.data import iris from datar.all import *  nb_header(rename, rename_with) Try this notebook on binder. In\u00a0[2]: Copied! <pre>rename(iris, petal_length='Petal_Length')\n</pre> rename(iris, petal_length='Petal_Length') Out[2]: Sepal_Length Sepal_Width petal_length Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.1 3.5 1.4 0.2 setosa 1 4.9 3.0 1.4 0.2 setosa 2 4.7 3.2 1.3 0.2 setosa 3 4.6 3.1 1.5 0.2 setosa ... ... ... ... ... ... 4 5.0 3.6 1.4 0.2 setosa 145 6.7 3.0 5.2 2.3 virginica 146 6.3 2.5 5.0 1.9 virginica 147 6.5 3.0 5.2 2.0 virginica 148 6.2 3.4 5.4 2.3 virginica 149 5.9 3.0 5.1 1.8 virginica <p>150 rows \u00d7 5 columns</p> In\u00a0[3]: Copied! <pre>rename_with(iris, str.upper)\n</pre> rename_with(iris, str.upper) Out[3]: SEPAL_LENGTH SEPAL_WIDTH PETAL_LENGTH PETAL_WIDTH SPECIES &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.1 3.5 1.4 0.2 setosa 1 4.9 3.0 1.4 0.2 setosa 2 4.7 3.2 1.3 0.2 setosa 3 4.6 3.1 1.5 0.2 setosa ... ... ... ... ... ... 4 5.0 3.6 1.4 0.2 setosa 145 6.7 3.0 5.2 2.3 virginica 146 6.3 2.5 5.0 1.9 virginica 147 6.5 3.0 5.2 2.0 virginica 148 6.2 3.4 5.4 2.3 virginica 149 5.9 3.0 5.1 1.8 virginica <p>150 rows \u00d7 5 columns</p> In\u00a0[4]: Copied! <pre>iris &gt;&gt; rename_with(str.upper, starts_with(\"Petal\"))\n</pre> iris &gt;&gt; rename_with(str.upper, starts_with(\"Petal\")) Out[4]: Sepal_Length Sepal_Width PETAL_LENGTH PETAL_WIDTH Species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.1 3.5 1.4 0.2 setosa 1 4.9 3.0 1.4 0.2 setosa 2 4.7 3.2 1.3 0.2 setosa 3 4.6 3.1 1.5 0.2 setosa ... ... ... ... ... ... 4 5.0 3.6 1.4 0.2 setosa 145 6.7 3.0 5.2 2.3 virginica 146 6.3 2.5 5.0 1.9 virginica 147 6.5 3.0 5.2 2.0 virginica 148 6.2 3.4 5.4 2.3 virginica 149 5.9 3.0 5.1 1.8 virginica <p>150 rows \u00d7 5 columns</p> In\u00a0[5]: Copied! <pre>iris &gt;&gt; rename_with(lambda x: x.replace('_', '.').lower())\n</pre> iris &gt;&gt; rename_with(lambda x: x.replace('_', '.').lower()) Out[5]: sepal.length sepal.width petal.length petal.width species &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.1 3.5 1.4 0.2 setosa 1 4.9 3.0 1.4 0.2 setosa 2 4.7 3.2 1.3 0.2 setosa 3 4.6 3.1 1.5 0.2 setosa ... ... ... ... ... ... 4 5.0 3.6 1.4 0.2 setosa 145 6.7 3.0 5.2 2.3 virginica 146 6.3 2.5 5.0 1.9 virginica 147 6.5 3.0 5.2 2.0 virginica 148 6.2 3.4 5.4 2.3 virginica 149 5.9 3.0 5.1 1.8 virginica <p>150 rows \u00d7 5 columns</p> In\u00a0[6]: Copied! <pre># names can be selected by indexes\niris &gt;&gt; rename(Sp=4)\n</pre> # names can be selected by indexes iris &gt;&gt; rename(Sp=4) Out[6]: Sepal_Length Sepal_Width Petal_Length Petal_Width Sp &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.1 3.5 1.4 0.2 setosa 1 4.9 3.0 1.4 0.2 setosa 2 4.7 3.2 1.3 0.2 setosa 3 4.6 3.1 1.5 0.2 setosa ... ... ... ... ... ... 4 5.0 3.6 1.4 0.2 setosa 145 6.7 3.0 5.2 2.3 virginica 146 6.3 2.5 5.0 1.9 virginica 147 6.5 3.0 5.2 2.0 virginica 148 6.2 3.4 5.4 2.3 virginica 149 5.9 3.0 5.1 1.8 virginica <p>150 rows \u00d7 5 columns</p>"},{"location":"notebooks/rename/#rename","title":"\u2605 rename\u00b6","text":""},{"location":"notebooks/rename/#rename-columns","title":"Rename columns\u00b6","text":"<p>See original API https://dplyr.tidyverse.org/reference/rename.html</p>"},{"location":"notebooks/rename/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>**kwargs</code>: Columns to rename</p>"},{"location":"notebooks/rename/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The dataframe with new names</p>"},{"location":"notebooks/rename/#rename_with","title":"\u2605 rename_with\u00b6","text":""},{"location":"notebooks/rename/#rename-columns-with-a-function","title":"Rename columns with a function\u00b6","text":"<p>See original API https://dplyr.tidyverse.org/reference/rename.html</p>"},{"location":"notebooks/rename/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>_fn</code>: A function to apply to column names <code>*args</code>: the columns to rename and non-keyword arguments for the <code>_fn</code>. \u2003\u2003\u2003\u2003If <code>*args</code> is not provided, then assuming all columns, and \u2003\u2003\u2003\u2003no non-keyword arguments are allowed to pass to the function, use \u2003\u2003\u2003\u2003keyword arguments instead.</p> <p> <code>**kwargs</code>: keyword arguments for <code>_fn</code></p>"},{"location":"notebooks/rename/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The dataframe with new names</p>"},{"location":"notebooks/replace_na/","title":"replace_na","text":"In\u00a0[1]: Copied! <pre># https://tidyr.tidyverse.org/reference/replace_na.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(replace_na)\n</pre> # https://tidyr.tidyverse.org/reference/replace_na.html %run nb_helpers.py  from datar.all import *  nb_header(replace_na) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x = c(1, 2, NA), y = c(\"a\", NA, \"b\"))\ndf &gt;&gt; replace_na(dict(x = 0, y = \"unknown\"))\n</pre> df = tibble(x = c(1, 2, NA), y = c(\"a\", NA, \"b\")) df &gt;&gt; replace_na(dict(x = 0, y = \"unknown\")) Out[2]: x y &lt;float64&gt; &lt;object&gt; 0 1.0 a 1 2.0 unknown 2 0.0 b In\u00a0[3]: Copied! <pre>df &gt;&gt; mutate(x = replace_na(f.x, 0))\n</pre> df &gt;&gt; mutate(x = replace_na(f.x, 0)) Out[3]: x y &lt;float64&gt; &lt;object&gt; 0 1.0 a 1 2.0 NaN 2 0.0 b In\u00a0[4]: Copied! <pre>df.x &gt;&gt; replace_na(0)\n</pre> df.x &gt;&gt; replace_na(0) Out[4]: <pre>0    1.0\n1    2.0\n2    0.0\nName: x, dtype: float64</pre> In\u00a0[5]: Copied! <pre>df.y &gt;&gt; replace_na(\"unknown\")\n</pre> df.y &gt;&gt; replace_na(\"unknown\") Out[5]: <pre>0          a\n1    unknown\n2          b\nName: y, dtype: object</pre> In\u00a0[6]: Copied! <pre>df_list = tibble(z = [seq(1,5), NULL, seq(10,20)])\ndf_list &gt;&gt; replace_na({'z': 5}) # replace with a list not supported yet\n</pre> df_list = tibble(z = [seq(1,5), NULL, seq(10,20)]) df_list &gt;&gt; replace_na({'z': 5}) # replace with a list not supported yet Out[6]: z &lt;object&gt; 0 [1, 2, 3, 4, 5] 1 5 2 [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]"},{"location":"notebooks/replace_na/#replace_na","title":"\u2605 replace_na\u00b6","text":""},{"location":"notebooks/replace_na/#replace-na-with-a-value","title":"Replace NA with a value\u00b6","text":"<p>This function can be also used not as a verb. As a function called as an argument in a verb, data is passed implicitly. Then one could pass data_or_replace as the data to replace.</p>"},{"location":"notebooks/replace_na/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: The data piped in <code>data_or_replace</code>: When called as argument of a verb, this is the \u2003\u2003\u2003\u2003data to replace. Otherwise this is the replacement.</p> <p> <code>replace</code>: The value to replace with \u2003\u2003\u2003\u2003Can only be a scalar or dict for data frame. \u2003\u2003\u2003\u2003So replace NA with a list is not supported yet.</p>"},{"location":"notebooks/replace_na/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003Corresponding data with NAs replaced</p>"},{"location":"notebooks/rownames/","title":"rownames","text":"In\u00a0[1]: Copied! <pre># https://tibble.tidyverse.org/reference/add_row.html\n%run nb_helpers.py\n\nfrom datar.tibble import *\nfrom datar.base import head\nfrom datar.data import mtcars, iris\n\nnb_header(has_rownames, remove_rownames, rownames_to_column, rowid_to_column, column_to_rownames, book='rownames')\n</pre> # https://tibble.tidyverse.org/reference/add_row.html %run nb_helpers.py  from datar.tibble import * from datar.base import head from datar.data import mtcars, iris  nb_header(has_rownames, remove_rownames, rownames_to_column, rowid_to_column, column_to_rownames, book='rownames') Try this notebook on binder. In\u00a0[2]: Copied! <pre>has_rownames(mtcars)\n</pre> has_rownames(mtcars) Out[2]: <pre>True</pre> In\u00a0[3]: Copied! <pre>has_rownames(iris)\n</pre> has_rownames(iris) Out[3]: <pre>False</pre> In\u00a0[4]: Copied! <pre>remove_rownames(mtcars) &gt;&gt; has_rownames()\n</pre> remove_rownames(mtcars) &gt;&gt; has_rownames() Out[4]: <pre>False</pre> In\u00a0[5]: Copied! <pre>mtcars_tbl = rownames_to_column(mtcars, var=\"car\") \nmtcars_tbl\n</pre> mtcars_tbl = rownames_to_column(mtcars, var=\"car\")  mtcars_tbl Out[5]: mpg car cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;object&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 21.0 Mazda RX4 6 160.0 110 3.90 2.620 16.46 0 1 4 4 1 21.0 Mazda RX4 Wag 6 160.0 110 3.90 2.875 17.02 0 1 4 4 2 22.8 Datsun 710 4 108.0 93 3.85 2.320 18.61 1 1 4 1 3 21.4 Hornet 4 Drive 6 258.0 110 3.08 3.215 19.44 1 0 3 1 4 18.7 Hornet Sportabout 8 360.0 175 3.15 3.440 17.02 0 0 3 2 5 18.1 Valiant 6 225.0 105 2.76 3.460 20.22 1 0 3 1 6 14.3 Duster 360 8 360.0 245 3.21 3.570 15.84 0 0 3 4 7 24.4 Merc 240D 4 146.7 62 3.69 3.190 20.00 1 0 4 2 8 22.8 Merc 230 4 140.8 95 3.92 3.150 22.90 1 0 4 2 9 19.2 Merc 280 6 167.6 123 3.92 3.440 18.30 1 0 4 4 10 17.8 Merc 280C 6 167.6 123 3.92 3.440 18.90 1 0 4 4 11 16.4 Merc 450SE 8 275.8 180 3.07 4.070 17.40 0 0 3 3 12 17.3 Merc 450SL 8 275.8 180 3.07 3.730 17.60 0 0 3 3 13 15.2 Merc 450SLC 8 275.8 180 3.07 3.780 18.00 0 0 3 3 14 10.4 Cadillac Fleetwood 8 472.0 205 2.93 5.250 17.98 0 0 3 4 15 10.4 Lincoln Continental 8 460.0 215 3.00 5.424 17.82 0 0 3 4 16 14.7 Chrysler Imperial 8 440.0 230 3.23 5.345 17.42 0 0 3 4 17 32.4 Fiat 128 4 78.7 66 4.08 2.200 19.47 1 1 4 1 18 30.4 Honda Civic 4 75.7 52 4.93 1.615 18.52 1 1 4 2 19 33.9 Toyota Corolla 4 71.1 65 4.22 1.835 19.90 1 1 4 1 20 21.5 Toyota Corona 4 120.1 97 3.70 2.465 20.01 1 0 3 1 21 15.5 Dodge Challenger 8 318.0 150 2.76 3.520 16.87 0 0 3 2 22 15.2 AMC Javelin 8 304.0 150 3.15 3.435 17.30 0 0 3 2 23 13.3 Camaro Z28 8 350.0 245 3.73 3.840 15.41 0 0 3 4 24 19.2 Pontiac Firebird 8 400.0 175 3.08 3.845 17.05 0 0 3 2 25 27.3 Fiat X1-9 4 79.0 66 4.08 1.935 18.90 1 1 4 1 26 26.0 Porsche 914-2 4 120.3 91 4.43 2.140 16.70 0 1 5 2 27 30.4 Lotus Europa 4 95.1 113 3.77 1.513 16.90 1 1 5 2 28 15.8 Ford Pantera L 8 351.0 264 4.22 3.170 14.50 0 1 5 4 29 19.7 Ferrari Dino 6 145.0 175 3.62 2.770 15.50 0 1 5 6 30 15.0 Maserati Bora 8 301.0 335 3.54 3.570 14.60 0 1 5 8 31 21.4 Volvo 142E 4 121.0 109 4.11 2.780 18.60 1 1 4 2 In\u00a0[6]: Copied! <pre>column_to_rownames(mtcars_tbl, var = \"car\") &gt;&gt; head()\n</pre> column_to_rownames(mtcars_tbl, var = \"car\") &gt;&gt; head() Out[6]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 In\u00a0[7]: Copied! <pre># Adding rowid as a column --------------------------------------------\nrowid_to_column(iris) &gt;&gt; head()\n</pre> # Adding rowid as a column -------------------------------------------- rowid_to_column(iris) &gt;&gt; head() Out[7]: Sepal_Length rowid Sepal_Width Petal_Length Petal_Width Species &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.1 0 3.5 1.4 0.2 setosa 1 4.9 1 3.0 1.4 0.2 setosa 2 4.7 2 3.2 1.3 0.2 setosa 3 4.6 3 3.1 1.5 0.2 setosa 4 5.0 4 3.6 1.4 0.2 setosa 5 5.4 5 3.9 1.7 0.4 setosa"},{"location":"notebooks/rownames/#has_rownames","title":"\u2605 has_rownames\u00b6","text":""},{"location":"notebooks/rownames/#detect-if-a-data-frame-has-row-names","title":"Detect if a data frame has row names\u00b6","text":"<p>Aliases <code>has_index</code></p>"},{"location":"notebooks/rownames/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: The data frame to check</p>"},{"location":"notebooks/rownames/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003True if the data frame has index otherwise False.</p>"},{"location":"notebooks/rownames/#remove_rownames","title":"\u2605 remove_rownames\u00b6","text":""},{"location":"notebooks/rownames/#remove-the-indexrownames-of-a-data-frame","title":"Remove the index/rownames of a data frame\u00b6","text":"<p>Aliases <code>remove_index</code>, <code>drop_index</code>, <code>remove_rownames</code></p>"},{"location":"notebooks/rownames/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: The data frame</p>"},{"location":"notebooks/rownames/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The data frame with index removed</p>"},{"location":"notebooks/rownames/#rownames_to_column","title":"\u2605 rownames_to_column\u00b6","text":""},{"location":"notebooks/rownames/#add-rownames-as-a-column","title":"Add rownames as a column\u00b6","text":"<p>Aliases <code>index_to_column</code></p>"},{"location":"notebooks/rownames/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: The data frame <code>var</code>: The name of the column</p>"},{"location":"notebooks/rownames/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The data frame with rownames added as one column. Note that the \u2003\u2003original index is removed.</p>"},{"location":"notebooks/rownames/#rowid_to_column","title":"\u2605 rowid_to_column\u00b6","text":""},{"location":"notebooks/rownames/#add-rownames-as-a-column","title":"Add rownames as a column\u00b6","text":""},{"location":"notebooks/rownames/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: The data frame <code>var</code>: The name of the column</p>"},{"location":"notebooks/rownames/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The data frame with row ids added as one column.</p>"},{"location":"notebooks/rownames/#column_to_rownames","title":"\u2605 column_to_rownames\u00b6","text":""},{"location":"notebooks/rownames/#set-rownamesindex-with-one-column-and-remove-it","title":"Set rownames/index with one column, and remove it\u00b6","text":"<p>Aliases <code>column_to_index</code></p>"},{"location":"notebooks/rownames/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: The data frame <code>var</code>: The column to conver to the rownames</p>"},{"location":"notebooks/rownames/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The data frame with the column converted to rownames</p>"},{"location":"notebooks/rows/","title":"rows","text":"In\u00a0[1]: Copied! <pre>%run nb_helpers.py\nfrom datar.all import *\n\nnb_header(\n    rows_insert, \n    rows_update, \n    rows_patch, \n    rows_upsert, \n    rows_delete, \n    book='rows'\n)\n</pre> %run nb_helpers.py from datar.all import *  nb_header(     rows_insert,      rows_update,      rows_patch,      rows_upsert,      rows_delete,      book='rows' ) Try this notebook on binder. In\u00a0[2]: Copied! <pre>data = tibble(a = seq(1, 3), b = c(letters[[0, 1]], NA), c = [.5, 1.5, 2.5])\ndata\n</pre> data = tibble(a = seq(1, 3), b = c(letters[[0, 1]], NA), c = [.5, 1.5, 2.5]) data Out[2]: a b c &lt;int64&gt; &lt;object&gt; &lt;float64&gt; 0 1 a 0.5 1 2 b 1.5 2 3 NaN 2.5 In\u00a0[3]: Copied! <pre>rows_insert(data, tibble(a = 4, b = \"z\"))\n</pre> rows_insert(data, tibble(a = 4, b = \"z\")) <pre>[2022-12-02 14:22:14][datar][   INFO] Matching, by='a'\n</pre> Out[3]: a b c &lt;int64&gt; &lt;object&gt; &lt;float64&gt; 0 1 a 0.5 1 2 b 1.5 2 3 NaN 2.5 3 4 z NaN In\u00a0[4]: Copied! <pre>with try_catch():\n    rows_insert(data, tibble(a = 3, b = \"z\"))\n</pre> with try_catch():     rows_insert(data, tibble(a = 3, b = \"z\")) <pre>[2022-12-02 14:22:14][datar][   INFO] Matching, by='a'\n</pre> <pre>[ValueError] Attempting to insert duplicate rows.\n</pre> In\u00a0[5]: Copied! <pre>rows_update(data, tibble(a = [2,3], b = \"z\"))\n</pre> rows_update(data, tibble(a = [2,3], b = \"z\")) <pre>[2022-12-02 14:22:15][datar][   INFO] Matching, by='a'\n</pre> Out[5]: a b c &lt;int64&gt; &lt;object&gt; &lt;float64&gt; 0 1 a 0.5 1 2 z 1.5 2 3 z 2.5 In\u00a0[6]: Copied! <pre>rows_update(data, tibble(b = \"z\", a = [2,3]), by = \"a\")\n</pre> rows_update(data, tibble(b = \"z\", a = [2,3]), by = \"a\") Out[6]: a b c &lt;int64&gt; &lt;object&gt; &lt;float64&gt; 0 1 a 0.5 1 2 z 1.5 2 3 z 2.5 In\u00a0[7]: Copied! <pre>rows_patch(data, tibble(a = [2,3], b = \"z\"))\n</pre> rows_patch(data, tibble(a = [2,3], b = \"z\")) <pre>[2022-12-02 14:22:17][datar][   INFO] Matching, by='a'\n</pre> Out[7]: a b c &lt;int64&gt; &lt;object&gt; &lt;float64&gt; 0 1 a 0.5 1 2 b 1.5 2 3 z 2.5 In\u00a0[8]: Copied! <pre>rows_upsert(data, tibble(a = seq(2, 4), b = \"z\"))\n</pre> rows_upsert(data, tibble(a = seq(2, 4), b = \"z\")) <pre>[2022-12-02 14:22:18][datar][   INFO] Matching, by='a'\n</pre> Out[8]: a b c &lt;int64&gt; &lt;object&gt; &lt;float64&gt; 0 1 a 0.5 1 2 z 1.5 2 3 z 2.5 3 4 z NaN In\u00a0[9]: Copied! <pre>rows_delete(data, tibble(a = [2, 3]))\n</pre> rows_delete(data, tibble(a = [2, 3])) <pre>[2022-12-02 14:22:18][datar][   INFO] Matching, by='a'\n</pre> Out[9]: a b c &lt;int64&gt; &lt;object&gt; &lt;float64&gt; 0 1 a 0.5 In\u00a0[10]: Copied! <pre>rows_delete(data, tibble(a = [2, 3], b = \"b\"))\n</pre> rows_delete(data, tibble(a = [2, 3], b = \"b\")) <pre>[2022-12-02 14:22:19][datar][   INFO] Matching, by='a'\n[2022-12-02 14:22:19][datar][   INFO] Ignoring extra columns: ['b']\n</pre> Out[10]: a b c &lt;int64&gt; &lt;object&gt; &lt;float64&gt; 0 1 a 0.5 In\u00a0[11]: Copied! <pre>with try_catch():\n    rows_delete(data, tibble(a = [2,3], b = \"b\"), by = c(\"a\", \"b\"))\n</pre> with try_catch():     rows_delete(data, tibble(a = [2,3], b = \"b\"), by = c(\"a\", \"b\")) <pre>[ValueError] Attempting to delete missing rows.\n</pre>"},{"location":"notebooks/rows/#rows_insert","title":"\u2605 rows_insert\u00b6","text":""},{"location":"notebooks/rows/#insert-rows-from-y-into-x","title":"Insert rows from y into x\u00b6","text":"<p>See original API https://dplyr.tidyverse.org/reference/rows.html</p>"},{"location":"notebooks/rows/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame <code>by</code>: An unnamed character vector giving the key columns. \u2003\u2003\u2003\u2003The key columns must exist in both x and y. \u2003\u2003\u2003\u2003Keys typically uniquely identify each row, but this is only \u2003\u2003\u2003\u2003enforced for the key values of y \u2003\u2003\u2003\u2003By default, we use the first column in y, since the first column is \u2003\u2003\u2003\u2003a reasonable place to put an identifier variable.</p> <p> <code>conflict</code>: How to handle conflicts \u2003\u2003\u2003\u2003- \"error\": Throw an error</p> <p>\u2003\u2003\u2003\u2003- \"ignore\": Ignore conflicts</p> <p> <code>copy</code>: If x and y are not from the same data source, and copy is TRUE, \u2003\u2003\u2003\u2003then y will be copied into the same src as x. \u2003\u2003\u2003\u2003This allows you to join tables across srcs, but it is a potentially \u2003\u2003\u2003\u2003expensive operation so you must opt into it.</p> <p> <code>in_place</code>: Should x be modified in place? \u2003\u2003\u2003\u2003This may not be supported, depending on the backend implementation.</p>"},{"location":"notebooks/rows/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with all existing rows and potentially new rows</p>"},{"location":"notebooks/rows/#rows_update","title":"\u2605 rows_update\u00b6","text":""},{"location":"notebooks/rows/#update-rows-in-x-with-values-from-y","title":"Update rows in x with values from y\u00b6","text":"<p>See original API https://dplyr.tidyverse.org/reference/rows.html</p>"},{"location":"notebooks/rows/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame <code>by</code>: An unnamed character vector giving the key columns. \u2003\u2003\u2003\u2003The key columns must exist in both x and y. \u2003\u2003\u2003\u2003Keys typically uniquely identify each row, but this is only \u2003\u2003\u2003\u2003enforced for the key values of y \u2003\u2003\u2003\u2003By default, we use the first column in y, since the first column is \u2003\u2003\u2003\u2003a reasonable place to put an identifier variable.</p> <p> <code>unmatched</code>: how should keys in y that are unmatched by the keys \u2003\u2003\u2003\u2003in x be handled? \u2003\u2003\u2003\u2003One of - \u2003\u2003\u2003\u2003\"error\", the default, will error if there are any keys in y that \u2003\u2003\u2003\u2003are unmatched by the keys in x. \u2003\u2003\u2003\u2003\"ignore\" will ignore rows in y with keys that are unmatched \u2003\u2003\u2003\u2003by the keys in x.</p> <p> <code>copy</code>: If x and y are not from the same data source, and copy is TRUE, \u2003\u2003\u2003\u2003then y will be copied into the same src as x. \u2003\u2003\u2003\u2003This allows you to join tables across srcs, but it is a potentially \u2003\u2003\u2003\u2003expensive operation so you must opt into it.</p> <p> <code>in_place</code>: Should x be modified in place? \u2003\u2003\u2003\u2003This may not be supported, depending on the backend implementation.</p>"},{"location":"notebooks/rows/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with all existing rows and potentially new rows</p>"},{"location":"notebooks/rows/#rows_patch","title":"\u2605 rows_patch\u00b6","text":""},{"location":"notebooks/rows/#patch-rows-in-x-with-values-from-y","title":"Patch rows in x with values from y\u00b6","text":"<p>See original API https://dplyr.tidyverse.org/reference/rows.html</p>"},{"location":"notebooks/rows/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame <code>by</code>: An unnamed character vector giving the key columns. \u2003\u2003\u2003\u2003The key columns must exist in both x and y. \u2003\u2003\u2003\u2003Keys typically uniquely identify each row, but this is only \u2003\u2003\u2003\u2003enforced for the key values of y \u2003\u2003\u2003\u2003By default, we use the first column in y, since the first column is \u2003\u2003\u2003\u2003a reasonable place to put an identifier variable.</p> <p> <code>unmatched</code>: how should keys in y that are unmatched by the keys \u2003\u2003\u2003\u2003in x be handled? \u2003\u2003\u2003\u2003One of - \u2003\u2003\u2003\u2003\"error\", the default, will error if there are any keys in y that \u2003\u2003\u2003\u2003are unmatched by the keys in x. \u2003\u2003\u2003\u2003\"ignore\" will ignore rows in y with keys that are unmatched \u2003\u2003\u2003\u2003by the keys in x.</p> <p> <code>copy</code>: If x and y are not from the same data source, and copy is TRUE, \u2003\u2003\u2003\u2003then y will be copied into the same src as x. \u2003\u2003\u2003\u2003This allows you to join tables across srcs, but it is a potentially \u2003\u2003\u2003\u2003expensive operation so you must opt into it.</p> <p> <code>in_place</code>: Should x be modified in place? \u2003\u2003\u2003\u2003This may not be supported, depending on the backend implementation.</p>"},{"location":"notebooks/rows/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with NA values overwritten and the number of rows preserved</p>"},{"location":"notebooks/rows/#rows_upsert","title":"\u2605 rows_upsert\u00b6","text":""},{"location":"notebooks/rows/#upsert-rows-in-x-with-values-from-y","title":"Upsert rows in x with values from y\u00b6","text":"<p>See original API https://dplyr.tidyverse.org/reference/rows.html</p>"},{"location":"notebooks/rows/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame <code>by</code>: An unnamed character vector giving the key columns. \u2003\u2003\u2003\u2003The key columns must exist in both x and y. \u2003\u2003\u2003\u2003Keys typically uniquely identify each row, but this is only \u2003\u2003\u2003\u2003enforced for the key values of y \u2003\u2003\u2003\u2003By default, we use the first column in y, since the first column is \u2003\u2003\u2003\u2003a reasonable place to put an identifier variable.</p> <p> <code>copy</code>: If x and y are not from the same data source, and copy is TRUE, \u2003\u2003\u2003\u2003then y will be copied into the same src as x. \u2003\u2003\u2003\u2003This allows you to join tables across srcs, but it is a potentially \u2003\u2003\u2003\u2003expensive operation so you must opt into it.</p> <p> <code>in_place</code>: Should x be modified in place? \u2003\u2003\u2003\u2003This may not be supported, depending on the backend implementation.</p>"},{"location":"notebooks/rows/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with inserted or updated depending on whether or not \u2003\u2003the key value in y already exists in x. Key values in y must be unique.</p>"},{"location":"notebooks/rows/#rows_delete","title":"\u2605 rows_delete\u00b6","text":""},{"location":"notebooks/rows/#delete-rows-in-x-that-match-keys-in-y","title":"Delete rows in x that match keys in y\u00b6","text":"<p>See original API https://dplyr.tidyverse.org/reference/rows.html</p>"},{"location":"notebooks/rows/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame <code>by</code>: An unnamed character vector giving the key columns. \u2003\u2003\u2003\u2003The key columns must exist in both x and y. \u2003\u2003\u2003\u2003Keys typically uniquely identify each row, but this is only \u2003\u2003\u2003\u2003enforced for the key values of y \u2003\u2003\u2003\u2003By default, we use the first column in y, since the first column is \u2003\u2003\u2003\u2003a reasonable place to put an identifier variable.</p> <p> <code>unmatched</code>: how should keys in y that are unmatched by the keys \u2003\u2003\u2003\u2003in x be handled? \u2003\u2003\u2003\u2003One of - \u2003\u2003\u2003\u2003\"error\", the default, will error if there are any keys in y that \u2003\u2003\u2003\u2003are unmatched by the keys in x. \u2003\u2003\u2003\u2003\"ignore\" will ignore rows in y with keys that are unmatched \u2003\u2003\u2003\u2003by the keys in x.</p> <p> <code>copy</code>: If x and y are not from the same data source, and copy is TRUE, \u2003\u2003\u2003\u2003then y will be copied into the same src as x. \u2003\u2003\u2003\u2003This allows you to join tables across srcs, but it is a potentially \u2003\u2003\u2003\u2003expensive operation so you must opt into it.</p> <p> <code>in_place</code>: Should x be modified in place? \u2003\u2003\u2003\u2003This may not be supported, depending on the backend implementation.</p>"},{"location":"notebooks/rows/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with rows deleted</p>"},{"location":"notebooks/rowwise/","title":"rowwise","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/rowwise.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(rowwise)\n</pre> # https://dplyr.tidyverse.org/reference/rowwise.html %run nb_helpers.py  from datar.all import *  nb_header(rowwise) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x=runif(6), y=runif(6), z=runif(6))\n\ndf &gt;&gt; rowwise() &gt;&gt; mutate(m=mean(c_across(c(f.x, f.y, f.z)))) \n</pre> df = tibble(x=runif(6), y=runif(6), z=runif(6))  df &gt;&gt; rowwise() &gt;&gt; mutate(m=mean(c_across(c(f.x, f.y, f.z))))  Out[2]: x y z m &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 0.740427 0.722062 0.796442 0.752977 1 0.420291 0.016988 0.681690 0.372989 2 0.983908 0.507227 0.508663 0.666599 3 0.059662 0.483942 0.047045 0.196883 4 0.288083 0.735485 0.868933 0.630834 5 0.184138 0.502597 0.424734 0.370489 <p>TibbleRowwise:  (n=6) </p> In\u00a0[3]: Copied! <pre>df &gt;&gt; rowwise() &gt;&gt; mutate(m=mean(c_across(f[f.x:])))\n</pre> df &gt;&gt; rowwise() &gt;&gt; mutate(m=mean(c_across(f[f.x:]))) Out[3]: x y z m &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 0.740427 0.722062 0.796442 0.752977 1 0.420291 0.016988 0.681690 0.372989 2 0.983908 0.507227 0.508663 0.666599 3 0.059662 0.483942 0.047045 0.196883 4 0.288083 0.735485 0.868933 0.630834 5 0.184138 0.502597 0.424734 0.370489 <p>TibbleRowwise:  (n=6) </p> In\u00a0[4]: Copied! <pre>df &gt;&gt; rowwise() &gt;&gt; mutate(m=min(c_across([f.x, f.y, f.z]))) \n</pre> df &gt;&gt; rowwise() &gt;&gt; mutate(m=min(c_across([f.x, f.y, f.z])))  Out[4]: x y z m &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 0.740427 0.722062 0.796442 0.722062 1 0.420291 0.016988 0.681690 0.016988 2 0.983908 0.507227 0.508663 0.507227 3 0.059662 0.483942 0.047045 0.047045 4 0.288083 0.735485 0.868933 0.288083 5 0.184138 0.502597 0.424734 0.184138 <p>TibbleRowwise:  (n=6) </p> In\u00a0[5]: Copied! <pre>df &gt;&gt; rowwise() &gt;&gt; mutate(m=min(c_across(f[f.x:]))) \n</pre> df &gt;&gt; rowwise() &gt;&gt; mutate(m=min(c_across(f[f.x:])))  Out[5]: x y z m &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 0.740427 0.722062 0.796442 0.722062 1 0.420291 0.016988 0.681690 0.016988 2 0.983908 0.507227 0.508663 0.507227 3 0.059662 0.483942 0.047045 0.047045 4 0.288083 0.735485 0.868933 0.288083 5 0.184138 0.502597 0.424734 0.184138 <p>TibbleRowwise:  (n=6) </p> In\u00a0[6]: Copied! <pre>df &gt;&gt; mutate(m = pmin(f.x, f.y, f.z))\n</pre> df &gt;&gt; mutate(m = pmin(f.x, f.y, f.z)) Out[6]: x y z m &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 0.740427 0.722062 0.796442 0.722062 1 0.420291 0.016988 0.681690 0.016988 2 0.983908 0.507227 0.508663 0.507227 3 0.059662 0.483942 0.047045 0.047045 4 0.288083 0.735485 0.868933 0.288083 5 0.184138 0.502597 0.424734 0.184138 In\u00a0[7]: Copied! <pre>params = tibble(\n    sim=[1, 2, 3],\n    n=[1, 2, 3],\n    mean=[1, 2, 1],\n    sd=[1, 4, 2]\n)\n\nparams &gt;&gt; rowwise(f.sim) &gt;&gt; mutate(z=rnorm(f.n, f.mean, f.sd)) \n</pre> params = tibble(     sim=[1, 2, 3],     n=[1, 2, 3],     mean=[1, 2, 1],     sd=[1, 4, 2] )  params &gt;&gt; rowwise(f.sim) &gt;&gt; mutate(z=rnorm(f.n, f.mean, f.sd))  Out[7]: sim n mean sd z &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;object&gt; 0 1 1 1 1 [1.8805605045050253] 1 2 2 2 4 [-2.39100601732882, 2.6882535131773917] 2 3 3 1 2 [-0.8909366235397611, 2.2500642263497337, 4.00... <p>TibbleRowwise: sim (n=3) </p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/rowwise/#rowwise","title":"\u2605 rowwise\u00b6","text":""},{"location":"notebooks/rowwise/#create-a-rowwise-frame","title":"Create a rowwise frame\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/rowwise.html</p>"},{"location":"notebooks/rowwise/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>*cols</code>: Columns to make rowwise.</p>"},{"location":"notebooks/rowwise/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A rowwise frame</p>"},{"location":"notebooks/select/","title":"select","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/select.html\n%run nb_helpers.py\n\nfrom datar.data import starwars, iris\nfrom datar.all import *\n\nnb_header(select)\n</pre> # https://dplyr.tidyverse.org/reference/select.html %run nb_helpers.py  from datar.data import starwars, iris from datar.all import *  nb_header(select) Try this notebook on binder. In\u00a0[2]: Copied! <pre>starwars &gt;&gt; select(f.height)\n</pre> starwars &gt;&gt; select(f.height) Out[2]: height &lt;float64&gt; 0 172.0 1 167.0 2 96.0 3 202.0 ... ... 4 150.0 82 NaN 83 NaN 84 NaN 85 NaN 86 165.0 <p>87 rows \u00d7 1 columns</p> In\u00a0[3]: Copied! <pre>iris &gt;&gt; pivot_longer(f['Sepal_Length'])\n</pre> iris &gt;&gt; pivot_longer(f['Sepal_Length']) Out[3]: Petal_Length Petal_Width Sepal_Width Species name value &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; 0 1.4 0.2 3.5 setosa Sepal_Length 5.1 1 1.4 0.2 3.0 setosa Sepal_Length 4.9 2 1.3 0.2 3.2 setosa Sepal_Length 4.7 3 1.5 0.2 3.1 setosa Sepal_Length 4.6 ... ... ... ... ... ... ... 4 1.4 0.2 3.6 setosa Sepal_Length 5.0 145 5.2 2.3 3.0 virginica Sepal_Length 6.7 146 5.0 1.9 2.5 virginica Sepal_Length 6.3 147 5.2 2.0 3.0 virginica Sepal_Length 6.5 148 5.4 2.3 3.4 virginica Sepal_Length 6.2 149 5.1 1.8 3.0 virginica Sepal_Length 5.9 <p>150 rows \u00d7 6 columns</p> In\u00a0[4]: Copied! <pre>starwars &gt;&gt; select(f.homeworld, f.height, f.mass)\n</pre> starwars &gt;&gt; select(f.homeworld, f.height, f.mass) Out[4]: homeworld height mass &lt;object&gt; &lt;float64&gt; &lt;float64&gt; 0 Tatooine 172.0 77.0 1 Tatooine 167.0 75.0 2 Naboo 96.0 32.0 3 Tatooine 202.0 136.0 ... ... ... ... 4 Alderaan 150.0 49.0 82 NaN NaN NaN 83 NaN NaN NaN 84 NaN NaN NaN 85 NaN NaN NaN 86 Naboo 165.0 45.0 <p>87 rows \u00d7 3 columns</p> In\u00a0[5]: Copied! <pre>iris &gt;&gt; pivot_longer(c(f['Sepal_Length'], f['Petal_Length']))\n</pre> iris &gt;&gt; pivot_longer(c(f['Sepal_Length'], f['Petal_Length'])) Out[5]: Petal_Width Sepal_Width Species name value &lt;float64&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; 0 0.2 3.5 setosa Sepal_Length 5.1 1 0.2 3.0 setosa Sepal_Length 4.9 2 0.2 3.2 setosa Sepal_Length 4.7 3 0.2 3.1 setosa Sepal_Length 4.6 ... ... ... ... ... ... 4 0.2 3.6 setosa Sepal_Length 5.0 295 2.3 3.0 virginica Petal_Length 5.2 296 1.9 2.5 virginica Petal_Length 5.0 297 2.0 3.0 virginica Petal_Length 5.2 298 2.3 3.4 virginica Petal_Length 5.4 299 1.8 3.0 virginica Petal_Length 5.1 <p>300 rows \u00d7 5 columns</p> In\u00a0[6]: Copied! <pre>starwars &gt;&gt; select(c[f.name:f.mass])\n</pre> starwars &gt;&gt; select(c[f.name:f.mass]) Out[6]: name height &lt;object&gt; &lt;float64&gt; 0 Luke Skywalker 172.0 1 C-3PO 167.0 2 R2-D2 96.0 3 Darth Vader 202.0 ... ... ... 4 Leia Organa 150.0 82 Rey NaN 83 Poe Dameron NaN 84 BB8 NaN 85 Captain Phasma NaN 86 Padm\u00e9 Amidala 165.0 <p>87 rows \u00d7 2 columns</p> In\u00a0[7]: Copied! <pre>starwars &gt;&gt; select(~c[f.name:f.mass])\n</pre> starwars &gt;&gt; select(~c[f.name:f.mass]) Out[7]: mass hair_color skin_color eye_color birth_year sex gender homeworld species &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 77.0 blond fair blue 19.0 male masculine Tatooine Human 1 75.0 NaN gold yellow 112.0 none masculine Tatooine Droid 2 32.0 NaN white, blue red 33.0 none masculine Naboo Droid 3 136.0 none white yellow 41.9 male masculine Tatooine Human ... ... ... ... ... ... ... ... ... ... 4 49.0 brown light brown 19.0 female feminine Alderaan Human 82 NaN brown light hazel NaN female feminine NaN Human 83 NaN brown light brown NaN male masculine NaN Human 84 NaN none none black NaN none masculine NaN Droid 85 NaN unknown unknown unknown NaN NaN NaN NaN NaN 86 45.0 brown light brown 46.0 female feminine Naboo Human <p>87 rows \u00d7 9 columns</p> In\u00a0[8]: Copied! <pre>iris &gt;&gt; select(~c(f['Sepal_Length'], f['Petal_Length']))\n</pre> iris &gt;&gt; select(~c(f['Sepal_Length'], f['Petal_Length'])) Out[8]: Sepal_Width Petal_Width Species &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 3.5 0.2 setosa 1 3.0 0.2 setosa 2 3.2 0.2 setosa 3 3.1 0.2 setosa ... ... ... ... 4 3.6 0.2 setosa 145 3.0 2.3 virginica 146 2.5 1.9 virginica 147 3.0 2.0 virginica 148 3.4 2.3 virginica 149 3.0 1.8 virginica <p>150 rows \u00d7 3 columns</p> In\u00a0[9]: Copied! <pre>iris &gt;&gt; select(~ends_with(\"Width\"))\n</pre> iris &gt;&gt; select(~ends_with(\"Width\")) Out[9]: Sepal_Length Petal_Length Species &lt;float64&gt; &lt;float64&gt; &lt;object&gt; 0 5.1 1.4 setosa 1 4.9 1.4 setosa 2 4.7 1.3 setosa 3 4.6 1.5 setosa ... ... ... ... 4 5.0 1.4 setosa 145 6.7 5.2 virginica 146 6.3 5.0 virginica 147 6.5 5.2 virginica 148 6.2 5.4 virginica 149 5.9 5.1 virginica <p>150 rows \u00d7 3 columns</p> In\u00a0[10]: Copied! <pre>iris &gt;&gt; select(starts_with(\"Petal\") &amp; ends_with(\"Width\"))\n</pre> iris &gt;&gt; select(starts_with(\"Petal\") &amp; ends_with(\"Width\")) Out[10]: Petal_Width &lt;float64&gt; 0 0.2 1 0.2 2 0.2 3 0.2 ... ... 4 0.2 145 2.3 146 1.9 147 2.0 148 2.3 149 1.8 <p>150 rows \u00d7 1 columns</p> In\u00a0[11]: Copied! <pre>iris &gt;&gt; select(starts_with(\"Petal\") | ends_with(\"Width\"))\n</pre> iris &gt;&gt; select(starts_with(\"Petal\") | ends_with(\"Width\")) Out[11]: Petal_Length Petal_Width Sepal_Width &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 1.4 0.2 3.5 1 1.4 0.2 3.0 2 1.3 0.2 3.2 3 1.5 0.2 3.1 ... ... ... ... 4 1.4 0.2 3.6 145 5.2 2.3 3.0 146 5.0 1.9 2.5 147 5.2 2.0 3.0 148 5.4 2.3 3.4 149 5.1 1.8 3.0 <p>150 rows \u00d7 3 columns</p> In\u00a0[12]: Copied! <pre>iris &gt;&gt; select(starts_with(\"Petal\") &amp; ~ends_with(\"Width\"))\n</pre> iris &gt;&gt; select(starts_with(\"Petal\") &amp; ~ends_with(\"Width\")) Out[12]: Petal_Length &lt;float64&gt; 0 1.4 1 1.4 2 1.3 3 1.5 ... ... 4 1.4 145 5.2 146 5.0 147 5.2 148 5.4 149 5.1 <p>150 rows \u00d7 1 columns</p> In\u00a0[13]: Copied! <pre># select last column\niris &gt;&gt; select(-1)\n</pre> # select last column iris &gt;&gt; select(-1) Out[13]: Species &lt;object&gt; 0 setosa 1 setosa 2 setosa 3 setosa ... ... 4 setosa 145 virginica 146 virginica 147 virginica 148 virginica 149 virginica <p>150 rows \u00d7 1 columns</p> In\u00a0[14]: Copied! <pre>iris &gt;&gt; select(c[1:3])\n</pre> iris &gt;&gt; select(c[1:3]) Out[14]: Sepal_Width Petal_Length &lt;float64&gt; &lt;float64&gt; 0 3.5 1.4 1 3.0 1.4 2 3.2 1.3 3 3.1 1.5 ... ... ... 4 3.6 1.4 145 3.0 5.2 146 2.5 5.0 147 3.0 5.2 148 3.4 5.4 149 3.0 5.1 <p>150 rows \u00d7 2 columns</p> In\u00a0[15]: Copied! <pre># drop last column\niris &gt;&gt; select(~c(-1))\n</pre> # drop last column iris &gt;&gt; select(~c(-1)) Out[15]: Sepal_Length Sepal_Width Petal_Length Petal_Width &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; 0 5.1 3.5 1.4 0.2 1 4.9 3.0 1.4 0.2 2 4.7 3.2 1.3 0.2 3 4.6 3.1 1.5 0.2 ... ... ... ... ... 4 5.0 3.6 1.4 0.2 145 6.7 3.0 5.2 2.3 146 6.3 2.5 5.0 1.9 147 6.5 3.0 5.2 2.0 148 6.2 3.4 5.4 2.3 149 5.9 3.0 5.1 1.8 <p>150 rows \u00d7 4 columns</p>"},{"location":"notebooks/select/#select","title":"\u2605 select\u00b6","text":""},{"location":"notebooks/select/#select-columns-from-a-data-frame","title":"Select columns from a data frame.\u00b6","text":"<p>See original API https://dplyr.tidyverse.org/reference/select.html</p>"},{"location":"notebooks/select/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>*args</code>: A list of columns to select <code>**kwargs</code>: A list of columns to select</p>"},{"location":"notebooks/select/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with only the selected columns</p>"},{"location":"notebooks/separate/","title":"separate","text":"In\u00a0[1]: Copied! <pre># https://tidyr.tidyverse.org/reference/separate.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(separate, separate_rows)\n</pre> # https://tidyr.tidyverse.org/reference/separate.html %run nb_helpers.py  from datar.all import *  nb_header(separate, separate_rows) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x=c(NA, \"x.y\", \"x.z\", \"y.z\"))\ndf &gt;&gt; separate(f.x, c(\"A\", \"B\"))\n</pre> df = tibble(x=c(NA, \"x.y\", \"x.z\", \"y.z\")) df &gt;&gt; separate(f.x, c(\"A\", \"B\")) Out[2]: A B &lt;object&gt; &lt;object&gt; 0 NaN NaN 1 x y 2 x z 3 y z In\u00a0[3]: Copied! <pre>df &gt;&gt; separate(f.x, c(NA, \"B\"))\n</pre> df &gt;&gt; separate(f.x, c(NA, \"B\")) Out[3]: B &lt;object&gt; 0 NaN 1 y 2 z 3 z In\u00a0[4]: Copied! <pre>df = tibble(x=c(\"x\", \"x y\", \"x y z\", NA))\ndf &gt;&gt; separate(f.x, c(\"a\", \"b\"))\n</pre> df = tibble(x=c(\"x\", \"x y\", \"x y z\", NA)) df &gt;&gt; separate(f.x, c(\"a\", \"b\")) <pre>[2022-12-02 14:25:28][datar][WARNING] Expected 2 pieces. Additional pieces discarded in 1 rows ['x y z'].\n[2022-12-02 14:25:28][datar][WARNING] Expected 2 pieces. Missing pieces filled with `NA` in 1 rows ['x'].\n</pre> Out[4]: a b &lt;object&gt; &lt;object&gt; 0 x NaN 1 x y 2 x y 3 NaN NaN In\u00a0[5]: Copied! <pre>df &gt;&gt; separate(f.x, c(\"a\", \"b\"), extra=\"drop\", fill=\"right\")\n</pre> df &gt;&gt; separate(f.x, c(\"a\", \"b\"), extra=\"drop\", fill=\"right\") Out[5]: a b &lt;object&gt; &lt;object&gt; 0 x NaN 1 x y 2 x y 3 NaN NaN In\u00a0[6]: Copied! <pre>df &gt;&gt; separate(f.x, c(\"a\", \"b\"), extra=\"merge\", fill=\"left\")\n</pre> df &gt;&gt; separate(f.x, c(\"a\", \"b\"), extra=\"merge\", fill=\"left\") Out[6]: a b &lt;object&gt; &lt;object&gt; 0 NaN x 1 x y 2 x y z 3 NaN NaN In\u00a0[7]: Copied! <pre>df &gt;&gt; separate(f.x, c(\"a\", \"b\", \"c\"))\n</pre> df &gt;&gt; separate(f.x, c(\"a\", \"b\", \"c\")) <pre>[2022-12-02 14:25:32][datar][WARNING] Expected 3 pieces. Missing pieces filled with `NA` in 2 rows ['x', 'x y'].\n</pre> Out[7]: a b c &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 x NaN NaN 1 x y NaN 2 x y z 3 NaN NaN NaN In\u00a0[8]: Copied! <pre>df = tibble(x=c(\"x: 123\", \"y: error: 7\"))\ndf &gt;&gt; separate(f.x, c(\"key\", \"value\"), \": \", extra=\"merge\")\n</pre> df = tibble(x=c(\"x: 123\", \"y: error: 7\")) df &gt;&gt; separate(f.x, c(\"key\", \"value\"), \": \", extra=\"merge\") Out[8]: key value &lt;object&gt; &lt;object&gt; 0 x 123 1 y error: 7 In\u00a0[9]: Copied! <pre>df = tibble(x=c(NA, \"x?y\", \"x.z\", \"y:z\"))\ndf &gt;&gt; separate(f.x, c(\"A\",\"B\"), sep=r\"[.?:]\")\n</pre> df = tibble(x=c(NA, \"x?y\", \"x.z\", \"y:z\")) df &gt;&gt; separate(f.x, c(\"A\",\"B\"), sep=r\"[.?:]\") Out[9]: A B &lt;object&gt; &lt;object&gt; 0 NaN NaN 1 x y 2 x z 3 y z In\u00a0[10]: Copied! <pre>df = tibble(x=c(\"x:1\", \"x:2\", \"y:4\", \"z\", NA))\ndf &gt;&gt; separate(f.x, c(\"key\",\"value\"), \":\")\n</pre> df = tibble(x=c(\"x:1\", \"x:2\", \"y:4\", \"z\", NA)) df &gt;&gt; separate(f.x, c(\"key\",\"value\"), \":\") <pre>[2022-12-02 14:25:35][datar][WARNING] Expected 2 pieces. Missing pieces filled with `NA` in 1 rows ['z'].\n</pre> Out[10]: key value &lt;object&gt; &lt;object&gt; 0 x 1 1 x 2 2 y 4 3 z NaN 4 NaN NaN In\u00a0[11]: Copied! <pre>out = df &gt;&gt; separate(f.x, c(\"key\",\"value\"), \":\", convert={'value': float}) \nout.dtypes\n</pre> out = df &gt;&gt; separate(f.x, c(\"key\",\"value\"), \":\", convert={'value': float})  out.dtypes <pre>[2022-12-02 14:25:36][datar][WARNING] Expected 2 pieces. Missing pieces filled with `NA` in 1 rows ['z'].\n</pre> Out[11]: <pre>key       object\nvalue    float64\ndtype: object</pre> In\u00a0[12]: Copied! <pre>df = tibble(\n  x=[1,2,3],\n  y=c(\"a\", \"d,e,f\", \"g,h\"),\n  z=c(\"1\", \"2,3,4\", \"5,6\")\n)\n</pre> df = tibble(   x=[1,2,3],   y=c(\"a\", \"d,e,f\", \"g,h\"),   z=c(\"1\", \"2,3,4\", \"5,6\") ) In\u00a0[13]: Copied! <pre>df &gt;&gt; separate_rows(f.y, f.z, convert={'z': int})\n</pre> df &gt;&gt; separate_rows(f.y, f.z, convert={'z': int}) Out[13]: x y z &lt;int64&gt; &lt;object&gt; &lt;int64&gt; 0 1 a 1 1 2 d 2 2 2 e 3 3 2 f 4 4 3 g 5 5 3 h 6 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/separate/#separate","title":"\u2605 separate\u00b6","text":""},{"location":"notebooks/separate/#given-either-a-regular-expression-or-a-vector-of-character-positions","title":"Given either a regular expression or a vector of character positions,\u00b6","text":"<p>turns a single character column into multiple columns.</p>"},{"location":"notebooks/separate/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: The dataframe <code>col</code>: Column name or position. <code>into</code>: Names of new variables to create as character vector. \u2003\u2003\u2003\u2003Use <code>None</code>/<code>NA</code>/<code>NULL</code> to omit the variable in the output.</p> <p> <code>sep</code>: Separator between columns. \u2003\u2003\u2003\u2003If str, <code>sep</code> is interpreted as a regular expression. \u2003\u2003\u2003\u2003The default value is a regular expression that matches \u2003\u2003\u2003\u2003any sequence of non-alphanumeric values. \u2003\u2003\u2003\u2003If int, <code>sep</code> is interpreted as character positions to split at.</p> <p> <code>remove</code>: If TRUE, remove input column from output data frame. <code>convert</code>: The universal type for the extracted columns or a dict for \u2003\u2003\u2003\u2003individual ones \u2003\u2003\u2003\u2003Note that when given <code>TRUE</code>, <code>DataFrame.convert_dtypes()</code> is called, \u2003\u2003\u2003\u2003but it will not convert <code>str</code> to other types \u2003\u2003\u2003\u2003(For example, <code>'1'</code> to <code>1</code>). You have to specify the dtype yourself.</p> <p> <code>extra</code>: If sep is a character vector, this controls what happens when \u2003\u2003\u2003\u2003there are too many pieces. There are three valid options:</p> <p>\u2003\u2003\u2003\u2003- \"warn\" (the default): emit a warning and drop extra values.</p> <p>\u2003\u2003\u2003\u2003- \"drop\": drop any extra values without a warning.</p> <p>\u2003\u2003\u2003\u2003- \"merge\": only splits at most length(into) times</p> <p> <code>fill</code>: If sep is a character vector, this controls what happens when \u2003\u2003\u2003\u2003there are not enough pieces. There are three valid options:</p> <p>\u2003\u2003\u2003\u2003- \"warn\" (the default): emit a warning and fill from the right</p> <p>\u2003\u2003\u2003\u2003- \"right\": fill with missing values on the right</p> <p>\u2003\u2003\u2003\u2003- \"left\": fill with missing values on the left</p>"},{"location":"notebooks/separate/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003Dataframe with separated columns.</p>"},{"location":"notebooks/separate/#separate_rows","title":"\u2605 separate_rows\u00b6","text":""},{"location":"notebooks/separate/#separates-the-values-and-places-each-one-in-its-own-row","title":"Separates the values and places each one in its own row.\u00b6","text":""},{"location":"notebooks/separate/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: The dataframe <code>*columns</code>: The columns to separate on <code>sep</code>: Separator between columns. <code>convert</code>: The universal type for the extracted columns or a dict for \u2003\u2003\u2003\u2003individual ones</p>"},{"location":"notebooks/separate/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003Dataframe with rows separated and repeated.</p>"},{"location":"notebooks/setops/","title":"setops","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/setops.html\n%run nb_helpers.py\n\nfrom datar.data import mtcars\nfrom datar.all import *\n\nnb_header(intersect, union, setdiff, union_all, setequal, book='setops')\n</pre> # https://dplyr.tidyverse.org/reference/setops.html %run nb_helpers.py  from datar.data import mtcars from datar.all import *  nb_header(intersect, union, setdiff, union_all, setequal, book='setops') Try this notebook on binder. In\u00a0[2]: Copied! <pre>first = mtcars &gt;&gt; slice(c[:20])\nsecond = mtcars &gt;&gt; slice(c[9:33])\n\nintersect(first, second) # or first &gt;&gt; intersect(second)\n</pre> first = mtcars &gt;&gt; slice(c[:20]) second = mtcars &gt;&gt; slice(c[9:33])  intersect(first, second) # or first &gt;&gt; intersect(second) Out[2]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 1 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 2 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 3 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 4 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 5 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 6 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 7 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 8 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 9 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 10 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 In\u00a0[3]: Copied! <pre>union(first, second)\n</pre> union(first, second) Out[3]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 1 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 2 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 3 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 4 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 5 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 6 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 7 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 8 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 9 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 10 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 11 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 12 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 13 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 14 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 15 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 16 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 17 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 18 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 19 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 20 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 21 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 22 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 23 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 24 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 25 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 26 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 27 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 28 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 29 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 30 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 31 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 In\u00a0[4]: Copied! <pre>setdiff(first, second)\n</pre> setdiff(first, second) Out[4]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 1 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 2 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 3 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 4 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 5 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 6 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 7 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 8 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 In\u00a0[5]: Copied! <pre>setdiff(second, first)\n</pre> setdiff(second, first) Out[5]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 1 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 2 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 3 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 4 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 5 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 6 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 7 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 8 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 9 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 10 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 11 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 In\u00a0[6]: Copied! <pre>union_all(first, second)\n</pre> union_all(first, second) Out[6]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 1 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 2 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 3 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 4 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 5 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 6 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 7 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 8 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 9 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 10 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 11 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 12 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 13 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 14 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 15 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 16 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 17 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 18 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 19 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 20 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 21 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 22 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 23 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 24 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 25 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 26 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 27 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 28 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 29 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 30 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 31 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 32 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 33 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 34 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 35 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 36 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 37 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 38 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 39 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 40 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 41 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 42 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 In\u00a0[7]: Copied! <pre>setequal(mtcars, mtcars &gt;&gt; slice(c[::-1]))\n</pre> setequal(mtcars, mtcars &gt;&gt; slice(c[::-1])) Out[7]: <pre>False</pre> In\u00a0[8]: Copied! <pre>a = tibble(column=c(*range(11), 10))\nb = tibble(column=c(*range(6), 5))\nintersect(a, b)\n</pre> a = tibble(column=c(*range(11), 10)) b = tibble(column=c(*range(6), 5)) intersect(a, b) Out[8]: column &lt;int64&gt; 0 0 1 1 2 2 3 3 4 4 5 5 In\u00a0[9]: Copied! <pre>union(a, b)\n</pre> union(a, b) Out[9]: column &lt;int64&gt; 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 In\u00a0[10]: Copied! <pre>setdiff(a, b)\n</pre> setdiff(a, b) Out[10]: column &lt;int64&gt; 0 6 1 7 2 8 3 9 4 10 In\u00a0[11]: Copied! <pre>union_all(a, b)\n</pre> union_all(a, b) Out[11]: column &lt;int64&gt; 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 10 12 0 13 1 14 2 15 3 16 4 17 5 18 5"},{"location":"notebooks/setops/#intersect","title":"\u2605 intersect\u00b6","text":""},{"location":"notebooks/setops/#get-the-intersection-of-two-vectors","title":"Get the intersection of two vectors\u00b6","text":""},{"location":"notebooks/setops/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: the first vector <code>y</code>: the second vector</p>"},{"location":"notebooks/setops/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The intersection of the two vectors</p>"},{"location":"notebooks/setops/#union","title":"\u2605 union\u00b6","text":""},{"location":"notebooks/setops/#get-the-union-of-two-vectors","title":"Get the union of two vectors\u00b6","text":""},{"location":"notebooks/setops/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: the first vector <code>y</code>: the second vector</p>"},{"location":"notebooks/setops/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The union of the two vectors</p>"},{"location":"notebooks/setops/#setdiff","title":"\u2605 setdiff\u00b6","text":""},{"location":"notebooks/setops/#get-the-difference-of-two-vectors","title":"Get the difference of two vectors\u00b6","text":""},{"location":"notebooks/setops/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: the first vector <code>y</code>: the second vector</p>"},{"location":"notebooks/setops/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The difference of the two vectors</p>"},{"location":"notebooks/setops/#union_all","title":"\u2605 union_all\u00b6","text":""},{"location":"notebooks/setops/#combine-two-data-frames-together","title":"Combine two data frames together.\u00b6","text":"<p>See original API https://dplyr.tidyverse.org/reference/setops.html</p>"},{"location":"notebooks/setops/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: A data frame <code>y</code>: A data frame</p>"},{"location":"notebooks/setops/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with rows from x and y</p>"},{"location":"notebooks/setops/#setequal","title":"\u2605 setequal\u00b6","text":""},{"location":"notebooks/setops/#check-if-two-vectors-are-equal","title":"Check if two vectors are equal\u00b6","text":""},{"location":"notebooks/setops/#args","title":"Args:\u00b6","text":"<p> <code>x</code>: the first vector <code>y</code>: the second vector</p>"},{"location":"notebooks/setops/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003Whether the two vectors are equal</p>"},{"location":"notebooks/slice/","title":"slice","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/slice.html\n%run nb_helpers.py\n\nfrom datar.data import mtcars\nfrom datar.all import *\n\nnb_header(slice, slice_head, slice_max, slice_min, slice_sample, slice_tail)\n</pre> # https://dplyr.tidyverse.org/reference/slice.html %run nb_helpers.py  from datar.data import mtcars from datar.all import *  nb_header(slice, slice_head, slice_max, slice_min, slice_sample, slice_tail) Try this notebook on binder. In\u00a0[4]: Copied! <pre>mtcars &gt;&gt; slice(0) # 0-based by default\n</pre> mtcars &gt;&gt; slice(0) # 0-based by default Out[4]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Mazda RX4 21.0 6 160.0 110 3.9 2.62 16.46 0 1 4 4 In\u00a0[3]: Copied! <pre>mtcars &gt;&gt; slice(n()-1) # last row\n</pre> mtcars &gt;&gt; slice(n()-1) # last row Out[3]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 In\u00a0[5]: Copied! <pre># or\nmtcars &gt;&gt; slice(-1) \n</pre> # or mtcars &gt;&gt; slice(-1)  Out[5]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 In\u00a0[6]: Copied! <pre>mtcars &gt;&gt; slice(c[5:])\n</pre> mtcars &gt;&gt; slice(c[5:]) Out[6]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 In\u00a0[7]: Copied! <pre># or\nmtcars &gt;&gt; slice(~c[:4])\n</pre> # or mtcars &gt;&gt; slice(~c[:4]) Out[7]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 In\u00a0[8]: Copied! <pre>mtcars &gt;&gt; slice(-c[:4]) \n</pre> mtcars &gt;&gt; slice(-c[:4])  Out[8]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.17 14.5 0 1 5 4 Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 Maserati Bora 15.0 8 301.0 335 3.54 3.57 14.6 0 1 5 8 Ferrari Dino 19.7 6 145.0 175 3.62 2.77 15.5 0 1 5 6 In\u00a0[9]: Copied! <pre>mtcars &gt;&gt; slice_head(n=5)\n</pre> mtcars &gt;&gt; slice_head(n=5) Out[9]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 In\u00a0[10]: Copied! <pre>mtcars &gt;&gt; slice_tail(n=5)\n</pre> mtcars &gt;&gt; slice_tail(n=5) Out[10]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 In\u00a0[11]: Copied! <pre>mtcars &gt;&gt; slice_min(f.mpg, n=5)\n</pre> mtcars &gt;&gt; slice_min(f.mpg, n=5) Out[11]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 In\u00a0[12]: Copied! <pre>mtcars &gt;&gt; slice_max(f.mpg, n=5)\n</pre> mtcars &gt;&gt; slice_max(f.mpg, n=5) Out[12]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 In\u00a0[13]: Copied! <pre>mtcars &gt;&gt; slice_min(f.cyl, n=1)\n</pre> mtcars &gt;&gt; slice_min(f.cyl, n=1) Out[13]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 In\u00a0[14]: Copied! <pre>mtcars &gt;&gt; slice_min(f.cyl, n=1, with_ties=False)\n</pre> mtcars &gt;&gt; slice_min(f.cyl, n=1, with_ties=False) Out[14]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Datsun 710 22.8 4 108.0 93 3.85 2.32 18.61 1 1 4 1 In\u00a0[15]: Copied! <pre>mtcars &gt;&gt; slice_min(f.cyl, n=1, with_ties='last')\n</pre> mtcars &gt;&gt; slice_min(f.cyl, n=1, with_ties='last') Out[15]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 In\u00a0[16]: Copied! <pre>mtcars &gt;&gt; slice_sample(n=5)\n</pre> mtcars &gt;&gt; slice_sample(n=5) Out[16]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 In\u00a0[17]: Copied! <pre>mtcars &gt;&gt; slice_sample(n=5, random_state=8525)\n</pre> mtcars &gt;&gt; slice_sample(n=5, random_state=8525) Out[17]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.6 0 0 3 3 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.9 1 0 4 2 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.0 1 0 4 2 In\u00a0[18]: Copied! <pre>mtcars &gt;&gt; slice_sample(n=5, random_state=8525)\n</pre> mtcars &gt;&gt; slice_sample(n=5, random_state=8525) Out[18]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.6 0 0 3 3 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.9 1 0 4 2 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.0 1 0 4 2 In\u00a0[19]: Copied! <pre>mtcars &gt;&gt; slice_sample(n=5, random_state=8525, replace=True)\n</pre> mtcars &gt;&gt; slice_sample(n=5, random_state=8525, replace=True) Out[19]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 In\u00a0[20]: Copied! <pre>mtcars &gt;&gt; slice_sample(weight_by=f.wt, n=5)\n</pre> mtcars &gt;&gt; slice_sample(weight_by=f.wt, n=5) Out[20]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 In\u00a0[21]: Copied! <pre>df = tibble(\n  group=['a'] + ['b']*2 + ['c']*4,\n  x=runif(7)\n)\ndf &gt;&gt; group_by(f.group) &gt;&gt; slice_head(n=2) \n</pre> df = tibble(   group=['a'] + ['b']*2 + ['c']*4,   x=runif(7) ) df &gt;&gt; group_by(f.group) &gt;&gt; slice_head(n=2)  Out[21]: group x &lt;object&gt; &lt;float64&gt; 0 a 0.993287 1 b 0.969380 2 b 0.450665 3 c 0.710398 4 c 0.029497 <p>TibbleGrouped: group (n=3) </p> In\u00a0[22]: Copied! <pre>df &gt;&gt; group_by(f.group) &gt;&gt; slice_head(prop = 0.5)\n</pre> df &gt;&gt; group_by(f.group) &gt;&gt; slice_head(prop = 0.5) Out[22]: group x &lt;object&gt; &lt;float64&gt; 0 b 0.969380 1 c 0.710398 2 c 0.029497 <p>TibbleGrouped: group (n=2) </p> In\u00a0[23]: Copied! <pre># row_number() is 1-based by default\nmtcars &gt;&gt; filter(row_number() == 1) \n</pre> # row_number() is 1-based by default mtcars &gt;&gt; filter(row_number() == 1)  Out[23]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Mazda RX4 21.0 6 160.0 110 3.9 2.62 16.46 0 1 4 4 In\u00a0[24]: Copied! <pre>mtcars &gt;&gt; filter(row_number() == n() )\n</pre> mtcars &gt;&gt; filter(row_number() == n() ) Out[24]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.78 18.6 1 1 4 2 In\u00a0[25]: Copied! <pre>mtcars &gt;&gt; filter(5 &lt;= row_number() &lt; n()) # cannot filter\n</pre> mtcars &gt;&gt; filter(5 &lt;= row_number() &lt; n()) # cannot filter Out[25]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 In\u00a0[26]: Copied! <pre>mtcars &gt;&gt; filter(between(row_number(), 5, n()))\n</pre> mtcars &gt;&gt; filter(between(row_number(), 5, n())) Out[26]: mpg cyl disp hp drat wt qsec vs am gear carb &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 In\u00a0[27]: Copied! <pre>df = tibble(\n  group=['a']*10 + ['b']*20 + ['c']*40,\n  x=runif(70)\n)\ndf &gt;&gt; group_by(f.group) &gt;&gt; slice_min(f.x, 2)\n</pre> df = tibble(   group=['a']*10 + ['b']*20 + ['c']*40,   x=runif(70) ) df &gt;&gt; group_by(f.group) &gt;&gt; slice_min(f.x, 2) Out[27]: group x &lt;object&gt; &lt;float64&gt; 0 a 0.068146 1 a 0.418989 2 b 0.047916 3 b 0.054781 4 c 0.000433 5 c 0.010472 <p>TibbleGrouped: group (n=3) </p> In\u00a0[28]: Copied! <pre>df &gt;&gt; group_by(f.group) &gt;&gt; slice_max(f.x, 2)\n</pre> df &gt;&gt; group_by(f.group) &gt;&gt; slice_max(f.x, 2) Out[28]: group x &lt;object&gt; &lt;float64&gt; 0 a 0.985698 1 a 0.712850 2 b 0.993662 3 b 0.985569 4 c 0.994279 5 c 0.966813 <p>TibbleGrouped: group (n=3) </p> In\u00a0[29]: Copied! <pre>df &gt;&gt; group_by(f.group) &gt;&gt; slice_sample(2)\n</pre> df &gt;&gt; group_by(f.group) &gt;&gt; slice_sample(2) Out[29]: group x &lt;object&gt; &lt;float64&gt; 0 a 0.636650 1 a 0.068146 2 b 0.058098 3 b 0.847180 4 c 0.743841 5 c 0.010472 <p>TibbleGrouped: group (n=3) </p>"},{"location":"notebooks/slice/#slice_","title":"\u2605 slice_\u00b6","text":""},{"location":"notebooks/slice/#extract-rows-by-their-position","title":"Extract rows by their position\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/slice.html</p>"},{"location":"notebooks/slice/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>*args</code>: Positions to extract. <code>_preserve</code>: If <code>True</code>, keep grouping variables even if they are not used.</p>"},{"location":"notebooks/slice/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The subset dataframe</p>"},{"location":"notebooks/slice/#slice_head","title":"\u2605 slice_head\u00b6","text":""},{"location":"notebooks/slice/#extract-the-first-rows","title":"Extract the first rows\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/slice.html</p>"},{"location":"notebooks/slice/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>n</code>: Number of rows to extract. <code>prop</code>: Proportion of rows to extract.</p>"},{"location":"notebooks/slice/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The subset dataframe</p>"},{"location":"notebooks/slice/#slice_max","title":"\u2605 slice_max\u00b6","text":""},{"location":"notebooks/slice/#extract-rows-with-the-maximum-value","title":"Extract rows with the maximum value\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/slice.html</p>"},{"location":"notebooks/slice/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>order_by</code>: A variable or function of variables to order by. <code>n</code>: Number of rows to extract. <code>prop</code>: Proportion of rows to extract. <code>with_ties</code>: If <code>True</code>, extract all rows with the maximum value. \u2003\u2003\u2003\u2003If \"first\", extract the first row with the maximum value. \u2003\u2003\u2003\u2003If \"last\", extract the last row with the maximum value.</p>"},{"location":"notebooks/slice/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The subset dataframe</p>"},{"location":"notebooks/slice/#slice_min","title":"\u2605 slice_min\u00b6","text":""},{"location":"notebooks/slice/#extract-rows-with-the-minimum-value","title":"Extract rows with the minimum value\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/slice.html</p>"},{"location":"notebooks/slice/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>order_by</code>: A variable or function of variables to order by. <code>n</code>: Number of rows to extract. <code>prop</code>: Proportion of rows to extract. <code>with_ties</code>: If <code>True</code>, extract all rows with the minimum value. \u2003\u2003\u2003\u2003If \"first\", extract the first row with the minimum value. \u2003\u2003\u2003\u2003If \"last\", extract the last row with the minimum value.</p>"},{"location":"notebooks/slice/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The subset dataframe</p>"},{"location":"notebooks/slice/#slice_sample","title":"\u2605 slice_sample\u00b6","text":""},{"location":"notebooks/slice/#extract-rows-by-sampling","title":"Extract rows by sampling\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/slice.html</p>"},{"location":"notebooks/slice/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>n</code>: Number of rows to extract. <code>prop</code>: Proportion of rows to extract. <code>weight_by</code>: A variable or function of variables to weight by. <code>replace</code>: If <code>True</code>, sample with replacement.</p>"},{"location":"notebooks/slice/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The subset dataframe</p>"},{"location":"notebooks/slice/#slice_tail","title":"\u2605 slice_tail\u00b6","text":""},{"location":"notebooks/slice/#extract-the-last-rows","title":"Extract the last rows\u00b6","text":"<p>The original API: https://dplyr.tidyverse.org/reference/slice.html</p>"},{"location":"notebooks/slice/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>n</code>: Number of rows to extract. <code>prop</code>: Proportion of rows to extract.</p>"},{"location":"notebooks/slice/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The subset dataframe</p>"},{"location":"notebooks/summarise/","title":"summarise","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/summarise.html\n%run nb_helpers.py\n\nfrom datar.data import mtcars, starwars\nfrom datar.all import *\n\nnb_header(summarise)\n</pre> # https://dplyr.tidyverse.org/reference/summarise.html %run nb_helpers.py  from datar.data import mtcars, starwars from datar.all import *  nb_header(summarise) Try this notebook on binder. In\u00a0[8]: Copied! <pre>mtcars &gt;&gt; summarise(mean=mean(f.disp), n=n())\n</pre> mtcars &gt;&gt; summarise(mean=mean(f.disp), n=n()) Out[8]: mean n &lt;float64&gt; &lt;int64&gt; 0 230.721875 32 In\u00a0[9]: Copied! <pre>mtcars &gt;&gt; \\\n  group_by(f.cyl) &gt;&gt; \\\n  summarise(mean=mean(f.disp), n=n()) \n</pre> mtcars &gt;&gt; \\   group_by(f.cyl) &gt;&gt; \\   summarise(mean=mean(f.disp), n=n())  Out[9]: cyl mean n &lt;int64&gt; &lt;float64&gt; &lt;int64&gt; 0 6 183.314286 7 1 4 105.136364 11 2 8 353.100000 14 In\u00a0[2]: Copied! <pre>mtcars &gt;&gt; \\\n   group_by(f.cyl) &gt;&gt; \\\n   summarise(qs=quantile(f.disp, c(0.25, 0.75)), prob=c(0.25, 0.75)) \n</pre> mtcars &gt;&gt; \\    group_by(f.cyl) &gt;&gt; \\    summarise(qs=quantile(f.disp, c(0.25, 0.75)), prob=c(0.25, 0.75))   <pre>[2022-12-02 14:46:41][datar][   INFO] `summarise()` has grouped output by ['cyl'] (override with `_groups` argument)\n</pre> Out[2]: cyl qs prob &lt;int64&gt; &lt;object&gt; &lt;float64&gt; 0 6 [160.0, 196.3] 0.25 1 6 [160.0, 196.3] 0.75 2 4 [78.85, 120.65] 0.25 3 4 [78.85, 120.65] 0.75 4 8 [301.75, 390.0] 0.25 5 8 [301.75, 390.0] 0.75 <p>TibbleGrouped: cyl (n=3) </p> In\u00a0[3]: Copied! <pre>with options_context(dplyr_summarise_inform=False):\n    mtcars &gt;&gt; \\\n        group_by(f.cyl) &gt;&gt; \\\n        summarise(qs=quantile(f.disp, c(0.25, 0.75)), prob=c(0.25, 0.75)) \n</pre> with options_context(dplyr_summarise_inform=False):     mtcars &gt;&gt; \\         group_by(f.cyl) &gt;&gt; \\         summarise(qs=quantile(f.disp, c(0.25, 0.75)), prob=c(0.25, 0.75))   Out[3]: cyl qs prob &lt;int64&gt; &lt;object&gt; &lt;float64&gt; 0 6 [160.0, 196.3] 0.25 1 6 [160.0, 196.3] 0.75 2 4 [78.85, 120.65] 0.25 3 4 [78.85, 120.65] 0.75 4 8 [301.75, 390.0] 0.25 5 8 [301.75, 390.0] 0.75 <p>TibbleGrouped: cyl (n=3) </p> In\u00a0[4]: Copied! <pre>mtcars &gt;&gt; \\\n  group_by(f.cyl, f.vs) &gt;&gt; \\\n  summarise(cyl_n = n()) &gt;&gt; \\\n  group_vars()\n</pre> mtcars &gt;&gt; \\   group_by(f.cyl, f.vs) &gt;&gt; \\   summarise(cyl_n = n()) &gt;&gt; \\   group_vars() <pre>[2022-12-02 14:46:52][datar][   INFO] `summarise()` has grouped output by ['cyl'] (override with `_groups` argument)\n</pre> Out[4]: <pre>['cyl']</pre> In\u00a0[5]: Copied! <pre># Unlike dplyr's summarise, f.disp can be reused.\nmtcars &gt;&gt; \\\n  group_by(f.cyl) &gt;&gt; \\\n  summarise(disp=mean(f.disp), sd=sd(f.disp)) \n</pre> # Unlike dplyr's summarise, f.disp can be reused. mtcars &gt;&gt; \\   group_by(f.cyl) &gt;&gt; \\   summarise(disp=mean(f.disp), sd=sd(f.disp))  Out[5]: cyl disp sd &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; 0 6 183.314286 NaN 1 4 105.136364 NaN 2 8 353.100000 NaN In\u00a0[6]: Copied! <pre># Create temporary variable\nmtcars &gt;&gt; \\\n  group_by(f.cyl) &gt;&gt; \\\n  summarise(_disp_m2=mean(f.disp), disp_m2=f._disp_m2 * 2) \n</pre> # Create temporary variable mtcars &gt;&gt; \\   group_by(f.cyl) &gt;&gt; \\   summarise(_disp_m2=mean(f.disp), disp_m2=f._disp_m2 * 2)  Out[6]: cyl disp_m2 &lt;int64&gt; &lt;float64&gt; 0 6 366.628571 1 4 210.272727 2 8 706.200000 In\u00a0[8]: Copied! <pre>var = \"mass\"\nstarwars &gt;&gt; summarise(avg = mean(f[var]))\n</pre> var = \"mass\" starwars &gt;&gt; summarise(avg = mean(f[var])) Out[8]: avg &lt;float64&gt; 0 97.311864"},{"location":"notebooks/summarise/#summarise","title":"\u2605 summarise\u00b6","text":""},{"location":"notebooks/summarise/#summarise-a-data-frame","title":"Summarise a data frame.\u00b6","text":"<p>See original API https://dplyr.tidyverse.org/reference/summarise.html</p>"},{"location":"notebooks/summarise/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>_groups</code>: Grouping structure of the result. \u2003\u2003\u2003\u2003- \"drop_last\": dropping the last level of grouping.</p> <p>\u2003\u2003\u2003\u2003- \"drop\": All levels of grouping are dropped.</p> <p>\u2003\u2003\u2003\u2003- \"keep\": Same grouping structure as _data.</p> <p>\u2003\u2003\u2003\u2003- \"rowwise\": Each row is its own group.</p> <p> <code>*args</code>: and <code>**kwargs</code>: Name-value pairs, where value is the summarized \u2003\u2003\u2003\u2003data for each group</p>"},{"location":"notebooks/summarise/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A data frame with the summarised columns</p>"},{"location":"notebooks/tibble/","title":"tibble","text":"In\u00a0[2]: Copied! <pre># https://tibble.tidyverse.org/reference/tibble.html\n# https://tibble.tidyverse.org/reference/tribble.html\n%run nb_helpers.py\n\nfrom datar import f\nfrom datar.tibble import tibble, tibble_row, tribble\nfrom datar.base import diag, runif\nfrom datar.dplyr import mutate\n\nnb_header(tibble, tibble_row, tribble)\n</pre> # https://tibble.tidyverse.org/reference/tibble.html # https://tibble.tidyverse.org/reference/tribble.html %run nb_helpers.py  from datar import f from datar.tibble import tibble, tibble_row, tribble from datar.base import diag, runif from datar.dplyr import mutate  nb_header(tibble, tibble_row, tribble) Try this notebook on binder. In\u00a0[3]: Copied! <pre>a = range(5)\ntibble(a=a, b=f.a*2)\n</pre> a = range(5) tibble(a=a, b=f.a*2) Out[3]: a b &lt;int64&gt; &lt;int64&gt; 0 0 0 1 1 2 2 2 4 3 3 6 4 4 8 In\u00a0[4]: Copied! <pre>tibble(a=a, b=f.a * 2, c=1)\n</pre> tibble(a=a, b=f.a * 2, c=1) Out[4]: a b c &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 0 0 1 1 1 2 1 2 2 4 1 3 3 6 1 4 4 8 1 In\u00a0[5]: Copied! <pre>tibble(x=runif(10), y=f.x*2)\n</pre> tibble(x=runif(10), y=f.x*2) Out[5]: x y &lt;float64&gt; &lt;float64&gt; 0 0.639511 1.279022 1 0.573888 1.147776 2 0.123471 0.246943 3 0.807206 1.614412 4 0.159120 0.318241 5 0.893697 1.787394 6 0.897584 1.795168 7 0.159780 0.319559 8 0.919717 1.839433 9 0.304561 0.609122 In\u00a0[6]: Copied! <pre>x = 1\nwith try_catch():\n    tibble(x, x)\n</pre> x = 1 with try_catch():     tibble(x, x) <pre>[NameNonUniqueError] Names must be unique: 1\n</pre> In\u00a0[7]: Copied! <pre>tibble(x, x, _name_repair=\"unique\")\n</pre> tibble(x, x, _name_repair=\"unique\") <pre>[2022-12-02 14:48:49][datar][WARNING] New names:\n[2022-12-02 14:48:49][datar][WARNING] * '1' -&gt; '1__0'\n[2022-12-02 14:48:49][datar][WARNING] * '1' -&gt; '1__1'\n</pre> Out[7]: 1__0 1__1 &lt;int64&gt; &lt;int64&gt; 0 1 1 In\u00a0[8]: Copied! <pre>tibble(x, x, _name_repair=\"minimal\") # duplicated columns allowed\n</pre> tibble(x, x, _name_repair=\"minimal\") # duplicated columns allowed Out[8]: 1 1 &lt;int64&gt; &lt;int64&gt; 0 1 1 In\u00a0[9]: Copied! <pre>a = 1\ntibble(a * 1, a * 2, _name_repair=\"universal\")\n</pre> a = 1 tibble(a * 1, a * 2, _name_repair=\"universal\") <pre>[2022-12-02 14:49:00][datar][WARNING] New names:\n[2022-12-02 14:49:00][datar][WARNING] * '1' -&gt; '_1'\n[2022-12-02 14:49:00][datar][WARNING] * '2' -&gt; '_2'\n</pre> Out[9]: _1 _2 &lt;int64&gt; &lt;int64&gt; 0 1 2 In\u00a0[10]: Copied! <pre>from typing import Iterable\n# use annotation to tell it's all names\n# not only a single name\ndef make_unique(names: Iterable[str]): \n    new_names = []\n    for name in names:\n        name_count = new_names.count(name)\n        if name_count == 0:\n            new_names.append(name)\n        else:\n            new_names.append(f'{name}_{name_count}')\n    return new_names\n\ntibble(a, a, _name_repair=make_unique)\n</pre> from typing import Iterable # use annotation to tell it's all names # not only a single name def make_unique(names: Iterable[str]):      new_names = []     for name in names:         name_count = new_names.count(name)         if name_count == 0:             new_names.append(name)         else:             new_names.append(f'{name}_{name_count}')     return new_names  tibble(a, a, _name_repair=make_unique) Out[10]: 1 1_1 &lt;int64&gt; &lt;int64&gt; 0 1 1 In\u00a0[11]: Copied! <pre># if not annotation specified\n# assuming a single name\ndef fix_names(name):\n    import re\n    return re.sub(r'\\s+', '_', name)\n\n\ntibble(a + 1, a + 2, _name_repair = fix_names)\n</pre> # if not annotation specified # assuming a single name def fix_names(name):     import re     return re.sub(r'\\s+', '_', name)   tibble(a + 1, a + 2, _name_repair = fix_names) Out[11]: 2 3 &lt;int64&gt; &lt;int64&gt; 0 2 3 In\u00a0[12]: Copied! <pre>tibble(x, x, _name_repair=[\"a\", \"b\"])\n</pre> tibble(x, x, _name_repair=[\"a\", \"b\"]) Out[12]: a b &lt;int64&gt; &lt;int64&gt; 0 1 1 In\u00a0[13]: Copied! <pre>tibble(\n  tibble(\n    b = [4,5,6],\n    c = [7,8,9]\n  ),\n  a = range(3),\n  d = f.b\n)\n</pre> tibble(   tibble(     b = [4,5,6],     c = [7,8,9]   ),   a = range(3),   d = f.b ) Out[13]: b c a d &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 4 7 0 4 1 5 8 1 5 2 6 9 2 6 In\u00a0[14]: Copied! <pre>s = tibble(diag(1, 4))\nt = tibble(s.iloc[:, :2], _name_repair=['x', 'y'])\ntibble(\n  a=range(4),\n  b=s,\n  c=t\n)\n</pre> s = tibble(diag(1, 4)) t = tibble(s.iloc[:, :2], _name_repair=['x', 'y']) tibble(   a=range(4),   b=s,   c=t ) Out[14]: a b$0 b$1 b$2 b$3 c$x$0 c$x$1 &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; &lt;int64&gt; 0 0 1 0 0 0 1 0 1 1 0 1 0 0 0 1 2 2 0 0 1 0 0 0 3 3 0 0 0 1 0 0 In\u00a0[15]: Copied! <pre>with try_catch():\n    tibble(a=range(3), b=range(4))\n</pre> with try_catch():     tibble(a=range(3), b=range(4)) <pre>[ValueError] `b` must be size [1 3], not 4.\n</pre> In\u00a0[16]: Copied! <pre>tibble(_dotted = 3, _name_repair=lambda x: x.replace('_', '.'))\n</pre> tibble(_dotted = 3, _name_repair=lambda x: x.replace('_', '.')) Out[16]: .dotted &lt;int64&gt; 0 3 In\u00a0[17]: Copied! <pre>x = 3\ntibble(x=1, y=f.x)\n</pre> x = 3 tibble(x=1, y=f.x) Out[17]: x y &lt;int64&gt; &lt;int64&gt; 0 1 1 In\u00a0[18]: Copied! <pre>tibble(x=1, y=x)\n</pre> tibble(x=1, y=x) Out[18]: x y &lt;int64&gt; &lt;int64&gt; 0 1 3 In\u00a0[19]: Copied! <pre>tribble(\n  f.colA, f.colB,\n  \"a\",    1,\n  \"b\",    2,\n  \"c\",    3\n)\n</pre> tribble(   f.colA, f.colB,   \"a\",    1,   \"b\",    2,   \"c\",    3 ) Out[19]: colA colB &lt;object&gt; &lt;int64&gt; 0 a 1 1 b 2 2 c 3 In\u00a0[20]: Copied! <pre>tribble(\n  f.x,  f.y,\n  \"a\",  [1,2,3],\n  \"b\",  [4,5,6]\n)\n</pre> tribble(   f.x,  f.y,   \"a\",  [1,2,3],   \"b\",  [4,5,6] ) Out[20]: x y &lt;object&gt; &lt;object&gt; 0 a [1, 2, 3] 1 b [4, 5, 6] In\u00a0[21]: Copied! <pre>tibble_row(a=1, b=[[2,3]])\n</pre> tibble_row(a=1, b=[[2,3]]) Out[21]: a b &lt;int64&gt; &lt;object&gt; 0 1 [2, 3] In\u00a0[22]: Copied! <pre># inside a verb\n\ntibble(x=1) &gt;&gt; mutate(y=tibble(y=f.x))\n</pre> # inside a verb  tibble(x=1) &gt;&gt; mutate(y=tibble(y=f.x)) Out[22]: x y$y &lt;int64&gt; &lt;int64&gt; 0 1 1"},{"location":"notebooks/tibble/#tibble","title":"\u2605 tibble\u00b6","text":""},{"location":"notebooks/tibble/#constructs-a-data-frame","title":"Constructs a data frame\u00b6","text":""},{"location":"notebooks/tibble/#args","title":"Args:\u00b6","text":"<p> <code>*args</code>: and <code>**kwargs</code>: A set of name-value pairs. <code>_name_repair</code>: treatment of problematic column names: \u2003\u2003\u2003\u2003- \"minimal\": No name repair or checks, beyond basic existence,</p> <p>\u2003\u2003\u2003\u2003- \"unique\": Make sure names are unique and not empty,</p> <p>\u2003\u2003\u2003\u2003- \"check_unique\": (default value), no name repair, \u2003\u2003\u2003\u2003\u2003\u2003but check they are unique,</p> <p>\u2003\u2003\u2003\u2003- \"universal\": Make the names unique and syntactic</p> <p>\u2003\u2003\u2003\u2003- a function: apply custom name repair</p> <p> <code>_rows</code>: Number of rows of a 0-col dataframe when args and kwargs are \u2003\u2003\u2003\u2003not provided. When args or kwargs are provided, this is ignored.</p> <p> <code>_dtypes</code>: The dtypes for each columns to convert to. <code>_drop_index</code>: Whether drop the index for the final data frame <code>_index</code>: The new index of the output frame</p>"},{"location":"notebooks/tibble/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A constructed tibble</p>"},{"location":"notebooks/tibble/#tibble_row","title":"\u2605 tibble_row\u00b6","text":""},{"location":"notebooks/tibble/#constructs-a-data-frame-that-is-guaranteed-to-occupy-one-row","title":"Constructs a data frame that is guaranteed to occupy one row.\u00b6","text":"<p>Scalar values will be wrapped with <code>[]</code></p>"},{"location":"notebooks/tibble/#args","title":"Args:\u00b6","text":"<p> <code>*args</code>: and <code>**kwargs</code>: A set of name-value pairs. <code>_name_repair</code>: treatment of problematic column names: \u2003\u2003\u2003\u2003- \"minimal\": No name repair or checks, beyond basic existence,</p> <p>\u2003\u2003\u2003\u2003- \"unique\": Make sure names are unique and not empty,</p> <p>\u2003\u2003\u2003\u2003- \"check_unique\": (default value), no name repair, \u2003\u2003\u2003\u2003\u2003\u2003but check they are unique,</p> <p>\u2003\u2003\u2003\u2003- \"universal\": Make the names unique and syntactic</p> <p>\u2003\u2003\u2003\u2003- a function: apply custom name repair</p>"},{"location":"notebooks/tibble/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A constructed dataframe</p>"},{"location":"notebooks/tibble/#tribble","title":"\u2605 tribble\u00b6","text":""},{"location":"notebooks/tibble/#create-dataframe-using-an-easier-to-read-row-by-row-layout","title":"Create dataframe using an easier to read row-by-row layout\u00b6","text":"<p>Unlike original API that uses formula (<code>f.col</code>) to indicate the column names, we use <code>f.col</code> to indicate them.</p>"},{"location":"notebooks/tibble/#args","title":"Args:\u00b6","text":"<p> <code>*dummies</code>: Arguments specifying the structure of a dataframe \u2003\u2003\u2003\u2003Variable names should be specified with <code>f.name</code></p> <p> <code>_dtypes</code>: The dtypes for each columns to convert to.</p>"},{"location":"notebooks/tibble/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003A dataframe</p>"},{"location":"notebooks/uncount/","title":"uncount","text":"In\u00a0[1]: Copied! <pre># https://tidyr.tidyverse.org/reference/uncount.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(uncount)\n</pre> # https://tidyr.tidyverse.org/reference/uncount.html %run nb_helpers.py  from datar.all import *  nb_header(uncount) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(x = c(\"a\", \"b\"), n = c(1, 2))\ndf &gt;&gt; uncount(f.n)\n</pre> df = tibble(x = c(\"a\", \"b\"), n = c(1, 2)) df &gt;&gt; uncount(f.n) Out[2]: x &lt;object&gt; 0 a 1 b 2 b In\u00a0[3]: Copied! <pre>df &gt;&gt; uncount(f.n, _id=\"id\")\n</pre> df &gt;&gt; uncount(f.n, _id=\"id\") Out[3]: id x &lt;int64&gt; &lt;object&gt; 0 0 a 1 1 b 2 1 b In\u00a0[4]: Copied! <pre>uncount(df, 2)\n</pre> uncount(df, 2) Out[4]: x n &lt;object&gt; &lt;int64&gt; 0 a 1 1 a 1 2 b 2 3 b 2 In\u00a0[5]: Copied! <pre>df &gt;&gt; uncount(2//f.n)\n</pre> df &gt;&gt; uncount(2//f.n) Out[5]: x &lt;object&gt; 0 a 1 a 2 b In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/uncount/#uncount","title":"\u2605 uncount\u00b6","text":""},{"location":"notebooks/uncount/#duplicating-rows-according-to-a-weighting-variable","title":"Duplicating rows according to a weighting variable\u00b6","text":""},{"location":"notebooks/uncount/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: A data frame <code>weights</code>: A vector of weights. Evaluated in the context of data <code>_remove</code>: If TRUE, and weights is the name of a column in data, \u2003\u2003\u2003\u2003then this column is removed.</p> <p> <code>_id</code>: Supply a string to create a new variable which gives a \u2003\u2003\u2003\u2003unique identifier for each created row (0-based).</p>"},{"location":"notebooks/uncount/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003dataframe with rows repeated.</p>"},{"location":"notebooks/unite/","title":"unite","text":"In\u00a0[1]: Copied! <pre># https://tidyr.tidyverse.org/reference/unite.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(unite)\n</pre> # https://tidyr.tidyverse.org/reference/unite.html %run nb_helpers.py  from datar.all import *  nb_header(unite)  Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = expand_grid(x=c(\"a\", NA), y=c(\"b\", NA))\ndf\n</pre> df = expand_grid(x=c(\"a\", NA), y=c(\"b\", NA)) df Out[2]: x y &lt;object&gt; &lt;object&gt; 0 a b 1 a NaN 2 NaN b 3 NaN NaN In\u00a0[3]: Copied! <pre>df &gt;&gt; unite(\"z\", c(f.x, f.y), remove=False)\n</pre> df &gt;&gt; unite(\"z\", c(f.x, f.y), remove=False) Out[3]: z x y &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 a_b a b 1 a a NaN 2 b NaN b 3 NaN NaN In\u00a0[4]: Copied! <pre>df &gt;&gt; unite(\"z\", [0, 1], na_rm=True, remove=False)\n</pre> df &gt;&gt; unite(\"z\", [0, 1], na_rm=True, remove=False) Out[4]: z x y &lt;object&gt; &lt;object&gt; &lt;object&gt; 0 a_b a b 1 a a NaN 2 b NaN b 3 NaN NaN In\u00a0[5]: Copied! <pre>df &gt;&gt; \\\n  unite(\"xy\", c(f.x, f.y)) &gt;&gt; \\\n  separate(f.xy, c(\"x\", \"y\"))\n</pre> df &gt;&gt; \\   unite(\"xy\", c(f.x, f.y)) &gt;&gt; \\   separate(f.xy, c(\"x\", \"y\")) <pre>[2022-12-02 14:51:25][datar][WARNING] Expected 2 pieces. Missing pieces filled with `NA` in 3 rows ['a', 'b', ''].\n</pre> Out[5]: x y &lt;object&gt; &lt;object&gt; 0 a b 1 a NaN 2 b NaN 3 NaN"},{"location":"notebooks/unite/#unite","title":"\u2605 unite\u00b6","text":""},{"location":"notebooks/unite/#unite-multiple-columns-into-one-by-pasting-strings-together","title":"Unite multiple columns into one by pasting strings together\u00b6","text":""},{"location":"notebooks/unite/#args","title":"Args:\u00b6","text":"<p> <code>data</code>: A data frame. <code>col</code>: The name of the new column, as a string or symbol. <code>*columns</code>: Columns to unite <code>sep</code>: Separator to use between values. <code>remove</code>: If True, remove input columns from output data frame. <code>na_rm</code>: If True, missing values will be remove prior to uniting \u2003\u2003\u2003\u2003each value.</p>"},{"location":"notebooks/unite/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The dataframe with selected columns united</p>"},{"location":"notebooks/with_groups/","title":"with_groups","text":"In\u00a0[1]: Copied! <pre># https://dplyr.tidyverse.org/reference/with_groups.html\n%run nb_helpers.py\n\nfrom datar.all import *\n\nnb_header(with_groups)\n</pre> # https://dplyr.tidyverse.org/reference/with_groups.html %run nb_helpers.py  from datar.all import *  nb_header(with_groups) Try this notebook on binder. In\u00a0[2]: Copied! <pre>df = tibble(g=c(1, 1, 2, 2, 3), x=runif(5))\ndf &gt;&gt; with_groups(f.g, mutate, x_mean = mean(f.x)) \n</pre> df = tibble(g=c(1, 1, 2, 2, 3), x=runif(5)) df &gt;&gt; with_groups(f.g, mutate, x_mean = mean(f.x))  Out[2]: g x x_mean &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; 0 1 0.244611 0.525006 1 1 0.805402 0.525006 2 2 0.862707 0.829213 3 2 0.795719 0.829213 4 3 0.812910 0.812910 <p>TibbleGrouped: g (n=3) </p> In\u00a0[3]: Copied! <pre>df &gt;&gt; with_groups(f.g, lambda df: df &gt;&gt; mutate(x1 = first(f.x))) \n</pre> df &gt;&gt; with_groups(f.g, lambda df: df &gt;&gt; mutate(x1 = first(f.x)))  Out[3]: g x x1 &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; 0 1 0.244611 0.244611 1 1 0.805402 0.244611 2 2 0.862707 0.862707 3 2 0.795719 0.862707 4 3 0.812910 0.812910 <p>TibbleGrouped: g (n=3) </p> In\u00a0[4]: Copied! <pre>df &gt;&gt; \\\n  group_by(f.g) &gt;&gt; \\\n  with_groups(None, mutate, x_mean = mean(f.x))\n</pre> df &gt;&gt; \\   group_by(f.g) &gt;&gt; \\   with_groups(None, mutate, x_mean = mean(f.x)) Out[4]: g x x_mean &lt;int64&gt; &lt;float64&gt; &lt;float64&gt; 0 1 0.244611 0.70427 1 1 0.805402 0.70427 2 2 0.862707 0.70427 3 2 0.795719 0.70427 4 3 0.812910 0.70427 In\u00a0[5]: Copied! <pre>df &gt;&gt; \\\n  group_by(f.g) &gt;&gt; \\\n  with_groups(None, mutate, g=None)\n</pre> df &gt;&gt; \\   group_by(f.g) &gt;&gt; \\   with_groups(None, mutate, g=None) Out[5]: x &lt;float64&gt; 0 0.244611 1 0.805402 2 0.862707 3 0.795719 4 0.812910"},{"location":"notebooks/with_groups/#with_groups","title":"\u2605 with_groups\u00b6","text":""},{"location":"notebooks/with_groups/#modify-the-grouping-variables-for-a-single-operation","title":"Modify the grouping variables for a single operation.\u00b6","text":""},{"location":"notebooks/with_groups/#args","title":"Args:\u00b6","text":"<p> <code>_data</code>: A data frame <code>_groups</code>: columns passed by group_by \u2003\u2003\u2003\u2003Use None to temporarily ungroup.</p> <p> <code>_func</code>: Function to apply to regrouped data.</p>"},{"location":"notebooks/with_groups/#returns","title":"Returns:\u00b6","text":"<p>\u2003\u2003The new data frame with operations applied.</p>"},{"location":"reference-maps/ALL/","title":"ALL","text":"Module Description Reference <code>base</code> APIs ported from <code>r-base/r-stats/r-utils</code> # # # <code>dplyr</code> APIs ported from <code>tidyverse/dplyr</code> <code>tidyr</code> APIs ported from <code>tidyverse/tidyr</code> <code>tibble</code> APIs ported from <code>tidyverse/tibble</code> <code>forcats</code> APIs ported from <code>tidyverse/forcats</code> # # # <code>datasets</code> Datasets collected from <code>tidyverse</code> or other related packages # # # <code>datar</code> Datar-specific verbs/functions"},{"location":"reference-maps/base/","title":"Base","text":""},{"location":"reference-maps/base/#reference-of-datarbase","title":"Reference of <code>datar.base</code>","text":"<p>See here for APIs ported from <code>r-stats</code> and here for APIs ported from <code>r-utils</code></p> <p>Legend:</p> Sample Status normal API that is regularly ported strike-through API that is not ported, or not an API originally bold API that is unique in <code>datar</code> italic Working in process"},{"location":"reference-maps/base/#constants","title":"Constants","text":"API Description Notebook example <code>pi</code> the ratio of the circumference of a circle to its diameter. <code>letters</code> the 26 lower-case letters of the Roman alphabet <code>LETTERS</code> the 26 upper-case letters of the Roman alphabet <code>month.abb</code> the three-letter abbreviations for the English month names <code>month.name</code> the English names for the months of the year"},{"location":"reference-maps/base/#options","title":"Options","text":"API Description Notebook example <code>options</code> Allow the user to set and examine a variety of global options <code>get_option()</code> Get the value of a certain option (R's <code>getOption()</code>) <code>options_context()</code> A context manager to temporarily modify the options"},{"location":"reference-maps/base/#arithmetic-functions","title":"Arithmetic functions","text":"API Description Notebook example <code>mean()</code> Calculate the mean of the values <code>median()</code> Calculate the median of the values <code>min()</code> Calculate the min of the values <code>max()</code> Calculate the max of the values <code>pmin()</code> Calculate the min of the values rowwisely <code>pmax()</code> Calculate the max of the values rowwisely <code>sum()</code> Calculate the sum of the values <code>abs()</code> Calculate the absolute values of the values <code>round()</code> Round the numbers <code>var()</code> Calculate the variance of the values <code>ceiling()</code> Get the ceiling integers of the numbers <code>floor()</code> Get the floor integers of the numbers <code>sqrt()</code> Get the square root of the numbers <code>cov()</code> Calculate the covariance of the values <code>prod()</code> Calculate Product of the input <code>sign()</code> Get the signs of the corresponding elements of x <code>signif()</code> Rounds the values in its first argument to the specified number of significant digits <code>trunc()</code> Get the integers truncated for each element in x <code>exp()</code> Calculates the power of natural number <code>log()</code> Computes logarithms, by default natural logarithm <code>log2()</code> Computes logarithms with base 2 <code>log10()</code> Computes logarithms with base 10 <code>log1p()</code> Computes log(1+x) <code>quantile()</code> Produces sample quantiles corresponding to the given probabilities. <code>sd()</code>, <code>std()</code> Computes the standard deviation of the values <code>weighted_mean()</code> Computes the weighted mean of the values <code>col_sums()</code> Computes column sums of a dataframe <code>row_sums()</code> Computes row sums of a dataframe <code>col_means()</code> Computes column means of a dataframe <code>row_means()</code> Computes row means of a dataframe <code>col_sds()</code> Computes column sds of a dataframe <code>row_sds()</code> Computes row sds of a dataframe <code>col_medians()</code> Computes column medians of a dataframe <code>row_medians()</code> Computes row medians of a dataframe"},{"location":"reference-maps/base/#bessel-functions","title":"Bessel functions","text":"API Description Notebook example <code>bessel_i()</code> Bessel Functions of integer and fractional order of first kind <code>bessel_k()</code> Bessel Functions of integer and fractional order of second kind <code>bessel_j()</code> Modified Bessel functions of first kind <code>bessel_y()</code> Modified Bessel functions of third kind"},{"location":"reference-maps/base/#casting-values-between-types","title":"Casting values between types","text":"API Description Notebook example <code>as_integer()</code> <code>as_int</code> Cast data to integer <code>as_double()</code> Cast data to double (<code>numpy.float64</code>) <code>as_float()</code> Cast data to float (<code>numpy.float_</code>) <code>as_numeric()</code> Cast data to numeric"},{"location":"reference-maps/base/#complex-numbers","title":"Complex numbers","text":"API Description Notebook example <code>re()</code> Get the real part of a complex number <code>mod()</code> Get the modulus of a complex number <code>im()</code> Get the imaginary part of a complex number <code>arg()</code> Get the argument of a complex number <code>conj()</code> Get the complex conjugate of a complex number <code>is_complex()</code> Test if data is complex number <code>as_complex()</code> Cast data to a complex number"},{"location":"reference-maps/base/#cumulativate-functions","title":"Cumulativate functions","text":"API Description Notebook example <code>cumsum()</code> Cummulative sum <code>cumprod()</code> Cummulative product <code>cummin()</code> Cummulative min <code>cummax()</code> Cummulative max"},{"location":"reference-maps/base/#date-functions","title":"Date functions","text":"API Description Notebook example <code>as_date()</code> Cast data to date <code>as_pd_date()</code> Alias of <code>pandas.to_datetime()</code>"},{"location":"reference-maps/base/#factor-data","title":"Factor data","text":"API Description Notebook example <code>factor()</code> Construct factor <code>droplevels()</code> Drop unused levels <code>levels()</code> Get levels of factors <code>is_factor()</code> <code>is_categorical</code> Test if data is factor <code>as_factor()</code> <code>as_categorical</code> Cast data to factor <code>is_ordered()</code> Check if a factor is ordered <code>nlevels()</code> Get number of levels of a factor <code>ordered()</code> Create an ordered factor"},{"location":"reference-maps/base/#logicalboolean-values","title":"Logical/Boolean values","text":"API Description Notebook example <code>TRUE</code> Logical true <code>FALSE</code> Logical false <code>is_true()</code> Test if data is scalar true (R's <code>isTRUE</code>) <code>is_false()</code> Test if data is scalar false (R's <code>FALSE</code>) <code>is_logical()</code> <code>is_bool()</code> Test if data is logical/boolean <code>as_logical()</code> <code>as_bool()</code> Cast data to logical/boolean"},{"location":"reference-maps/base/#na-missing-values","title":"NA (missing values)","text":"API Description Notebook example <code>Inf</code> Infinite number <code>NA</code> Missing value <code>NaN</code> Missing value, same as <code>NA</code> <code>is_na()</code> Test if data is NA <code>any_na()</code> Test if any element is NA <code>is_finite()</code> Test if x is finite <code>is_infinite()</code> Test if x is infinite <code>is_nan()</code> Test if x is nan"},{"location":"reference-maps/base/#null","title":"NULL","text":"API Description Notebook example <code>NULL</code> NULL value <code>is_null()</code> Test if data is null <code>as_null()</code> Cast anything to NULL"},{"location":"reference-maps/base/#random","title":"Random","text":"API Description Notebook example <code>set_seed()</code> Set the randomization seed"},{"location":"reference-maps/base/#functions-to-create-and-manipulate-sequences","title":"Functions to create and manipulate sequences","text":"API Description Notebook example <code>c()</code> Collection of data <code>seq()</code> Generate sequence <code>seq_len()</code> Generate sequence with length <code>seq_along()</code> Generate sequence along with another sequence <code>rev()</code> Reverse a sequence <code>rep()</code> Generate sequence with repeats <code>lengths()</code> Get the length of elements in the sequence <code>unique()</code> Get the unique elements <code>sample()</code> Sample the elements from sequence <code>length()</code> Get the length of data <code>match()</code> match returns a vector of the positions of (first) matches of its first argument in its second. <code>rank()</code> Returns the sample ranks of the values in a vector. <code>order()</code> Returns a permutation which rearranges its first argument into ascending or descending order <code>sort()</code> Sorting or Ordering Vectors"},{"location":"reference-maps/base/#special-functions","title":"Special functions","text":"API Description Notebook example <code>beta()</code> Beta function <code>lbeta()</code> Natural logarithm of beta function <code>gamma()</code> Gamma function <code>lgamma()</code> Natural logarithm of gamma function <code>digamma()</code> the first derivatives of the logarithm of the gamma function. <code>trigamma()</code> the second derivatives of the logarithm of the gamma function. <code>psigamma()</code> polygamma funnction <code>choose()</code> binomial coefficients <code>lchoose()</code> the logarithms of binomial coefficients. <code>factorial()</code> factorial <code>lfactorial()</code> Natural logarithm of factorial"},{"location":"reference-maps/base/#string-functions","title":"String functions","text":"API Description Notebook example <code>is_character()</code> <code>is_str</code> <code>is_string</code> Test if data is string <code>as_character()</code> <code>as_str</code> <code>as_string</code> Cast data to string <code>grep()</code> Test if pattern in string <code>grepl()</code> Logical version of <code>grep</code> <code>sub()</code> Replace substrings in strings <code>gsub()</code> Replace all matched substring in strings <code>nchar()</code> Get length of string <code>nzhcar()</code> Test if string is not empty <code>paste()</code> Concatenate strings <code>paste0()</code> Concatenate strings with <code>sep=''</code> <code>sprintf()</code> C-style string formatting <code>substr()</code> Get substring <code>substring()</code> Get substring with a start only <code>strsplit()</code> Split strings with delimiter <code>startswith()</code> Test if strings start with given prefix <code>endswith()</code> Test if strings end with given suffix <code>strtoi()</code> Convert strings to integers <code>chartr()</code> Replace characters in strings <code>tolower()</code> Transform strings to lower case <code>toupper()</code> Transform strings to upper case <code>trimws()</code> Remove leading and/or trailing whitespace from character strings."},{"location":"reference-maps/base/#table","title":"Table","text":"API Description Notebook example <code>table()</code> Cross Tabulation and Table Creation <code>tabulate()</code> Takes the integer-valued vector <code>bin</code> and counts the number of times each integer occurs in it."},{"location":"reference-maps/base/#testing-value-types","title":"Testing value types","text":"API Description Notebook example <code>is_double()</code> <code>is_float()</code> Test if data is double or float (<code>numpy.float_</code>) <code>is_integer()</code> <code>is_int()</code> Test if data is integer <code>is_numeric()</code> Test if data is numeric <code>is_atomic()</code> Test is data is atomic [<code>is_element(),</code>is_in()<code>][96]|Test if value is an element of an array (R's</code>%in`)"},{"location":"reference-maps/base/#trigonometric-and-hyper-bolic-functions","title":"Trigonometric and hyper bolic functions","text":"API Description Notebook example <code>cos()</code> cosine <code>sin()</code> sine <code>tan()</code> tangent <code>acos()</code> Arc-cosine <code>asin()</code> Arc-sine <code>atan()</code> Arc-tangent <code>atan2()</code> <code>atan(y/x)</code> <code>cospi()</code> <code>cos(pi*x)</code> <code>sinpi()</code> <code>sin(pi*x)</code> <code>tanpi()</code> <code>tan(pi*x)</code> <code>cosh()</code> Hyperbolic cosine <code>sinh()</code> Hyperbolic sine <code>tanh()</code> Hyperbolic tangent <code>acosh()</code> Hyperbolic cosine <code>asinh()</code> Hyperbolic sine <code>atanh()</code> Hyperbolic tangent"},{"location":"reference-maps/base/#which","title":"Which","text":"API Description Notebook example which() Which indices are True? which_min() which_max() Where is the minimum or maximum or first TRUE or FALSE"},{"location":"reference-maps/base/#other-functions","title":"Other functions","text":"API Description Notebook example <code>glimpse()</code> Get a glimpse of your data <code>cut()</code> Convert Numeric to Factor <code>diff()</code> Returns suitably lagged and iterated differences. <code>identity()</code> Identity Function <code>expandgrid()</code> Create a Data Frame from All Combinations of Factor Variables <code>outer()</code> Compute the outer product of two vectors. <code>max_col()</code> Find the maximum position for each row of a matrix <code>append()</code> Add elements to a vector. <code>complete_cases()</code> Get a bool array indicating whether the values of rows are complete in a data frame. <code>proportions()</code>, <code>prop_table</code> Returns conditional proportions given <code>margins</code> <code>make_names()</code> Make names available as columns and can be accessed by <code>df.&lt;name&gt;</code> <code>make_unique()</code> Make the names unique, alias of <code>make_names(names, unique=True)</code>"},{"location":"reference-maps/datasets/","title":"Datasets","text":""},{"location":"reference-maps/datasets/#reference-of-datardata","title":"Reference of <code>datar.data</code>","text":"API Description Source <code>airlines</code> translation between two letter carrier codes and names <code>r-nycflights13</code> <code>airports</code> airport names and locations <code>r-nycflights13</code> <code>flights</code> all flights that departed from NYC in 2013 <code>r-nycflights13</code> <code>weather</code> hourly meterological data for each airport <code>r-nycflights13</code> <code>planes</code> construction information about each plane <code>r-nycflights13</code> # # # <code>state_abb</code> character vector of 2-letter abbreviations for the state names. <code>r-datasets-state</code> <code>state_division</code> factor giving state divisions (New England, Middle Atlantic, South Atlantic, East South Central, West South Central, East North Central, West North Central, Mountain, and Pacific). <code>r-datasets-state</code> <code>state_region</code> factor giving the region (Northeast, South, North Central, West) that each state belongs to. <code>r-datasets-state</code> # # # <code>airquality</code> Daily air quality measurements in New York, May to September 1973. <code>r-datasets-airquality</code> <code>anscombe</code> Four x-y datasets which have the same traditional statistical properties <code>r-datasets-anscombe</code> <code>faithful</code> Waiting time between eruptions and the duration of the eruption for the Old Faithful geyser in Yellowstone National Park, Wyoming, USA <code>r-datasets-faithful</code> <code>iris</code> Edgar Anderson's Iris Data <code>r-datasets-iris</code> <code>mtcars</code> Motor Trend Car Road Tests <code>r-datasets-mtcars</code> <code>warpbreaks</code> The Number of Breaks in Yarn during Weaving <code>r-datasets-warpbreaks</code> <code>ToothGrowth</code> The Effect of Vitamin C on Tooth Growth in Guinea Pigs <code>r-datasets-ToothGrowth</code> # # # <code>band_instruments</code> Band members of the Beatles and Rolling Stones <code>r-dplyr-band_members</code> <code>band_instruments2</code> Band members of the Beatles and Rolling Stones <code>r-dplyr-band_members</code> <code>band_members</code> Band members of the Beatles and Rolling Stones <code>r-dplyr-band_members</code> # # # <code>table1</code> Example tabular representations <code>r-dplyr-storms</code> <code>table2</code> Example tabular representations <code>r-dplyr-storms</code> <code>table3</code> Example tabular representations <code>r-dplyr-storms</code> <code>table4a</code> Example tabular representations <code>r-dplyr-storms</code> <code>table4b</code> Example tabular representations <code>r-dplyr-storms</code> <code>table5</code> Example tabular representations <code>r-dplyr-storms</code> # # # <code>starwars</code> Starwars characters (columns <code>films</code>, <code>vehicles</code> and <code>starships</code> are not included) <code>r-dplyr-starwars</code> <code>storms</code> This data is a subset of the NOAA Atlantic hurricane database best track data <code>r-dplyr-storms</code> <code>us_rent_income</code> US rent and income data <code>r-dplyr-us_rent_income</code> <code>world_bank_pop</code> Population data from the world bank <code>r-dplyr-world_bank_pop</code> # # # <code>billboard</code> Song rankings for Billboard top 100 in the year 2000 <code>r-tidyr-billboard</code> <code>construction</code> Completed construction in the US in 2018 <code>r-tidyr-construction</code> <code>fish_encounters</code> Information about fish swimming down a river <code>r-tidyr-fish_encounters</code> <code>population</code> A subset of data from the World Health Organization Global Tuberculosis Report, and accompanying global populations. <code>r-tidyr-who</code> <code>relig_income</code> Pew religion and income survey <code>r-tidyr-relig_income</code> <code>smiths</code> A small demo dataset describing John and Mary Smith. <code>r-tidyr-smiths</code> <code>who</code> A subset of data from the World Health Organization Global Tuberculosis Report, and accompanying global populations. <code>r-tidyr-who</code> # # # <code>diamonds</code> A dataset containing the prices and other attributes of almost 54,000 diamonds <code>r-ggplot2-diamonds</code> <code>economics</code> <code>economics_long</code> US economic time series <code>r-ggplot2-economics</code> <code>faithfuld</code> 2d density estimate of Old Faithful data <code>r-ggplot2-faithfuld</code> <code>midwest</code> Midwest demographics <code>r-ggplot2-midwest</code> <code>mpg</code> Fuel economy data from 1999 to 2008 for 38 popular models of cars <code>r-ggplot2-mpg</code> <code>msleep</code> An updated and expanded version of the mammals sleep dataset <code>r-ggplot2-msleep</code> <code>presidential</code> Terms of 11 presidents from Eisenhower to Obama <code>r-ggplot2-presidential</code> <code>seals</code> Vector field of seal movements <code>r-ggplot2-seals</code> <code>txhousing</code> Housing sales in TX <code>r-ggplot2-txhousing</code> <code>luv_colours</code> <code>colors()</code> in Luv space <code>r-ggplot2-luv_colours</code> # # <code>gss_cat</code> A sample of categorical variables from the General Social survey <code>r-forcats-gss_cat</code>"},{"location":"reference-maps/dplyr/","title":"Dplyr","text":""},{"location":"reference-maps/dplyr/#reference-of-datardplyr","title":"Reference of <code>datar.dplyr</code>","text":"<p>Reference map of <code>r-tidyverse-dplyr</code> can be found here.</p> <p>Legend:</p> Sample Status normal API that is regularly ported strike-through API that is not ported, or not an API originally bold API that is unique in <code>datar</code> italic Working in process"},{"location":"reference-maps/dplyr/#one-table-verbs","title":"One table verbs","text":"API Description Notebook example arrange() Arrange rows by column values count() tally() add_count() add_tally() Count observations by group distinct() Subset distinct/unique rows filter() Subset rows using column values mutate() transmute() Create, modify, and delete columns pull() Extract a single column relocate() Change column order rename() rename_with() Rename columns select() Subset columns using their names and types summarise() summarize() Summarise each group to fewer rows slice() slice_head() slice_tail() slice_min() slice_max() slice_sample() Subset rows using their positions"},{"location":"reference-maps/dplyr/#two-table-verbs","title":"Two table verbs","text":"API Description Notebook example bind_rows() bind_cols() Efficiently bind multiple data frames by row and column intersect() setdiff() setequal() union() Set operations on data frame all_of() any_of() contains() ends_with() everything() last_col() matches() num_range() one_of() starts_with() Select variables from character vectors union_all() Set operations inner_join() left_join() right_join() full_join() Mutating joins nest_join() Nest join semi_join() anti_join() Filtering joins"},{"location":"reference-maps/dplyr/#grouping","title":"Grouping","text":"API Description Notebook example group_by() ungroup() Group by one or more variables group_cols() group_vars() Select grouping variables rowwise() Group input by rows"},{"location":"reference-maps/dplyr/#vector-functions","title":"Vector functions","text":"API Description Notebook example across() if_any() if_all() Apply a function (or functions) across multiple columns c_across() Combine values from multiple columns between() Do values in a numeric vector fall in specified range? case_when() A general vectorised if coalesce() Find first non-missing element cumall() cumany() cummean() Cumulativate versions of any, all, and mean desc() Descending order if_else() Vectorised if lag() lead() Compute lagged or leading values order_by() A helper function for ordering window function output n() cur_data() cur_data_all() cur_group() cur_group_id() cur_group_rows() cur_column() Context dependent expressions n_distinct() Efficiently count the number of unique values in a set of vectors na_if() Convert values to NA near() Compare two numeric vectors nth() first() last() Extract the first, last or nth value from a vector row_number() ntile() min_rank() dense_rank() percent_rank() cume_dist() Windowed rank functions. recode() recode_factor() Recode values"},{"location":"reference-maps/dplyr/#data","title":"Data","text":"<p>See datasets</p>"},{"location":"reference-maps/dplyr/#remote-tables","title":"Remote tables","text":""},{"location":"reference-maps/dplyr/#experimental","title":"Experimental","text":"API Description Notebook example group_map() group_modify() group_walk() Apply a function to each group group_trim() Trim grouping structure group_split() Split data frame by groups with_groups() Perform an operation with temporary groups rows_insert() rows_update() rows_patch() rows_upsert() rows_delete() Manipulate individual rows"},{"location":"reference-maps/dplyr/#questioning","title":"Questioning","text":""},{"location":"reference-maps/dplyr/#superseded","title":"Superseded","text":""},{"location":"reference-maps/forcats/","title":"Forcats","text":""},{"location":"reference-maps/forcats/#reference-of-datarforcats","title":"Reference of <code>datar.forcats</code>","text":"<p>Reference map of <code>r-tidyverse-forcats</code> can be found here.</p> <p>Legend:</p> Sample Status normal API that is regularly ported strike-through API that is not ported, or not an API originally bold API that is unique in <code>datar</code> italic Working in process"},{"location":"reference-maps/forcats/#change-order-of-levels","title":"Change order of levels","text":"API Description Notebook example fct_relevel() Reorder factor levels by hand fct_inorder() fct_infreq() fct_inseq() Reorder factor levels by first appearance, frequency, or numeric order fct_reorder() fct_reorder2() last2() first2() Reorder factor levels by sorting along another variable fct_shuffle() Randomly permute factor levels fct_rev() Reverse order of factor levels fct_shift() Shift factor levels to left or right, wrapping around at end"},{"location":"reference-maps/forcats/#change-value-of-levels","title":"Change value of levels","text":"API Description Notebook example fct_anon() Anonymise factor levels fct_collapse() Collapse factor levels into manually defined groups fct_lump() fct_lump_min() fct_lump_prop() fct_lump_n() fct_lump_lowfreq() Lump together actor levels into \"other\" fct_other() Replace levels with \"other\" fct_recode() Change factor levels by hand fct_relabel() Automatically relabel factor levels, collapse as necessary"},{"location":"reference-maps/forcats/#addremove-levels","title":"Add/remove levels","text":"API Description Notebook example fct_expand() Add additional levels to a factor fct_explicit_na() Make missing values explicit fct_drop() Drop unused levels fct_unify() Unify the levels in a list of factors"},{"location":"reference-maps/forcats/#combine-multiple-factors","title":"Combine multiple factors","text":"API Description Notebook example fct_c() Concatenate factors, combining levels fct_cross() Combine levels from two or more factors to create a new factor"},{"location":"reference-maps/forcats/#other-helpers","title":"Other helpers","text":"API Description Notebook example as_factor() Convert input to a factor fct_count() Count entries in a factor fct_match() Test for presence of levels in a factor fct_unique() Unique values of a factor lvls_reorder() lvls_revalue() lvls_expand() Low-level functions for manipulating levels lvls_union() Find all levels in a list of factors"},{"location":"reference-maps/other/","title":"Other","text":""},{"location":"reference-maps/other/#reference-of-datardatar","title":"Reference of <code>datar.datar</code>","text":"<p>Legend:</p> Sample Status normal API that is regularly ported strike-through API that is not ported, or not an API originally bold API that is unique in <code>datar</code> italic Working in process"},{"location":"reference-maps/other/#verbs","title":"Verbs","text":"API Description Notebook example <code>get()</code> Extract values from data frames <code>flatten()</code> Flatten values of data frames"},{"location":"reference-maps/other/#functions","title":"Functions","text":"<p>|<code>itemgetter()</code>|Turn <code>a[f.x]</code> to a valid verb argument with <code>itemgetter(a, f.x)</code>|| |<code>attrgetter()</code>|<code>f.x.&lt;attr&gt;</code> but works with <code>SeriesGroupBy</code> object|| |<code>pd_str()</code>|<code>str</code> accessor but works with <code>SeriesGroupBy</code> object|| |<code>pd_cat()</code>|<code>cat</code> accessor but works with <code>SeriesGroupBy</code> object|| |<code>pd_dt()</code>|<code>dt</code> accessor but works with <code>SeriesGroupBy</code> object||</p>"},{"location":"reference-maps/stats/","title":"Stats","text":""},{"location":"reference-maps/stats/#reference-of-datardatar","title":"Reference of <code>datar.datar</code>","text":"<p>Legend:</p> Sample Status normal API that is regularly ported strike-through API that is not ported, or not an API originally bold API that is unique in <code>datar</code> italic Working in process"},{"location":"reference-maps/stats/#stats","title":"Stats","text":"API Description Notebook example <code>rnorm()</code> Generates random deviates for the normal distribution <code>rpois()</code> Generates random deviates for the Poisson distribution <code>runif()</code> Generates random deviates for the uniform distribution"},{"location":"reference-maps/tibble/","title":"Tibble","text":""},{"location":"reference-maps/tibble/#reference-of-datartibble","title":"Reference of <code>datar.tibble</code>","text":"<p>Reference map of <code>r-tidyverse-tibble</code> can be found here.</p> <p>Legend:</p> Sample Status normal API that is regularly ported strike-through API that is not ported, or not an API originally bold API that is unique in <code>datar</code> italic Working in process"},{"location":"reference-maps/tibble/#tibbles","title":"Tibbles","text":"<p>Tip</p> <p>Tibbles in <code>datar</code> are just <code>pandas.DataFrame</code>s. So there is no difference between data frames created by <code>tibble()</code> and <code>pandas.DataFrame</code>, unlike in R, <code>tibble</code> and <code>data.frame</code>.</p> <p>Also note that tibbles in <code>datar</code> are not <code>rownames</code>/<code>index</code> aware for most APIs, just like most <code>tidyverse</code> APIs.</p> API Description Notebook example <code>tibble-package</code> <code>tibble()</code> <code>tibble_row()</code> Build a data frame <code>fibble()</code> Same as <code>tibble()</code> but used as Verb arguments <code>tbl_df-class</code> <code>print(&lt;tbl_df&gt;)</code> <code>format(&lt;tbl_df&gt;)</code> <code>tribble()</code> Row-wise tibble creation"},{"location":"reference-maps/tibble/#coercion","title":"Coercion","text":"API Description Notebook example <code>is_tibble()</code> <code>as_tibble()</code> Convert data frames into datar's tibbles <code>new_tibble()</code> <code>validate_tibble()</code> <code>enframe()</code> <code>deframe()</code> Converting iterables to data frames, and vice versa"},{"location":"reference-maps/tibble/#manipulation","title":"Manipulation","text":"API Description Notebook example <code>$</code> <code>[[</code> <code>[</code> Please subset data frames using <code>pandas</code> syntax (<code>df.col</code>, <code>df['col']</code>, <code>df.loc[...]</code> or <code>df.iloc[...]</code> <code>add_row()</code> Add rows to a data frame <code>add_column()</code> Add columns to a data frame"},{"location":"reference-maps/tibble/#helpers","title":"Helpers","text":"API Description Notebook example <code>reexports</code> <code>has_rownames()</code>/<code>has_index()</code> <code>remove_rownames()</code>/<code>remove_index()</code>/<code>drop_index()</code> <code>rownames_to_column()</code>/<code>index_to_column()</code> <code>rowid_to_column()</code> <code>column_to_rownames()</code>/<code>column_to_index()</code> Tools for working with row names/DataFrame indexes <code>view()</code>"},{"location":"reference-maps/tibble/#vectors-matrices-and-lists","title":"Vectors, matrices, and lists","text":""},{"location":"reference-maps/tidyr/","title":"Tidyr","text":""},{"location":"reference-maps/tidyr/#reference-of-datardplyr","title":"Reference of <code>datar.dplyr</code>","text":"<p>Reference map of <code>r-tidyverse-tidyr</code> can be found here.</p> <p>Legend:</p> Sample Status normal API that is regularly ported strike-through API that is not ported, or not an API originally bold API that is unique in <code>datar</code> italic Working in process"},{"location":"reference-maps/tidyr/#pivoting","title":"Pivoting","text":"API Description Notebook example pivot_longer() Pivot data from wide to long pivot_wider() Pivot data from long to wide"},{"location":"reference-maps/tidyr/#rectangling","title":"Rectangling","text":"API Description Notebook example <code>hoist()</code> <code>unnest_longer()</code> <code>unnest_wider()</code> <code>unnest_auto()</code> Rectangle a nested list into a tidy tibble"},{"location":"reference-maps/tidyr/#nesting","title":"Nesting","text":"API Description Notebook example <code>nest()</code> <code>unnest()</code> Nest and unnest"},{"location":"reference-maps/tidyr/#character-vectors","title":"Character vectors","text":"API Description Notebook example <code>extract()</code> Extract a character column into multiple columns using regular expression groups <code>separate()</code> Separate a character column into multiple columns with a regular expression or numeric locations <code>separate_rows()</code> Separate a collapsed column into multiple rows <code>unite()</code> Unite multiple columns into one by pasting strings together"},{"location":"reference-maps/tidyr/#missing-values","title":"Missing values","text":"API Description Notebook example <code>complete()</code> Complete a data frame with missing combinations of data <code>drop_na()</code> Drop rows containing missing values <code>expand()</code> <code>crossing()</code> <code>nesting()</code> Expand data frame to include all possible combinations of values <code>expand_grid()</code> <code>fill()</code> Fill in missing values with previous or next value <code>full_seq()</code> Create the full sequence of values in a vector <code>replace_na()</code> Replace NAs with specified values"},{"location":"reference-maps/tidyr/#miscellanea","title":"Miscellanea","text":"API Description Notebook example <code>chop()</code> <code>unchop()</code> Chop and unchop <code>pack()</code> <code>unpack()</code> Pack and unpack <code>uncount()</code> \"Uncount\" a data frame"},{"location":"reference-maps/tidyr/#data","title":"Data","text":"<p>See datasets</p>"},{"location":"reference-maps/utils/","title":"Utils","text":""},{"location":"reference-maps/utils/#reference-of-datardatar","title":"Reference of <code>datar.datar</code>","text":"<p>Legend:</p> Sample Status normal API that is regularly ported strike-through API that is not ported, or not an API originally bold API that is unique in <code>datar</code> italic Working in process"},{"location":"reference-maps/utils/#utils","title":"Utils","text":"API Description Notebook example <code>head()</code> Get the head of the object <code>tail()</code> Get the tail of the object"}]}